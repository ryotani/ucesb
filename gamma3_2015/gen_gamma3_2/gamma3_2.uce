
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

CAEN_V775(geom,crate)
{
  MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_07: undefined;
     8_13: count;
    16_23: crate = MATCH(crate);
    24_26: 2;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
         12: overflow;
         13: underflow;
         14: valid;
      16_20: channel;
      24_26: 0;
      27_31: geom = CHECK(geom);
      ENCODE(data[channel],(value=value,overflow=overflow));
    }
  }
  UINT32 eob
  {
     0_23: event_number;
    24_26: 4;
    27_31: geom = CHECK(geom);
  }
}

CAEN_V830_SCALER(id)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 sc_header
  {
     0_06: count = RANGE(0,31);
    24_31: id = MATCH(id);
  }
  UINT32 header
  {
     0_15: event_number;
    16_17: ts;
    18_23: count;
    24_25: undefined;
       26: 1;
    27_31: geom;
  }
  list(0<=index<header.count)
  {
    UINT32 sc NOENCODE
    {
       0_25: value;
         26: 0;
      27_31: channel;
      ENCODE(data[channel],(value=value));
    }
  }
}

CAMAC_LECROY_4434(channels)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    UINT32 ch_data NOENCODE
    {
       0_23: value;
      24_31: 0;
      ENCODE(data[index],(value=value));
    }
  }
}

CAMAC_PHILLIPS_7164(channels,mark_channel_no)
{
  MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    if(mark_channel_no)
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        12_15: channel = CHECK(index);
        ENCODE(data[index],(value=value));
      }
    }
    else
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        ENCODE(data[index],(value=value));
      }
    }
  }
}

CAMAC_SILENA_4418(channels,mark_channel_no)
{
  MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    if(mark_channel_no)
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        12_14: channel = CHECK(index);
           15: overflow;
        ENCODE(data[index],(value=value,overflow=overflow));
      }
    }
    else
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
           15: overflow;
        ENCODE(data[index],(value=value,overflow=overflow));
      }
    }
  }
}

FASTBUS_LECROY_1875(geom,channels)
{
  MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  UINT32 ch_data NOENCODE
  {
     0_11: value;
    16_21: channel = RANGE(0,(channels - 1));
       23: range;
    24_26: n = CHECK(0);
    27_31: geom = MATCH(geom);
    ENCODE(data[channel],(value=value,range=range));
  }
}

FASTBUS_LECROY_1885(geom,channels)
{
  MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  UINT32 ch_data NOENCODE
  {
     0_11: value;
    16_22: channel = RANGE(0,(channels - 1));
       23: range;
    24_26: n = CHECK(0);
    27_31: geom = MATCH(geom);
    ENCODE(data[channel],(value=value,range=range));
  }
}

LAND_STD_VME()
{
  MEMBER(DATA32 timestamp);
  UINT32 failure
  {
        0: fail_general;
        1: fail_data_corrupt;
        2: fail_data_missing;
        3: fail_data_too_much;
        4: fail_event_counter_mismatch;
        5: fail_readout_error_driver;
        6: fail_unexpected_trigger;
       26: has_scaler_data;
       27: has_no_zero_suppression;
       28: has_multi_adctdc_counter0;
       29: has_multi_scaler_counter0;
       30: has_multi_event;
       31: has_time_stamp;
  }
  if(failure.has_time_stamp)
  {
    UINT32 time_stamp
    {
       0_31: value;
      ENCODE(timestamp,(value=value));
    }
  }
  if(failure.has_multi_event)
  {
    UINT32 multi_events;
  }
  if(failure.has_multi_scaler_counter0)
  {
    UINT32 multi_scaler_counter0;
  }
  if(failure.has_multi_adctdc_counter0)
  {
    UINT32 multi_adctdc_counter0;
  }
}

SERIAL_TS()
{
  UINT32 header NOENCODE
  {
     0_31: multi_events;
  }
  list(0<=i<header.multi_events)
  {
    multi event = SERIAL_TS_EVENT();
  }
}

SERIAL_TS_EVENT()
{
  MEMBER(DATA32 ts_hi);
  MEMBER(DATA32 ts_lo);
  UINT32 ts_lsb NOENCODE
  {
     0_31: t_lsb;
    ENCODE(ts_lo,(value=t_lsb));
  }
  UINT32 ts_msb NOENCODE
  {
     0_30: t_msb;
       31: missed_event;
    ENCODE(ts_hi,(value=t_msb));
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TRIGBUF(multi_events)
{
  UINT32 header
  {
     0_11: entries;
    12_31: multi_events;
  }
  list(0<=i<multi_events)
  {
    multi entry = TRIGBUF_ENTRY();
  }
}

TRIGBUF_ENTRY()
{
  MEMBER(DATA32 ts_hi);
  MEMBER(DATA32 ts_lo);
  MEMBER(DATA32 tpat);
  MEMBER(DATA8 trig);
  UINT32 ts_lsb NOENCODE
  {
     0_31: t_lsb;
    ENCODE(ts_lo,(value=t_lsb));
  }
  UINT32 ts_msb NOENCODE
  {
     0_30: t_msb;
       31: missed_event;
    ENCODE(ts_hi,(value=t_msb));
  }
  UINT32 info NOENCODE
  {
     0_23: tpat;
    24_27: trig;
    28_31: cnt;
    ENCODE(tpat,(value=tpat));
    ENCODE(trig,(value=trig));
  }
}

TRLO(id,multi_events)
{
  wr_ts = TIMESTAMP_WHITERABBIT(id=id);
  serial_ts = SERIAL_TS();
  trigbuf = TRIGBUF(multi_events=multi_events);
}

TRLO_EVENT_TRIGGER()
{
  UINT32 time_lo
  {
     0_31: val;
  }
  UINT32 time_hi
  {
     0_30: val;
       31: missed_event;
  }
  UINT32 status
  {
     0_23: tpat;
    24_27: trig;
    28_31: count;
  }
}

TRLO_SAMPLER(id)
{
  MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  UINT32 header
  {
     0_09: count;
       10: missing_at_end;
    24_31: id = MATCH(id);
  }
  list(0<=index<header.count)
  {
    UINT32 data NOENCODE
    {
       0_31: stamp;
      ENCODE(stamps APPEND_LIST,(value=stamp));
    }
  }
}

TRLO_TRIG_SCALER(id)
{
  MEMBER(DATA32 before_lmu[16] ZERO_SUPPRESS);
  MEMBER(DATA32 before_lmu_mux[1] ZERO_SUPPRESS);
  MEMBER(DATA32 before_lmu_aux[4] ZERO_SUPPRESS);
  MEMBER(DATA32 before_deadtime[16] ZERO_SUPPRESS);
  MEMBER(DATA32 after_deadtime[16] ZERO_SUPPRESS);
  MEMBER(DATA32 after_reduction[16] ZERO_SUPPRESS);
  UINT32 header
  {
     0_05: before_lmu = RANGE(0,16);
     6_10: before_lmu_mux = RANGE(0,1);
    11_15: before_lmu_aux = RANGE(0,4);
    16_21: after_lmu = RANGE(0,16);
    24_31: id = MATCH(id);
  }
  list(0<=index<header.before_lmu)
  {
    UINT32 b_lmu NOENCODE
    {
       0_31: value;
      ENCODE(before_lmu[index],(value=value));
    }
  }
  list(0<=index<header.before_lmu_mux)
  {
    UINT32 b_lmu_mux NOENCODE
    {
       0_31: value;
      ENCODE(before_lmu_mux[index],(value=value));
    }
  }
  list(0<=index<header.before_lmu_aux)
  {
    UINT32 b_lmu_aux NOENCODE
    {
       0_31: value;
      ENCODE(before_lmu_aux[index],(value=value));
    }
  }
  list(0<=index<header.after_lmu)
  {
    UINT32 b_deadtime NOENCODE
    {
       0_31: value;
      ENCODE(before_deadtime[index],(value=value));
    }
  }
  list(0<=index<header.after_lmu)
  {
    UINT32 a_deadtime NOENCODE
    {
       0_31: value;
      ENCODE(after_deadtime[index],(value=value));
    }
  }
  list(0<=index<header.after_lmu)
  {
    UINT32 a_reduction NOENCODE
    {
       0_31: value;
      ENCODE(after_reduction[index],(value=value));
    }
  }
  list(0<=index<16)
  {
    UINT32 val;
  }
}

VME_CAEN_V1190(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   data=data);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1190_SHORT(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         data=data);
    norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  UINT32 ch_data NOENCODE
  {
     0_18: value;
    19_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  }
}

VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
{
  UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
}

VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(tdc_start);
  UINT32 header
  {
     0_11: bunch_id;
    12_23: event_id = CHECK(event_id);
    24_25: tdc = MATCH(tdc);
    27_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_18: value;
    19_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  }
  optional UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
  MARK_COUNT(tdc_end);
  UINT32 trailer
  {
     0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    12_23: event_id = CHECK(header.event_id);
    24_25: tdc = CHECK(tdc);
    27_31: 3;
  }
}

VME_CAEN_V1290(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   data=data);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1290_SHORT(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         data=data);
    norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  UINT32 ch_data NOENCODE
  {
     0_20: value;
    21_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  }
}

VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
{
  UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
}

VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(tdc_start);
  UINT32 header
  {
     0_11: bunch_id;
    12_23: event_id = CHECK(event_id);
    24_25: tdc = MATCH(tdc);
    27_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_20: value;
    21_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  }
  optional UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
  MARK_COUNT(tdc_end);
  UINT32 trailer
  {
     0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    12_23: event_id = CHECK(header.event_id);
    24_25: tdc = CHECK(tdc);
    27_31: 3;
  }
}

VME_CAEN_V775(geom,crate)
{
  MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     8_13: count;
    16_23: crate = MATCH(crate);
    24_26: 2;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
         12: overflow;
         13: underflow;
         14: valid;
      16_20: channel;
      24_26: 0;
      27_31: geom = CHECK(geom);
      ENCODE(data[channel],(value=value,overflow=overflow));
    }
  }
  UINT32 eob
  {
     0_23: event_number;
    24_26: 4;
    27_31: geom = CHECK(geom);
  }
}

VME_CAEN_V830(geom)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 header
  {
     0_15: event_number;
    16_17: ts;
    18_23: count;
       26: 1;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_25: value;
         26: 0;
      27_31: channel;
      ENCODE(data[channel],(value=value));
    }
  }
}

VME_MESYTEC_MADC32(geom)
{
  MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_14: adc_resol;
       15: out_form;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_12: value;
       14: outofrange;
    16_20: channel;
    21_29: 32;
    30_31: 0;
    ENCODE(data[channel],(value=value,overflow=outofrange));
  }
  optional UINT32 filler NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

VME_MESYTEC_MDPP16(geom)
{
  MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_09: word_number;
    10_12: adc_res;
    13_15: tdc_res;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_15: value;
    16_21: channel;
       22: overflow;
       23: pileup;
    24_27: 0;
    28_31: 1;
    ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  }
  several UINT32 fill_word NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

VME_MESY_MADC32(geom)
{
  MEMBER(DATA16 data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_14: adc_resol;
       15: out_form;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  list(0<=index<(header.word_number - 1))
  {
    UINT32 ch_data NOENCODE
    {
       0_12: value;
         14: outofrange;
      16_20: channel;
      21_29: 32;
      30_31: 0;
      ENCODE(data[channel],(value=value));
    }
  }
  UINT32 end_of_event NOENCODE
  {
     0_29: counter;
    30_31: 3;
  }
}

VME_MESY_MADC32_PADDING()
{
  UINT32 padding NOENCODE
  {
     0_31: value = MATCH(0x32323232);
  }
}

VME_STRUCK_SIS3316(id)
{
  MEMBER(DATA8 n_ch);
  UINT32 header NOENCODE
  {
     0_07: id = MATCH(id);
     8_15: nofCH;
    16_31: module = MATCH(0x3316);
    ENCODE(n_ch,(value=nofCH));
  }
  select several
  {
    channel[0] = VME_STRUCK_SIS3316_CHANNEL(ch=0,id=id);
    channel[1] = VME_STRUCK_SIS3316_CHANNEL(ch=1,id=id);
    channel[2] = VME_STRUCK_SIS3316_CHANNEL(ch=2,id=id);
    channel[3] = VME_STRUCK_SIS3316_CHANNEL(ch=3,id=id);
    channel[4] = VME_STRUCK_SIS3316_CHANNEL(ch=4,id=id);
    channel[5] = VME_STRUCK_SIS3316_CHANNEL(ch=5,id=id);
    channel[6] = VME_STRUCK_SIS3316_CHANNEL(ch=6,id=id);
    channel[7] = VME_STRUCK_SIS3316_CHANNEL(ch=7,id=id);
    channel[8] = VME_STRUCK_SIS3316_CHANNEL(ch=8,id=id);
    channel[9] = VME_STRUCK_SIS3316_CHANNEL(ch=9,id=id);
    channel[10] = VME_STRUCK_SIS3316_CHANNEL(ch=10,id=id);
    channel[11] = VME_STRUCK_SIS3316_CHANNEL(ch=11,id=id);
    channel[12] = VME_STRUCK_SIS3316_CHANNEL(ch=12,id=id);
    channel[13] = VME_STRUCK_SIS3316_CHANNEL(ch=13,id=id);
    channel[14] = VME_STRUCK_SIS3316_CHANNEL(ch=14,id=id);
    channel[15] = VME_STRUCK_SIS3316_CHANNEL(ch=15,id=id);
  }
}

VME_STRUCK_SIS3316_CHANNEL(id,ch)
{
  UINT32 channel_header NOENCODE
  {
     0_07: id = MATCH(id);
     8_11: ch = MATCH(ch);
    12_15: padding_words;
    16_31: module = MATCH(0x3316);
  }
  list(0<=n<channel_header.padding_words)
  {
    UINT32 padding NOENCODE
    {
       0_07: id = MATCH(id);
       8_15: ch = MATCH(ch);
      16_31: module = MATCH(0x3316);
    }
  }
  select several
  {
    multi data = VME_STRUCK_SIS3316_CHANNEL_DATA(id=id,ch=ch);
  }
}

VME_STRUCK_SIS3316_CHANNEL_DATA(id,ch)
{
  MEMBER(DATA32 ts[2] ZERO_SUPPRESS);
  MEMBER(DATA32 gate[8] ZERO_SUPPRESS);
  MEMBER(DATA32 maw[3] ZERO_SUPPRESS);
  MEMBER(DATA32 maxe[2] ZERO_SUPPRESS);
  UINT32 header0
  {
        0: has_acc6;
        1: has_acc2;
        2: has_maw;
        3: has_e;
     4_07: chanNo = MATCH(ch);
     8_15: id = MATCH(id);
    16_31: timeS;
    ENCODE(ts[0],(value=timeS));
  }
  UINT32 header2
  {
     0_31: timeS;
    ENCODE(ts[1],(value=timeS));
  }
  if(header0.has_acc6)
  {
    UINT32 peak NOENCODE
    {
       0_15: peakValue;
      16_31: peakIndex;
    }
    UINT32 gate_group_1
    {
       0_23: sum;
      24_27: reserved;
         28: has_pileup;
         29: has_repileup;
         30: has_underflow;
         31: has_overflow;
      ENCODE(gate[0],(value=sum));
    }
    list(1<=i<6)
    {
      UINT32 gate_group_2_6
      {
         0_27: sum;
        28_31: 0;
        ENCODE(gate[i],(value=sum));
      }
    }
  }
  if(header0.has_acc2)
  {
    list(6<=i<8)
    {
      UINT32 gate_group_7_8
      {
         0_27: sum;
        28_31: 0;
        ENCODE(gate[i],(value=sum));
      }
    }
  }
  if(header0.has_maw)
  {
    UINT32 maw1
    {
       0_31: max;
      ENCODE(maw[0],(value=max));
    }
    UINT32 maw2
    {
       0_31: after;
      ENCODE(maw[1],(value=after));
    }
    UINT32 maw3
    {
       0_31: before;
      ENCODE(maw[2],(value=before));
    }
  }
  if(header0.has_e)
  {
    UINT32 maxe1
    {
       0_31: start;
      ENCODE(maxe[0],(value=(start + 0x08000000)));
    }
    UINT32 maxe2
    {
       0_31: max;
      ENCODE(maxe[1],(value=(max + 0x08000000)));
    }
  }
  UINT32 header3
  {
     0_25: sampleLength;
       26: pileup;
       27: mawFlag;
    28_31: 14;
  }
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

SUBEVENT(SCALERS)
{
  select several
  {
    trlo = TRLO_TRIG_SCALER(id=18);
    caen_scaler = VME_CAEN_V830(geom=31);
  }
}

SUBEVENT(TS)
{
  trlo = TRLO(id=2,multi_events=29);
}

SUBEVENT(VME)
{
  header = LAND_STD_VME();
  select several
  {
    sis3316[0] = VME_STRUCK_SIS3316(id=3);
    sis3316[1] = VME_STRUCK_SIS3316(id=4);
    sis3316[2] = VME_STRUCK_SIS3316(id=5);
    multi tdc = CAEN_V775(geom=31,crate=0);
    mesy_padding = VME_MESY_MADC32_PADDING();
    multi adc = VME_MESY_MADC32(geom=5);
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  ts = TS(type=10,subtype=1,control=5,subcrate=1);
  vme = VME(type=88,subtype=0x2260,control=5,subcrate=1);
  scalers = SCALERS(type=12,subtype=0xd80,control=5,subcrate=1);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(ADC1CH13MAXE1,vme.sis3316[0].channel[12].data.maxe[0],DATA32);
SIGNAL(ADC1CH13MAXE2,vme.sis3316[0].channel[12].data.maxe[1],DATA32);
SIGNAL(ADC1CH13T1,vme.sis3316[0].channel[12].data.maw[0],DATA32);
SIGNAL(ADC1CH13T2,vme.sis3316[0].channel[12].data.maw[1],DATA32);
SIGNAL(ADC1CH13T3,vme.sis3316[0].channel[12].data.maw[2],DATA32);
SIGNAL(ADC1CH1MAXE1,vme.sis3316[0].channel[0].data.maxe[0],DATA32);
SIGNAL(ADC1CH1MAXE2,vme.sis3316[0].channel[0].data.maxe[1],DATA32);
SIGNAL(ADC1CH1T1,vme.sis3316[0].channel[0].data.maw[0],DATA32);
SIGNAL(ADC1CH1T2,vme.sis3316[0].channel[0].data.maw[1],DATA32);
SIGNAL(ADC1CH1T3,vme.sis3316[0].channel[0].data.maw[2],DATA32);
SIGNAL(ADC1CH5MAXE1,vme.sis3316[0].channel[4].data.maxe[0],DATA32);
SIGNAL(ADC1CH5MAXE2,vme.sis3316[0].channel[4].data.maxe[1],DATA32);
SIGNAL(ADC1CH5T1,vme.sis3316[0].channel[4].data.maw[0],DATA32);
SIGNAL(ADC1CH5T2,vme.sis3316[0].channel[4].data.maw[1],DATA32);
SIGNAL(ADC1CH5T3,vme.sis3316[0].channel[4].data.maw[2],DATA32);
SIGNAL(ADC1CH9MAXE1,vme.sis3316[0].channel[8].data.maxe[0],DATA32);
SIGNAL(ADC1CH9MAXE2,vme.sis3316[0].channel[8].data.maxe[1],DATA32);
SIGNAL(ADC1CH9T1,vme.sis3316[0].channel[8].data.maw[0],DATA32);
SIGNAL(ADC1CH9T2,vme.sis3316[0].channel[8].data.maw[1],DATA32);
SIGNAL(ADC1CH9T3,vme.sis3316[0].channel[8].data.maw[2],DATA32);
SIGNAL(ADC1TS10H,vme.sis3316[0].channel[9].data.ts[0],DATA32);
SIGNAL(ADC1TS10L,vme.sis3316[0].channel[9].data.ts[1],DATA32);
SIGNAL(ADC1TS11H,vme.sis3316[0].channel[10].data.ts[0],DATA32);
SIGNAL(ADC1TS11L,vme.sis3316[0].channel[10].data.ts[1],DATA32);
SIGNAL(ADC1TS12H,vme.sis3316[0].channel[11].data.ts[0],DATA32);
SIGNAL(ADC1TS12L,vme.sis3316[0].channel[11].data.ts[1],DATA32);
SIGNAL(ADC1TS13H,vme.sis3316[0].channel[12].data.ts[0],DATA32);
SIGNAL(ADC1TS13L,vme.sis3316[0].channel[12].data.ts[1],DATA32);
SIGNAL(ADC1TS14H,vme.sis3316[0].channel[13].data.ts[0],DATA32);
SIGNAL(ADC1TS14L,vme.sis3316[0].channel[13].data.ts[1],DATA32);
SIGNAL(ADC1TS15H,vme.sis3316[0].channel[14].data.ts[0],DATA32);
SIGNAL(ADC1TS15L,vme.sis3316[0].channel[14].data.ts[1],DATA32);
SIGNAL(ADC1TS16H,vme.sis3316[0].channel[15].data.ts[0],DATA32);
SIGNAL(ADC1TS16L,vme.sis3316[0].channel[15].data.ts[1],DATA32);
SIGNAL(ADC1TS1H,vme.sis3316[0].channel[0].data.ts[0],DATA32);
SIGNAL(ADC1TS1L,vme.sis3316[0].channel[0].data.ts[1],DATA32);
SIGNAL(ADC1TS2H,vme.sis3316[0].channel[1].data.ts[0],DATA32);
SIGNAL(ADC1TS2L,vme.sis3316[0].channel[1].data.ts[1],DATA32);
SIGNAL(ADC1TS3H,vme.sis3316[0].channel[2].data.ts[0],DATA32);
SIGNAL(ADC1TS3L,vme.sis3316[0].channel[2].data.ts[1],DATA32);
SIGNAL(ADC1TS4H,vme.sis3316[0].channel[3].data.ts[0],DATA32);
SIGNAL(ADC1TS4L,vme.sis3316[0].channel[3].data.ts[1],DATA32);
SIGNAL(ADC1TS5H,vme.sis3316[0].channel[4].data.ts[0],DATA32);
SIGNAL(ADC1TS5L,vme.sis3316[0].channel[4].data.ts[1],DATA32);
SIGNAL(ADC1TS6H,vme.sis3316[0].channel[5].data.ts[0],DATA32);
SIGNAL(ADC1TS6L,vme.sis3316[0].channel[5].data.ts[1],DATA32);
SIGNAL(ADC1TS7H,vme.sis3316[0].channel[6].data.ts[0],DATA32);
SIGNAL(ADC1TS7L,vme.sis3316[0].channel[6].data.ts[1],DATA32);
SIGNAL(ADC1TS8H,vme.sis3316[0].channel[7].data.ts[0],DATA32);
SIGNAL(ADC1TS8L,vme.sis3316[0].channel[7].data.ts[1],DATA32);
SIGNAL(ADC1TS9H,vme.sis3316[0].channel[8].data.ts[0],DATA32);
SIGNAL(ADC1TS9L,vme.sis3316[0].channel[8].data.ts[1],DATA32);
SIGNAL(ADC2CH10GATE1,vme.sis3316[1].channel[9].data.gate[0],DATA32);
SIGNAL(ADC2CH10GATE2,vme.sis3316[1].channel[9].data.gate[1],DATA32);
SIGNAL(ADC2CH10GATE3,vme.sis3316[1].channel[9].data.gate[2],DATA32);
SIGNAL(ADC2CH10GATE4,vme.sis3316[1].channel[9].data.gate[3],DATA32);
SIGNAL(ADC2CH10GATE5,vme.sis3316[1].channel[9].data.gate[4],DATA32);
SIGNAL(ADC2CH10GATE6,vme.sis3316[1].channel[9].data.gate[5],DATA32);
SIGNAL(ADC2CH10GATE7,vme.sis3316[1].channel[9].data.gate[6],DATA32);
SIGNAL(ADC2CH10GATE8,vme.sis3316[1].channel[9].data.gate[7],DATA32);
SIGNAL(ADC2CH10MAXE1,vme.sis3316[1].channel[9].data.maxe[0],DATA32);
SIGNAL(ADC2CH10MAXE2,vme.sis3316[1].channel[9].data.maxe[1],DATA32);
SIGNAL(ADC2CH10T1,vme.sis3316[1].channel[9].data.maw[0],DATA32);
SIGNAL(ADC2CH10T2,vme.sis3316[1].channel[9].data.maw[1],DATA32);
SIGNAL(ADC2CH10T3,vme.sis3316[1].channel[9].data.maw[2],DATA32);
SIGNAL(ADC2CH13GATE1,vme.sis3316[1].channel[12].data.gate[0],DATA32);
SIGNAL(ADC2CH13GATE2,vme.sis3316[1].channel[12].data.gate[1],DATA32);
SIGNAL(ADC2CH13GATE3,vme.sis3316[1].channel[12].data.gate[2],DATA32);
SIGNAL(ADC2CH13GATE4,vme.sis3316[1].channel[12].data.gate[3],DATA32);
SIGNAL(ADC2CH13GATE5,vme.sis3316[1].channel[12].data.gate[4],DATA32);
SIGNAL(ADC2CH13GATE6,vme.sis3316[1].channel[12].data.gate[5],DATA32);
SIGNAL(ADC2CH13GATE7,vme.sis3316[1].channel[12].data.gate[6],DATA32);
SIGNAL(ADC2CH13GATE8,vme.sis3316[1].channel[12].data.gate[7],DATA32);
SIGNAL(ADC2CH13MAXE1,vme.sis3316[1].channel[12].data.maxe[0],DATA32);
SIGNAL(ADC2CH13MAXE2,vme.sis3316[1].channel[12].data.maxe[1],DATA32);
SIGNAL(ADC2CH13T1,vme.sis3316[1].channel[12].data.maw[0],DATA32);
SIGNAL(ADC2CH13T2,vme.sis3316[1].channel[12].data.maw[1],DATA32);
SIGNAL(ADC2CH13T3,vme.sis3316[1].channel[12].data.maw[2],DATA32);
SIGNAL(ADC2CH14GATE1,vme.sis3316[1].channel[13].data.gate[0],DATA32);
SIGNAL(ADC2CH14GATE2,vme.sis3316[1].channel[13].data.gate[1],DATA32);
SIGNAL(ADC2CH14GATE3,vme.sis3316[1].channel[13].data.gate[2],DATA32);
SIGNAL(ADC2CH14GATE4,vme.sis3316[1].channel[13].data.gate[3],DATA32);
SIGNAL(ADC2CH14GATE5,vme.sis3316[1].channel[13].data.gate[4],DATA32);
SIGNAL(ADC2CH14GATE6,vme.sis3316[1].channel[13].data.gate[5],DATA32);
SIGNAL(ADC2CH14GATE7,vme.sis3316[1].channel[13].data.gate[6],DATA32);
SIGNAL(ADC2CH14GATE8,vme.sis3316[1].channel[13].data.gate[7],DATA32);
SIGNAL(ADC2CH14MAXE1,vme.sis3316[1].channel[13].data.maxe[0],DATA32);
SIGNAL(ADC2CH14MAXE2,vme.sis3316[1].channel[13].data.maxe[1],DATA32);
SIGNAL(ADC2CH14T1,vme.sis3316[1].channel[13].data.maw[0],DATA32);
SIGNAL(ADC2CH14T2,vme.sis3316[1].channel[13].data.maw[1],DATA32);
SIGNAL(ADC2CH14T3,vme.sis3316[1].channel[13].data.maw[2],DATA32);
SIGNAL(ADC2CH1GATE1,vme.sis3316[1].channel[0].data.gate[0],DATA32);
SIGNAL(ADC2CH1GATE2,vme.sis3316[1].channel[0].data.gate[1],DATA32);
SIGNAL(ADC2CH1GATE3,vme.sis3316[1].channel[0].data.gate[2],DATA32);
SIGNAL(ADC2CH1GATE4,vme.sis3316[1].channel[0].data.gate[3],DATA32);
SIGNAL(ADC2CH1GATE5,vme.sis3316[1].channel[0].data.gate[4],DATA32);
SIGNAL(ADC2CH1GATE6,vme.sis3316[1].channel[0].data.gate[5],DATA32);
SIGNAL(ADC2CH1GATE7,vme.sis3316[1].channel[0].data.gate[6],DATA32);
SIGNAL(ADC2CH1GATE8,vme.sis3316[1].channel[0].data.gate[7],DATA32);
SIGNAL(ADC2CH1MAXE1,vme.sis3316[1].channel[0].data.maxe[0],DATA32);
SIGNAL(ADC2CH1MAXE2,vme.sis3316[1].channel[0].data.maxe[1],DATA32);
SIGNAL(ADC2CH1T1,vme.sis3316[1].channel[0].data.maw[0],DATA32);
SIGNAL(ADC2CH1T2,vme.sis3316[1].channel[0].data.maw[1],DATA32);
SIGNAL(ADC2CH1T3,vme.sis3316[1].channel[0].data.maw[2],DATA32);
SIGNAL(ADC2CH2GATE1,vme.sis3316[1].channel[1].data.gate[0],DATA32);
SIGNAL(ADC2CH2GATE2,vme.sis3316[1].channel[1].data.gate[1],DATA32);
SIGNAL(ADC2CH2GATE3,vme.sis3316[1].channel[1].data.gate[2],DATA32);
SIGNAL(ADC2CH2GATE4,vme.sis3316[1].channel[1].data.gate[3],DATA32);
SIGNAL(ADC2CH2GATE5,vme.sis3316[1].channel[1].data.gate[4],DATA32);
SIGNAL(ADC2CH2GATE6,vme.sis3316[1].channel[1].data.gate[5],DATA32);
SIGNAL(ADC2CH2GATE7,vme.sis3316[1].channel[1].data.gate[6],DATA32);
SIGNAL(ADC2CH2GATE8,vme.sis3316[1].channel[1].data.gate[7],DATA32);
SIGNAL(ADC2CH2MAXE1,vme.sis3316[1].channel[1].data.maxe[0],DATA32);
SIGNAL(ADC2CH2MAXE2,vme.sis3316[1].channel[1].data.maxe[1],DATA32);
SIGNAL(ADC2CH2T1,vme.sis3316[1].channel[1].data.maw[0],DATA32);
SIGNAL(ADC2CH2T2,vme.sis3316[1].channel[1].data.maw[1],DATA32);
SIGNAL(ADC2CH2T3,vme.sis3316[1].channel[1].data.maw[2],DATA32);
SIGNAL(ADC2CH5GATE1,vme.sis3316[1].channel[4].data.gate[0],DATA32);
SIGNAL(ADC2CH5GATE2,vme.sis3316[1].channel[4].data.gate[1],DATA32);
SIGNAL(ADC2CH5GATE3,vme.sis3316[1].channel[4].data.gate[2],DATA32);
SIGNAL(ADC2CH5GATE4,vme.sis3316[1].channel[4].data.gate[3],DATA32);
SIGNAL(ADC2CH5GATE5,vme.sis3316[1].channel[4].data.gate[4],DATA32);
SIGNAL(ADC2CH5GATE6,vme.sis3316[1].channel[4].data.gate[5],DATA32);
SIGNAL(ADC2CH5GATE7,vme.sis3316[1].channel[4].data.gate[6],DATA32);
SIGNAL(ADC2CH5GATE8,vme.sis3316[1].channel[4].data.gate[7],DATA32);
SIGNAL(ADC2CH5MAXE1,vme.sis3316[1].channel[4].data.maxe[0],DATA32);
SIGNAL(ADC2CH5MAXE2,vme.sis3316[1].channel[4].data.maxe[1],DATA32);
SIGNAL(ADC2CH5T1,vme.sis3316[1].channel[4].data.maw[0],DATA32);
SIGNAL(ADC2CH5T2,vme.sis3316[1].channel[4].data.maw[1],DATA32);
SIGNAL(ADC2CH5T3,vme.sis3316[1].channel[4].data.maw[2],DATA32);
SIGNAL(ADC2CH6GATE1,vme.sis3316[1].channel[5].data.gate[0],DATA32);
SIGNAL(ADC2CH6GATE2,vme.sis3316[1].channel[5].data.gate[1],DATA32);
SIGNAL(ADC2CH6GATE3,vme.sis3316[1].channel[5].data.gate[2],DATA32);
SIGNAL(ADC2CH6GATE4,vme.sis3316[1].channel[5].data.gate[3],DATA32);
SIGNAL(ADC2CH6GATE5,vme.sis3316[1].channel[5].data.gate[4],DATA32);
SIGNAL(ADC2CH6GATE6,vme.sis3316[1].channel[5].data.gate[5],DATA32);
SIGNAL(ADC2CH6GATE7,vme.sis3316[1].channel[5].data.gate[6],DATA32);
SIGNAL(ADC2CH6GATE8,vme.sis3316[1].channel[5].data.gate[7],DATA32);
SIGNAL(ADC2CH6MAXE1,vme.sis3316[1].channel[5].data.maxe[0],DATA32);
SIGNAL(ADC2CH6MAXE2,vme.sis3316[1].channel[5].data.maxe[1],DATA32);
SIGNAL(ADC2CH6T1,vme.sis3316[1].channel[5].data.maw[0],DATA32);
SIGNAL(ADC2CH6T2,vme.sis3316[1].channel[5].data.maw[1],DATA32);
SIGNAL(ADC2CH6T3,vme.sis3316[1].channel[5].data.maw[2],DATA32);
SIGNAL(ADC2CH9GATE1,vme.sis3316[1].channel[8].data.gate[0],DATA32);
SIGNAL(ADC2CH9GATE2,vme.sis3316[1].channel[8].data.gate[1],DATA32);
SIGNAL(ADC2CH9GATE3,vme.sis3316[1].channel[8].data.gate[2],DATA32);
SIGNAL(ADC2CH9GATE4,vme.sis3316[1].channel[8].data.gate[3],DATA32);
SIGNAL(ADC2CH9GATE5,vme.sis3316[1].channel[8].data.gate[4],DATA32);
SIGNAL(ADC2CH9GATE6,vme.sis3316[1].channel[8].data.gate[5],DATA32);
SIGNAL(ADC2CH9GATE7,vme.sis3316[1].channel[8].data.gate[6],DATA32);
SIGNAL(ADC2CH9GATE8,vme.sis3316[1].channel[8].data.gate[7],DATA32);
SIGNAL(ADC2CH9MAXE1,vme.sis3316[1].channel[8].data.maxe[0],DATA32);
SIGNAL(ADC2CH9MAXE2,vme.sis3316[1].channel[8].data.maxe[1],DATA32);
SIGNAL(ADC2CH9T1,vme.sis3316[1].channel[8].data.maw[0],DATA32);
SIGNAL(ADC2CH9T2,vme.sis3316[1].channel[8].data.maw[1],DATA32);
SIGNAL(ADC2CH9T3,vme.sis3316[1].channel[8].data.maw[2],DATA32);
SIGNAL(ADC2TS10H,vme.sis3316[1].channel[9].data.ts[0],DATA32);
SIGNAL(ADC2TS10L,vme.sis3316[1].channel[9].data.ts[1],DATA32);
SIGNAL(ADC2TS11H,vme.sis3316[1].channel[10].data.ts[0],DATA32);
SIGNAL(ADC2TS11L,vme.sis3316[1].channel[10].data.ts[1],DATA32);
SIGNAL(ADC2TS12H,vme.sis3316[1].channel[11].data.ts[0],DATA32);
SIGNAL(ADC2TS12L,vme.sis3316[1].channel[11].data.ts[1],DATA32);
SIGNAL(ADC2TS13H,vme.sis3316[1].channel[12].data.ts[0],DATA32);
SIGNAL(ADC2TS13L,vme.sis3316[1].channel[12].data.ts[1],DATA32);
SIGNAL(ADC2TS14H,vme.sis3316[1].channel[13].data.ts[0],DATA32);
SIGNAL(ADC2TS14L,vme.sis3316[1].channel[13].data.ts[1],DATA32);
SIGNAL(ADC2TS15H,vme.sis3316[1].channel[14].data.ts[0],DATA32);
SIGNAL(ADC2TS15L,vme.sis3316[1].channel[14].data.ts[1],DATA32);
SIGNAL(ADC2TS16H,vme.sis3316[1].channel[15].data.ts[0],DATA32);
SIGNAL(ADC2TS16L,vme.sis3316[1].channel[15].data.ts[1],DATA32);
SIGNAL(ADC2TS1H,vme.sis3316[1].channel[0].data.ts[0],DATA32);
SIGNAL(ADC2TS1L,vme.sis3316[1].channel[0].data.ts[1],DATA32);
SIGNAL(ADC2TS2H,vme.sis3316[1].channel[1].data.ts[0],DATA32);
SIGNAL(ADC2TS2L,vme.sis3316[1].channel[1].data.ts[1],DATA32);
SIGNAL(ADC2TS3H,vme.sis3316[1].channel[2].data.ts[0],DATA32);
SIGNAL(ADC2TS3L,vme.sis3316[1].channel[2].data.ts[1],DATA32);
SIGNAL(ADC2TS4H,vme.sis3316[1].channel[3].data.ts[0],DATA32);
SIGNAL(ADC2TS4L,vme.sis3316[1].channel[3].data.ts[1],DATA32);
SIGNAL(ADC2TS5H,vme.sis3316[1].channel[4].data.ts[0],DATA32);
SIGNAL(ADC2TS5L,vme.sis3316[1].channel[4].data.ts[1],DATA32);
SIGNAL(ADC2TS6H,vme.sis3316[1].channel[5].data.ts[0],DATA32);
SIGNAL(ADC2TS6L,vme.sis3316[1].channel[5].data.ts[1],DATA32);
SIGNAL(ADC2TS7H,vme.sis3316[1].channel[6].data.ts[0],DATA32);
SIGNAL(ADC2TS7L,vme.sis3316[1].channel[6].data.ts[1],DATA32);
SIGNAL(ADC2TS8H,vme.sis3316[1].channel[7].data.ts[0],DATA32);
SIGNAL(ADC2TS8L,vme.sis3316[1].channel[7].data.ts[1],DATA32);
SIGNAL(ADC2TS9H,vme.sis3316[1].channel[8].data.ts[0],DATA32);
SIGNAL(ADC2TS9L,vme.sis3316[1].channel[8].data.ts[1],DATA32);
SIGNAL(ADC3CH13MAXE1,vme.sis3316[2].channel[12].data.maxe[0],DATA32);
SIGNAL(ADC3CH13MAXE2,vme.sis3316[2].channel[12].data.maxe[1],DATA32);
SIGNAL(ADC3CH13T1,vme.sis3316[2].channel[12].data.maw[0],DATA32);
SIGNAL(ADC3CH13T2,vme.sis3316[2].channel[12].data.maw[1],DATA32);
SIGNAL(ADC3CH13T3,vme.sis3316[2].channel[12].data.maw[2],DATA32);
SIGNAL(ADC3CH1MAXE1,vme.sis3316[2].channel[0].data.maxe[0],DATA32);
SIGNAL(ADC3CH1MAXE2,vme.sis3316[2].channel[0].data.maxe[1],DATA32);
SIGNAL(ADC3CH1T1,vme.sis3316[2].channel[0].data.maw[0],DATA32);
SIGNAL(ADC3CH1T2,vme.sis3316[2].channel[0].data.maw[1],DATA32);
SIGNAL(ADC3CH1T3,vme.sis3316[2].channel[0].data.maw[2],DATA32);
SIGNAL(ADC3CH5MAXE1,vme.sis3316[2].channel[4].data.maxe[0],DATA32);
SIGNAL(ADC3CH5MAXE2,vme.sis3316[2].channel[4].data.maxe[1],DATA32);
SIGNAL(ADC3CH5T1,vme.sis3316[2].channel[4].data.maw[0],DATA32);
SIGNAL(ADC3CH5T2,vme.sis3316[2].channel[4].data.maw[1],DATA32);
SIGNAL(ADC3CH5T3,vme.sis3316[2].channel[4].data.maw[2],DATA32);
SIGNAL(ADC3CH9MAXE1,vme.sis3316[2].channel[8].data.maxe[0],DATA32);
SIGNAL(ADC3CH9MAXE2,vme.sis3316[2].channel[8].data.maxe[1],DATA32);
SIGNAL(ADC3CH9T1,vme.sis3316[2].channel[8].data.maw[0],DATA32);
SIGNAL(ADC3CH9T2,vme.sis3316[2].channel[8].data.maw[1],DATA32);
SIGNAL(ADC3CH9T3,vme.sis3316[2].channel[8].data.maw[2],DATA32);
SIGNAL(ADC3TS10H,vme.sis3316[2].channel[9].data.ts[0],DATA32);
SIGNAL(ADC3TS10L,vme.sis3316[2].channel[9].data.ts[1],DATA32);
SIGNAL(ADC3TS11H,vme.sis3316[2].channel[10].data.ts[0],DATA32);
SIGNAL(ADC3TS11L,vme.sis3316[2].channel[10].data.ts[1],DATA32);
SIGNAL(ADC3TS12H,vme.sis3316[2].channel[11].data.ts[0],DATA32);
SIGNAL(ADC3TS12L,vme.sis3316[2].channel[11].data.ts[1],DATA32);
SIGNAL(ADC3TS13H,vme.sis3316[2].channel[12].data.ts[0],DATA32);
SIGNAL(ADC3TS13L,vme.sis3316[2].channel[12].data.ts[1],DATA32);
SIGNAL(ADC3TS14H,vme.sis3316[2].channel[13].data.ts[0],DATA32);
SIGNAL(ADC3TS14L,vme.sis3316[2].channel[13].data.ts[1],DATA32);
SIGNAL(ADC3TS15H,vme.sis3316[2].channel[14].data.ts[0],DATA32);
SIGNAL(ADC3TS15L,vme.sis3316[2].channel[14].data.ts[1],DATA32);
SIGNAL(ADC3TS16H,vme.sis3316[2].channel[15].data.ts[0],DATA32);
SIGNAL(ADC3TS16L,vme.sis3316[2].channel[15].data.ts[1],DATA32);
SIGNAL(ADC3TS1H,vme.sis3316[2].channel[0].data.ts[0],DATA32);
SIGNAL(ADC3TS1L,vme.sis3316[2].channel[0].data.ts[1],DATA32);
SIGNAL(ADC3TS2H,vme.sis3316[2].channel[1].data.ts[0],DATA32);
SIGNAL(ADC3TS2L,vme.sis3316[2].channel[1].data.ts[1],DATA32);
SIGNAL(ADC3TS3H,vme.sis3316[2].channel[2].data.ts[0],DATA32);
SIGNAL(ADC3TS3L,vme.sis3316[2].channel[2].data.ts[1],DATA32);
SIGNAL(ADC3TS4H,vme.sis3316[2].channel[3].data.ts[0],DATA32);
SIGNAL(ADC3TS4L,vme.sis3316[2].channel[3].data.ts[1],DATA32);
SIGNAL(ADC3TS5H,vme.sis3316[2].channel[4].data.ts[0],DATA32);
SIGNAL(ADC3TS5L,vme.sis3316[2].channel[4].data.ts[1],DATA32);
SIGNAL(ADC3TS6H,vme.sis3316[2].channel[5].data.ts[0],DATA32);
SIGNAL(ADC3TS6L,vme.sis3316[2].channel[5].data.ts[1],DATA32);
SIGNAL(ADC3TS7H,vme.sis3316[2].channel[6].data.ts[0],DATA32);
SIGNAL(ADC3TS7L,vme.sis3316[2].channel[6].data.ts[1],DATA32);
SIGNAL(ADC3TS8H,vme.sis3316[2].channel[7].data.ts[0],DATA32);
SIGNAL(ADC3TS8L,vme.sis3316[2].channel[7].data.ts[1],DATA32);
SIGNAL(ADC3TS9H,vme.sis3316[2].channel[8].data.ts[0],DATA32);
SIGNAL(ADC3TS9L,vme.sis3316[2].channel[8].data.ts[1],DATA32);
SIGNAL(ADC_1_N,vme.sis3316[0].n_ch,DATA8);
SIGNAL(ADC_2_N,vme.sis3316[1].n_ch,DATA8);
SIGNAL(ADC_3_N,vme.sis3316[2].n_ch,DATA8);
SIGNAL(CRM_1,scalers.caen_scaler.data[16],DATA32);
SIGNAL(CRM_2,scalers.caen_scaler.data[17],DATA32);
SIGNAL(CRM_3,scalers.caen_scaler.data[18],DATA32);
SIGNAL(CRM_4,scalers.caen_scaler.data[19],DATA32);
SIGNAL(CRM_5,scalers.caen_scaler.data[20],DATA32);
SIGNAL(CRM_6,scalers.caen_scaler.data[21],DATA32);
SIGNAL(CRM_7,scalers.caen_scaler.data[22],DATA32);
SIGNAL(CRM_8,scalers.caen_scaler.data[23],DATA32);
SIGNAL(HPGEL_1S,scalers.caen_scaler.data[8],DATA32);
SIGNAL(HPGEL_1T,vme.tdc.data[4],DATA12);
SIGNAL(HPGEL_2S,scalers.caen_scaler.data[9],DATA32);
SIGNAL(HPGEL_2T,vme.tdc.data[5],DATA12);
SIGNAL(HPGEL_3S,scalers.caen_scaler.data[10],DATA32);
SIGNAL(HPGEL_3T,vme.tdc.data[6],DATA12);
SIGNAL(HPGEL_4S,scalers.caen_scaler.data[11],DATA32);
SIGNAL(HPGEL_4T,vme.tdc.data[7],DATA12);
SIGNAL(HPGE_1S,scalers.caen_scaler.data[12],DATA32);
SIGNAL(HPGE_2S,scalers.caen_scaler.data[13],DATA32);
SIGNAL(HPGE_3S,scalers.caen_scaler.data[14],DATA32);
SIGNAL(HPGE_4S,scalers.caen_scaler.data[15],DATA32);
SIGNAL(LABRL_1S,scalers.caen_scaler.data[0],DATA32);
SIGNAL(LABRL_1T,vme.tdc.data[0],DATA12);
SIGNAL(LABRL_2S,scalers.caen_scaler.data[1],DATA32);
SIGNAL(LABRL_2T,vme.tdc.data[1],DATA12);
SIGNAL(LABRL_3S,scalers.caen_scaler.data[2],DATA32);
SIGNAL(LABRL_3T,vme.tdc.data[2],DATA12);
SIGNAL(LABRL_4S,scalers.caen_scaler.data[3],DATA32);
SIGNAL(LABRL_4T,vme.tdc.data[3],DATA12);
SIGNAL(LABR_1S,scalers.caen_scaler.data[4],DATA32);
SIGNAL(LABR_2S,scalers.caen_scaler.data[5],DATA32);
SIGNAL(LABR_3S,scalers.caen_scaler.data[6],DATA32);
SIGNAL(LABR_4S,scalers.caen_scaler.data[7],DATA32);
SIGNAL(N_1E,vme.adc.data[0],DATA16);
SIGNAL(N_1P,vme.adc.data[1],DATA16);
SIGNAL(N_1S,scalers.caen_scaler.data[24],DATA32);
SIGNAL(N_1T,vme.tdc.data[8],DATA12);
SIGNAL(N_2E,vme.adc.data[2],DATA16);
SIGNAL(N_2P,vme.adc.data[3],DATA16);
SIGNAL(N_2S,scalers.caen_scaler.data[25],DATA32);
SIGNAL(N_2T,vme.tdc.data[9],DATA12);
SIGNAL(N_3E,vme.adc.data[4],DATA16);
SIGNAL(N_3P,vme.adc.data[5],DATA16);
SIGNAL(N_3S,scalers.caen_scaler.data[26],DATA32);
SIGNAL(N_3T,vme.tdc.data[10],DATA12);
SIGNAL(N_4E,vme.adc.data[6],DATA16);
SIGNAL(N_4P,vme.adc.data[7],DATA16);
SIGNAL(N_4S,scalers.caen_scaler.data[27],DATA32);
SIGNAL(N_4T,vme.tdc.data[11],DATA12);
SIGNAL(N_5E,vme.adc.data[16],DATA16);
SIGNAL(N_5P,vme.adc.data[17],DATA16);
SIGNAL(N_5S,scalers.caen_scaler.data[28],DATA32);
SIGNAL(N_5T,vme.tdc.data[12],DATA12);
SIGNAL(N_6E,vme.adc.data[18],DATA16);
SIGNAL(N_6P,vme.adc.data[19],DATA16);
SIGNAL(N_6S,scalers.caen_scaler.data[29],DATA32);
SIGNAL(N_6T,vme.tdc.data[13],DATA12);
SIGNAL(N_7E,vme.adc.data[20],DATA16);
SIGNAL(N_7P,vme.adc.data[21],DATA16);
SIGNAL(N_7S,scalers.caen_scaler.data[30],DATA32);
SIGNAL(N_7T,vme.tdc.data[14],DATA12);
SIGNAL(N_8E,vme.adc.data[22],DATA16);
SIGNAL(N_8P,vme.adc.data[23],DATA16);
SIGNAL(N_8S,scalers.caen_scaler.data[31],DATA32);
SIGNAL(N_8T,vme.tdc.data[15],DATA12);
SIGNAL(TPAT,ts.trlo.trigbuf.entry.tpat,DATA32);
SIGNAL(TRIG,ts.trlo.trigbuf.entry.trig,DATA8);
SIGNAL(TRIGT_1,vme.tdc.data[16],DATA12);
SIGNAL(TRIGT_10,vme.tdc.data[25],DATA12);
SIGNAL(TRIGT_11,vme.tdc.data[26],DATA12);
SIGNAL(TRIGT_12,vme.tdc.data[27],DATA12);
SIGNAL(TRIGT_2,vme.tdc.data[17],DATA12);
SIGNAL(TRIGT_3,vme.tdc.data[18],DATA12);
SIGNAL(TRIGT_4,vme.tdc.data[19],DATA12);
SIGNAL(TRIGT_5,vme.tdc.data[20],DATA12);
SIGNAL(TRIGT_6,vme.tdc.data[21],DATA12);
SIGNAL(TRIGT_7,vme.tdc.data[22],DATA12);
SIGNAL(TRIGT_8,vme.tdc.data[23],DATA12);
SIGNAL(TRIGT_9,vme.tdc.data[24],DATA12);
SIGNAL(TRLOADT1,scalers.trlo.after_deadtime[0],DATA32);
SIGNAL(TRLOADT10,scalers.trlo.after_deadtime[9],DATA32);
SIGNAL(TRLOADT11,scalers.trlo.after_deadtime[10],DATA32);
SIGNAL(TRLOADT12,scalers.trlo.after_deadtime[11],DATA32);
SIGNAL(TRLOADT13,scalers.trlo.after_deadtime[12],DATA32);
SIGNAL(TRLOADT14,scalers.trlo.after_deadtime[13],DATA32);
SIGNAL(TRLOADT15,scalers.trlo.after_deadtime[14],DATA32);
SIGNAL(TRLOADT16,scalers.trlo.after_deadtime[15],DATA32);
SIGNAL(TRLOADT2,scalers.trlo.after_deadtime[1],DATA32);
SIGNAL(TRLOADT3,scalers.trlo.after_deadtime[2],DATA32);
SIGNAL(TRLOADT4,scalers.trlo.after_deadtime[3],DATA32);
SIGNAL(TRLOADT5,scalers.trlo.after_deadtime[4],DATA32);
SIGNAL(TRLOADT6,scalers.trlo.after_deadtime[5],DATA32);
SIGNAL(TRLOADT7,scalers.trlo.after_deadtime[6],DATA32);
SIGNAL(TRLOADT8,scalers.trlo.after_deadtime[7],DATA32);
SIGNAL(TRLOADT9,scalers.trlo.after_deadtime[8],DATA32);
SIGNAL(TRLOARD1,scalers.trlo.after_reduction[0],DATA32);
SIGNAL(TRLOARD10,scalers.trlo.after_reduction[9],DATA32);
SIGNAL(TRLOARD11,scalers.trlo.after_reduction[10],DATA32);
SIGNAL(TRLOARD12,scalers.trlo.after_reduction[11],DATA32);
SIGNAL(TRLOARD13,scalers.trlo.after_reduction[12],DATA32);
SIGNAL(TRLOARD14,scalers.trlo.after_reduction[13],DATA32);
SIGNAL(TRLOARD15,scalers.trlo.after_reduction[14],DATA32);
SIGNAL(TRLOARD16,scalers.trlo.after_reduction[15],DATA32);
SIGNAL(TRLOARD2,scalers.trlo.after_reduction[1],DATA32);
SIGNAL(TRLOARD3,scalers.trlo.after_reduction[2],DATA32);
SIGNAL(TRLOARD4,scalers.trlo.after_reduction[3],DATA32);
SIGNAL(TRLOARD5,scalers.trlo.after_reduction[4],DATA32);
SIGNAL(TRLOARD6,scalers.trlo.after_reduction[5],DATA32);
SIGNAL(TRLOARD7,scalers.trlo.after_reduction[6],DATA32);
SIGNAL(TRLOARD8,scalers.trlo.after_reduction[7],DATA32);
SIGNAL(TRLOARD9,scalers.trlo.after_reduction[8],DATA32);
SIGNAL(TRLOBDT1,scalers.trlo.before_deadtime[0],DATA32);
SIGNAL(TRLOBDT10,scalers.trlo.before_deadtime[9],DATA32);
SIGNAL(TRLOBDT11,scalers.trlo.before_deadtime[10],DATA32);
SIGNAL(TRLOBDT12,scalers.trlo.before_deadtime[11],DATA32);
SIGNAL(TRLOBDT13,scalers.trlo.before_deadtime[12],DATA32);
SIGNAL(TRLOBDT14,scalers.trlo.before_deadtime[13],DATA32);
SIGNAL(TRLOBDT15,scalers.trlo.before_deadtime[14],DATA32);
SIGNAL(TRLOBDT16,scalers.trlo.before_deadtime[15],DATA32);
SIGNAL(TRLOBDT2,scalers.trlo.before_deadtime[1],DATA32);
SIGNAL(TRLOBDT3,scalers.trlo.before_deadtime[2],DATA32);
SIGNAL(TRLOBDT4,scalers.trlo.before_deadtime[3],DATA32);
SIGNAL(TRLOBDT5,scalers.trlo.before_deadtime[4],DATA32);
SIGNAL(TRLOBDT6,scalers.trlo.before_deadtime[5],DATA32);
SIGNAL(TRLOBDT7,scalers.trlo.before_deadtime[6],DATA32);
SIGNAL(TRLOBDT8,scalers.trlo.before_deadtime[7],DATA32);
SIGNAL(TRLOBDT9,scalers.trlo.before_deadtime[8],DATA32);
SIGNAL(TRLORAW1,scalers.trlo.before_lmu[0],DATA32);
SIGNAL(TRLORAW10,scalers.trlo.before_lmu[9],DATA32);
SIGNAL(TRLORAW11,scalers.trlo.before_lmu[10],DATA32);
SIGNAL(TRLORAW12,scalers.trlo.before_lmu[11],DATA32);
SIGNAL(TRLORAW13,scalers.trlo.before_lmu[12],DATA32);
SIGNAL(TRLORAW14,scalers.trlo.before_lmu[13],DATA32);
SIGNAL(TRLORAW15,scalers.trlo.before_lmu[14],DATA32);
SIGNAL(TRLORAW16,scalers.trlo.before_lmu[15],DATA32);
SIGNAL(TRLORAW2,scalers.trlo.before_lmu[1],DATA32);
SIGNAL(TRLORAW3,scalers.trlo.before_lmu[2],DATA32);
SIGNAL(TRLORAW4,scalers.trlo.before_lmu[3],DATA32);
SIGNAL(TRLORAW5,scalers.trlo.before_lmu[4],DATA32);
SIGNAL(TRLORAW6,scalers.trlo.before_lmu[5],DATA32);
SIGNAL(TRLORAW7,scalers.trlo.before_lmu[6],DATA32);
SIGNAL(TRLORAW8,scalers.trlo.before_lmu[7],DATA32);
SIGNAL(TRLORAW9,scalers.trlo.before_lmu[8],DATA32);
SIGNAL(TS_HI,ts.trlo.trigbuf.entry.ts_hi,DATA32);
SIGNAL(TS_LO,ts.trlo.trigbuf.entry.ts_lo,DATA32);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: CAEN_V775
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V775(geom,crate)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAEN_V775
class CAEN_V775
#else//PACKER_CODE
# define DECLARED_PACKER_CAEN_V775
class PACKER_CAEN_V775
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,32> data;
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 event_number : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 crate);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 crate);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 crate);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAEN_V775);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V775(geom,crate)
template<typename __data_src_t>
void CAEN_V775::__unpack(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 undefined : 8; // 0..7
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 undefined : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(1033,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(1030,header.crate,crate);
  CHECK_BITS_EQUAL(1031,header.unnamed_24_26,2);
  CHECK_BITS_EQUAL(1032,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(1033,header.u32,0x0000c000);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 overflow : 1; // 12
        uint32 underflow : 1; // 13
        uint32 valid : 1; // 14
        uint32 dummy_15 : 1;
        uint32 channel : 5; // 16..20
        uint32 dummy_21_23 : 3;
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 dummy_21_23 : 3;
        uint32 channel : 5; // 16..20
        uint32 dummy_15 : 1;
        uint32 valid : 1; // 14
        uint32 underflow : 1; // 13
        uint32 overflow : 1; // 12
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(1053,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(1049,ch_data.unnamed_24_26,0);
    CHECK_BITS_EQUAL(1050,ch_data.geom,geom);
    CHECK_UNNAMED_BITS_ZERO(1053,ch_data.u32,0x00e08000);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(1052,ch_data.channel);
      __item.value = ch_data.value;
      __item.overflow = ch_data.overflow;
    }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  READ_FROM_BUFFER_FULL(1062,uint32 ,eob,eob.u32);
  CHECK_BITS_EQUAL(1059,eob.unnamed_24_26,4);
  CHECK_BITS_EQUAL(1060,eob.geom,geom);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAEN_V775::__unpack,uint32 geom,uint32 crate);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V775(geom,crate)
template<typename __data_src_t>
bool CAEN_V775::__match(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 undefined : 8; // 0..7
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 undefined : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(1033,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(1030,header.crate,crate);
  MATCH_BITS_EQUAL(1031,header.unnamed_24_26,2);
  MATCH_BITS_EQUAL(1032,header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(1033,header.u32,0x0000c000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAEN_V775::__match,uint32 geom,uint32 crate);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V775(geom,crate)
template<typename __data_dest_t>
void PACKER_CAEN_V775::__packer(__data_dest_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: undefined;
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAEN_V775::__packer,uint32 geom,uint32 crate);

/** END_PACKER ********************************************************/

//
// Generating code for: CAEN_V830_SCALER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAEN_V830_SCALER.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V830_SCALER(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAEN_V830_SCALER
class CAEN_V830_SCALER
#else//PACKER_CODE
# define DECLARED_PACKER_CAEN_V830_SCALER
class PACKER_CAEN_V830_SCALER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 sc_header
  // {
    //  0_06: count = RANGE(0,31);
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 7; // 0..6
      uint32 dummy_7_23 : 17;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_7_23 : 17;
      uint32 count : 7; // 0..6
#endif
    };
    uint32  u32;
  } sc_header;
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 undefined : 2; // 24..25
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 undefined : 2; // 24..25
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 sc NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAEN_V830_SCALER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAEN_V830_SCALER.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V830_SCALER(id)
template<typename __data_src_t>
void CAEN_V830_SCALER::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 sc_header
  // {
    //  0_06: count = RANGE(0,31);
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(995,uint32 ,sc_header,sc_header.u32);
  CHECK_BITS_RANGE_MAX(993,sc_header.count,31);
  CHECK_BITS_EQUAL(994,sc_header.id,id);
  CHECK_UNNAMED_BITS_ZERO(995,sc_header.u32,0x00ffff80);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom;
  // }
  READ_FROM_BUFFER_FULL(1004,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(1002,header.unnamed_26_26,1);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 sc NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 26; // 0..25
        uint32 unnamed_26_26 : 1; // 26
        uint32 channel : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel : 5; // 27..31
        uint32 unnamed_26_26 : 1; // 26
        uint32 value : 26; // 0..25
#endif
      };
      uint32  u32;
    } sc;
    READ_FROM_BUFFER_FULL(1012,uint32 ,sc,sc.u32);
    CHECK_BITS_EQUAL(1009,sc.unnamed_26_26,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(1011,sc.channel);
      __item.value = sc.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAEN_V830_SCALER::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAEN_V830_SCALER.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V830_SCALER(id)
template<typename __data_src_t>
bool CAEN_V830_SCALER::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 sc_header
  // {
    //  0_06: count = RANGE(0,31);
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 7; // 0..6
      uint32 dummy_7_23 : 17;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_7_23 : 17;
      uint32 count : 7; // 0..6
#endif
    };
    uint32  u32;
  } __sc_header;
  READ_FROM_BUFFER_FULL(995,uint32 ,sc_header,__sc_header.u32);
  MATCH_BITS_RANGE_MAX(993,__sc_header.count,31);
  MATCH_BITS_EQUAL(994,__sc_header.id,id);
  MATCH_UNNAMED_BITS_ZERO(995,__sc_header.u32,0x00ffff80);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAEN_V830_SCALER::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAEN_V830_SCALER.
 *
 * Do not edit - automatically generated.
 */

// CAEN_V830_SCALER(id)
template<typename __data_dest_t>
void PACKER_CAEN_V830_SCALER::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 sc_header
  // {
    //  0_06: count = RANGE(0,31);
    // 24_31: id = MATCH(id);
  // }
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    // 24_25: undefined;
    //    26: 1;
    // 27_31: geom;
  // }
  // list(0<=index<header.count)

  {
    // UINT32 sc NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAEN_V830_SCALER::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_LECROY_4434
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_LECROY_4434
class CAMAC_LECROY_4434
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_LECROY_4434
class PACKER_CAMAC_LECROY_4434
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA24,DATA24,32> data;
  // list(0<=index<channels)

    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_LECROY_4434);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_src_t>
void CAMAC_LECROY_4434::__unpack(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 24; // 0..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 value : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(23,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(20,ch_data.unnamed_24_31,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(22,index);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_4434::__unpack,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_src_t>
bool CAMAC_LECROY_4434::__match(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 24; // 0..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 value : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(23,uint32 ,ch_data,ch_data.u32);
    MATCH_BITS_EQUAL(20,ch_data.unnamed_24_31,0);
    return true;
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_LECROY_4434::__match,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_dest_t>
void PACKER_CAMAC_LECROY_4434::__packer(__data_dest_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_4434::__packer,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_PHILLIPS_7164
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_PHILLIPS_7164
class CAMAC_PHILLIPS_7164
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_PHILLIPS_7164
class PACKER_CAMAC_PHILLIPS_7164
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,16> data;
  // list(0<=index<channels)

    // if(mark_channel_no)

    // else

      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels,uint32 mark_channel_no);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_PHILLIPS_7164);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_src_t>
void CAMAC_PHILLIPS_7164::__unpack(__data_src_t &__buffer,uint32 channels
                                                         ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 4; // 12..15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 channel : 4; // 12..15
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(71,uint16 ,ch_data,ch_data.u16);
      CHECK_BITS_EQUAL(68,ch_data.channel,index);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(70,index);
        __item.value = ch_data.value;
      }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_15 : 4;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 dummy_12_15 : 4;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(78,uint16 ,ch_data,ch_data.u16);
      CHECK_UNNAMED_BITS_ZERO(78,ch_data.u16,0xf000);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(77,index);
        __item.value = ch_data.value;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_PHILLIPS_7164::__unpack,uint32 channels
                                                              ,uint32 mark_channel_no);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_src_t>
bool CAMAC_PHILLIPS_7164::__match(__data_src_t &__buffer,uint32 channels
                                                        ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 4; // 12..15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 channel : 4; // 12..15
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(71,uint16 ,ch_data,ch_data.u16);
      MATCH_BITS_EQUAL(68,ch_data.channel,index);
      return true;
      return false;
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_15 : 4;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 dummy_12_15 : 4;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(78,uint16 ,ch_data,ch_data.u16);
      MATCH_UNNAMED_BITS_ZERO(78,ch_data.u16,0xf000);
      return true;
      return false;
    }
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_PHILLIPS_7164::__match,uint32 channels
                                                             ,uint32 mark_channel_no);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_dest_t>
void PACKER_CAMAC_PHILLIPS_7164::__packer(__data_dest_t &__buffer,uint32 channels
                                                                 ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_PHILLIPS_7164::__packer,uint32 channels
                                                              ,uint32 mark_channel_no);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_SILENA_4418
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_SILENA_4418
class CAMAC_SILENA_4418
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_SILENA_4418
class PACKER_CAMAC_SILENA_4418
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,8> data;
  // list(0<=index<channels)

    // if(mark_channel_no)

    // else

      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels,uint32 mark_channel_no);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_SILENA_4418);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_src_t>
void CAMAC_SILENA_4418::__unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 3; // 12..14
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 channel : 3; // 12..14
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(43,uint16 ,ch_data,ch_data.u16);
      CHECK_BITS_EQUAL(39,ch_data.channel,index);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(42,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_14 : 3;
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 dummy_12_14 : 3;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(51,uint16 ,ch_data,ch_data.u16);
      CHECK_UNNAMED_BITS_ZERO(51,ch_data.u16,0x7000);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(50,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_SILENA_4418::__unpack,uint32 channels
                                                            ,uint32 mark_channel_no);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_src_t>
bool CAMAC_SILENA_4418::__match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 3; // 12..14
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 channel : 3; // 12..14
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(43,uint16 ,ch_data,ch_data.u16);
      MATCH_BITS_EQUAL(39,ch_data.channel,index);
      return true;
      return false;
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_14 : 3;
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 dummy_12_14 : 3;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(51,uint16 ,ch_data,ch_data.u16);
      MATCH_UNNAMED_BITS_ZERO(51,ch_data.u16,0x7000);
      return true;
      return false;
    }
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_SILENA_4418::__match,uint32 channels
                                                           ,uint32 mark_channel_no);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_dest_t>
void PACKER_CAMAC_SILENA_4418::__packer(__data_dest_t &__buffer,uint32 channels
                                                               ,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_SILENA_4418::__packer,uint32 channels
                                                            ,uint32 mark_channel_no);

/** END_PACKER ********************************************************/

//
// Generating code for: FASTBUS_LECROY_1875
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_FASTBUS_LECROY_1875
class FASTBUS_LECROY_1875
#else//PACKER_CODE
# define DECLARED_PACKER_FASTBUS_LECROY_1875
class PACKER_FASTBUS_LECROY_1875
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_RANGE,DATA12_RANGE,64> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FASTBUS_LECROY_1875);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_src_t>
void FASTBUS_LECROY_1875::__unpack(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 6; // 16..21
      uint32 dummy_22 : 1;
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 dummy_22 : 1;
      uint32 channel : 6; // 16..21
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(101,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(94,ch_data.channel,(channels - 1));
  CHECK_BITS_EQUAL(97,ch_data.n,0);
  CHECK_BITS_EQUAL(98,ch_data.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(101,ch_data.u32,0x0040f000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(100,ch_data.channel);
    __item.value = ch_data.value;
    __item.range = ch_data.range;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1875::__unpack,uint32 geom
                                                              ,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_src_t>
bool FASTBUS_LECROY_1875::__match(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 6; // 16..21
      uint32 dummy_22 : 1;
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 dummy_22 : 1;
      uint32 channel : 6; // 16..21
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(101,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(94,ch_data.channel,(channels - 1));
  MATCH_BITS_EQUAL(97,ch_data.n,0);
  MATCH_BITS_EQUAL(98,ch_data.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(101,ch_data.u32,0x0040f000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FASTBUS_LECROY_1875::__match,uint32 geom
                                                             ,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_dest_t>
void PACKER_FASTBUS_LECROY_1875::__packer(__data_dest_t &__buffer,uint32 geom
                                                                 ,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1875::__packer,uint32 geom
                                                              ,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: FASTBUS_LECROY_1885
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_FASTBUS_LECROY_1885
class FASTBUS_LECROY_1885
#else//PACKER_CODE
# define DECLARED_PACKER_FASTBUS_LECROY_1885
class PACKER_FASTBUS_LECROY_1885
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_RANGE,DATA12_RANGE,96> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FASTBUS_LECROY_1885);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_src_t>
void FASTBUS_LECROY_1885::__unpack(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 7; // 16..22
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 channel : 7; // 16..22
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(118,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(112,ch_data.channel,(channels - 1));
  CHECK_BITS_EQUAL(114,ch_data.n,0);
  CHECK_BITS_EQUAL(115,ch_data.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(118,ch_data.u32,0x0000f000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(117,ch_data.channel);
    __item.value = ch_data.value;
    __item.range = ch_data.range;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1885::__unpack,uint32 geom
                                                              ,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_src_t>
bool FASTBUS_LECROY_1885::__match(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 7; // 16..22
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 channel : 7; // 16..22
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(118,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(112,ch_data.channel,(channels - 1));
  MATCH_BITS_EQUAL(114,ch_data.n,0);
  MATCH_BITS_EQUAL(115,ch_data.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(118,ch_data.u32,0x0000f000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FASTBUS_LECROY_1885::__match,uint32 geom
                                                             ,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_dest_t>
void PACKER_FASTBUS_LECROY_1885::__packer(__data_dest_t &__buffer,uint32 geom
                                                                 ,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1885::__packer,uint32 geom
                                                              ,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_STD_VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_STD_VME
class LAND_STD_VME
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_STD_VME
class PACKER_LAND_STD_VME
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 timestamp);
  DATA32 timestamp;
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //    26: has_scaler_data;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 fail_general : 1; // 0
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 dummy_7_25 : 19;
      uint32 has_scaler_data : 1; // 26
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_event : 1; // 30
      uint32 has_time_stamp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 has_time_stamp : 1; // 31
      uint32 has_multi_event : 1; // 30
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_scaler_data : 1; // 26
      uint32 dummy_7_25 : 19;
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_general : 1; // 0
#endif
    };
    uint32  u32;
  } failure;
  // if(failure.has_time_stamp)

    // UINT32 time_stamp
    // {
      //  0_31: value;
      // ENCODE(timestamp,(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } time_stamp;
  // if(failure.has_multi_event)

    // UINT32 multi_events;
    uint32  multi_events;
  // if(failure.has_multi_scaler_counter0)

    // UINT32 multi_scaler_counter0;
    uint32  multi_scaler_counter0;
  // if(failure.has_multi_adctdc_counter0)

    // UINT32 multi_adctdc_counter0;
    uint32  multi_adctdc_counter0;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_STD_VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_src_t>
void LAND_STD_VME::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 timestamp);
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //    26: has_scaler_data;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  READ_FROM_BUFFER_FULL(1264,uint32 ,failure,failure.u32);
  CHECK_UNNAMED_BITS_ZERO(1264,failure.u32,0x03ffff80);
  // if(failure.has_time_stamp)

  if (failure.has_time_stamp)
  {
    // UINT32 time_stamp
    // {
      //  0_31: value;
      // ENCODE(timestamp,(value=value));
    // }
    READ_FROM_BUFFER_FULL(1270,uint32 ,time_stamp,time_stamp.u32);
    {
      timestamp.value = time_stamp.value;
    }
  }
  // if(failure.has_multi_event)

  if (failure.has_multi_event)
  {
    // UINT32 multi_events;
    READ_FROM_BUFFER(1274,uint32 ,multi_events);
  }
  // if(failure.has_multi_scaler_counter0)

  if (failure.has_multi_scaler_counter0)
  {
    // UINT32 multi_scaler_counter0;
    READ_FROM_BUFFER(1278,uint32 ,multi_scaler_counter0);
  }
  // if(failure.has_multi_adctdc_counter0)

  if (failure.has_multi_adctdc_counter0)
  {
    // UINT32 multi_adctdc_counter0;
    READ_FROM_BUFFER(1282,uint32 ,multi_adctdc_counter0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_STD_VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_src_t>
bool LAND_STD_VME::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 timestamp);
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //    26: has_scaler_data;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 fail_general : 1; // 0
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 dummy_7_25 : 19;
      uint32 has_scaler_data : 1; // 26
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_event : 1; // 30
      uint32 has_time_stamp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 has_time_stamp : 1; // 31
      uint32 has_multi_event : 1; // 30
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_scaler_data : 1; // 26
      uint32 dummy_7_25 : 19;
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_general : 1; // 0
#endif
    };
    uint32  u32;
  } __failure;
  READ_FROM_BUFFER_FULL(1264,uint32 ,failure,__failure.u32);
  MATCH_UNNAMED_BITS_ZERO(1264,__failure.u32,0x03ffff80);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,LAND_STD_VME::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_dest_t>
void PACKER_LAND_STD_VME::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 timestamp);
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //    26: has_scaler_data;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  // if(failure.has_time_stamp)

  if (failure.has_time_stamp)
  {
    // UINT32 time_stamp
    // {
      //  0_31: value;
      // ENCODE(timestamp,(value=value));
    // }
  }
  // if(failure.has_multi_event)

  if (failure.has_multi_event)
  {
    // UINT32 multi_events;
  }
  // if(failure.has_multi_scaler_counter0)

  if (failure.has_multi_scaler_counter0)
  {
    // UINT32 multi_scaler_counter0;
  }
  // if(failure.has_multi_adctdc_counter0)

  if (failure.has_multi_adctdc_counter0)
  {
    // UINT32 multi_adctdc_counter0;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_STD_VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SERIAL_TS
//
//
// Generating code for: SERIAL_TS_EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SERIAL_TS_EVENT.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS_EVENT()
#if !PACKER_CODE
# define DECLARED_UNPACK_SERIAL_TS_EVENT
class SERIAL_TS_EVENT
#else//PACKER_CODE
# define DECLARED_PACKER_SERIAL_TS_EVENT
class PACKER_SERIAL_TS_EVENT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 ts_hi);
  DATA32 ts_hi;
  // MEMBER(DATA32 ts_lo);
  DATA32 ts_lo;
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  // UINT32 ts_msb NOENCODE
  // {
    //  0_30: t_msb;
    //    31: missed_event;
    // ENCODE(ts_hi,(value=t_msb));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SERIAL_TS_EVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SERIAL_TS_EVENT.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS_EVENT()
template<typename __data_src_t>
void SERIAL_TS_EVENT::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 ts_hi);
  // MEMBER(DATA32 ts_lo);
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
    };
    uint32  u32;
  } ts_lsb;
  READ_FROM_BUFFER_FULL(819,uint32 ,ts_lsb,ts_lsb.u32);
  {
    ts_lo.value = ts_lsb.t_lsb;
  }
  // UINT32 ts_msb NOENCODE
  // {
    //  0_30: t_msb;
    //    31: missed_event;
    // ENCODE(ts_hi,(value=t_msb));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t_msb : 31; // 0..30
      uint32 missed_event : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 missed_event : 1; // 31
      uint32 t_msb : 31; // 0..30
#endif
    };
    uint32  u32;
  } ts_msb;
  READ_FROM_BUFFER_FULL(825,uint32 ,ts_msb,ts_msb.u32);
  {
    ts_hi.value = ts_msb.t_msb;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SERIAL_TS_EVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SERIAL_TS_EVENT.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS_EVENT()
template<typename __data_src_t>
bool SERIAL_TS_EVENT::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 ts_hi);
  // MEMBER(DATA32 ts_lo);
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
    };
    uint32  u32;
  } ts_lsb;
  READ_FROM_BUFFER_FULL(819,uint32 ,ts_lsb,ts_lsb.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,SERIAL_TS_EVENT::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SERIAL_TS_EVENT.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS_EVENT()
template<typename __data_dest_t>
void PACKER_SERIAL_TS_EVENT::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 ts_hi);
  // MEMBER(DATA32 ts_lo);
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  // UINT32 ts_msb NOENCODE
  // {
    //  0_30: t_msb;
    //    31: missed_event;
    // ENCODE(ts_hi,(value=t_msb));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,SERIAL_TS_EVENT::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SERIAL_TS.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS()
#if !PACKER_CODE
# define DECLARED_UNPACK_SERIAL_TS
class SERIAL_TS
#else//PACKER_CODE
# define DECLARED_PACKER_SERIAL_TS
class PACKER_SERIAL_TS
#endif//PACKER_CODE

{
public:
  // UINT32 header NOENCODE
  // {
    //  0_31: multi_events;
  // }
  // list(0<=i<header.multi_events)

    // multi event = SERIAL_TS_EVENT();
    MULTI(SERIAL_TS_EVENT,event);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SERIAL_TS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SERIAL_TS.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS()
template<typename __data_src_t>
void SERIAL_TS::__unpack(__data_src_t &__buffer)
{
  // UINT32 header NOENCODE
  // {
    //  0_31: multi_events;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 multi_events : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 multi_events : 32; // 0..31
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(805,uint32 ,header,header.u32);
  // list(0<=i<header.multi_events)

  for (uint32 i = 0; i < (uint32) (header.multi_events); ++i)
  {
    // multi event = SERIAL_TS_EVENT();
    UNPACK_DECL(808,SERIAL_TS_EVENT,multi_event.next_free());
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SERIAL_TS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SERIAL_TS.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS()
template<typename __data_src_t>
bool SERIAL_TS::__match(__data_src_t &__buffer)
{
  // UINT32 header NOENCODE
  // {
    //  0_31: multi_events;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 multi_events : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 multi_events : 32; // 0..31
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(805,uint32 ,header,header.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,SERIAL_TS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SERIAL_TS.
 *
 * Do not edit - automatically generated.
 */

// SERIAL_TS()
template<typename __data_dest_t>
void PACKER_SERIAL_TS::__packer(__data_dest_t &__buffer)
{
  // UINT32 header NOENCODE
  // {
    //  0_31: multi_events;
  // }
  // list(0<=i<header.multi_events)

  {
    // multi event = SERIAL_TS_EVENT();
    PACK_DECL(808,SERIAL_TS_EVENT,multi_event.next_free());
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SERIAL_TS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(762,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(757,header.id,id);
  CHECK_BITS_EQUAL(758,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(760,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(767,uint32 ,d1,d1.u32);
  CHECK_BITS_EQUAL(765,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(772,uint32 ,d2,d2.u32);
  CHECK_BITS_EQUAL(770,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(777,uint32 ,d3,d3.u32);
  CHECK_BITS_EQUAL(775,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(782,uint32 ,d4,d4.u32);
  CHECK_BITS_EQUAL(780,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(762,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(757,header.id,id);
  MATCH_BITS_EQUAL(758,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(760,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TRIGBUF
//
//
// Generating code for: TRIGBUF_ENTRY
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRIGBUF_ENTRY.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF_ENTRY()
#if !PACKER_CODE
# define DECLARED_UNPACK_TRIGBUF_ENTRY
class TRIGBUF_ENTRY
#else//PACKER_CODE
# define DECLARED_PACKER_TRIGBUF_ENTRY
class PACKER_TRIGBUF_ENTRY
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 ts_hi);
  DATA32 ts_hi;
  // MEMBER(DATA32 ts_lo);
  DATA32 ts_lo;
  // MEMBER(DATA32 tpat);
  DATA32 tpat;
  // MEMBER(DATA8 trig);
  DATA8 trig;
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  // UINT32 ts_msb NOENCODE
  // {
    //  0_30: t_msb;
    //    31: missed_event;
    // ENCODE(ts_hi,(value=t_msb));
  // }
  // UINT32 info NOENCODE
  // {
    //  0_23: tpat;
    // 24_27: trig;
    // 28_31: cnt;
    // ENCODE(tpat,(value=tpat));
    // ENCODE(trig,(value=trig));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRIGBUF_ENTRY);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRIGBUF_ENTRY.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF_ENTRY()
template<typename __data_src_t>
void TRIGBUF_ENTRY::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 ts_hi);
  // MEMBER(DATA32 ts_lo);
  // MEMBER(DATA32 tpat);
  // MEMBER(DATA8 trig);
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
    };
    uint32  u32;
  } ts_lsb;
  READ_FROM_BUFFER_FULL(850,uint32 ,ts_lsb,ts_lsb.u32);
  {
    ts_lo.value = ts_lsb.t_lsb;
  }
  // UINT32 ts_msb NOENCODE
  // {
    //  0_30: t_msb;
    //    31: missed_event;
    // ENCODE(ts_hi,(value=t_msb));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t_msb : 31; // 0..30
      uint32 missed_event : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 missed_event : 1; // 31
      uint32 t_msb : 31; // 0..30
#endif
    };
    uint32  u32;
  } ts_msb;
  READ_FROM_BUFFER_FULL(856,uint32 ,ts_msb,ts_msb.u32);
  {
    ts_hi.value = ts_msb.t_msb;
  }
  // UINT32 info NOENCODE
  // {
    //  0_23: tpat;
    // 24_27: trig;
    // 28_31: cnt;
    // ENCODE(tpat,(value=tpat));
    // ENCODE(trig,(value=trig));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tpat : 24; // 0..23
      uint32 trig : 4; // 24..27
      uint32 cnt : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 cnt : 4; // 28..31
      uint32 trig : 4; // 24..27
      uint32 tpat : 24; // 0..23
#endif
    };
    uint32  u32;
  } info;
  READ_FROM_BUFFER_FULL(864,uint32 ,info,info.u32);
  {
    tpat.value = info.tpat;
  }
  {
    trig.value = info.trig;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRIGBUF_ENTRY::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRIGBUF_ENTRY.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF_ENTRY()
template<typename __data_src_t>
bool TRIGBUF_ENTRY::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 ts_hi);
  // MEMBER(DATA32 ts_lo);
  // MEMBER(DATA32 tpat);
  // MEMBER(DATA8 trig);
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 t_lsb : 32; // 0..31
#endif
    };
    uint32  u32;
  } ts_lsb;
  READ_FROM_BUFFER_FULL(850,uint32 ,ts_lsb,ts_lsb.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TRIGBUF_ENTRY::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRIGBUF_ENTRY.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF_ENTRY()
template<typename __data_dest_t>
void PACKER_TRIGBUF_ENTRY::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 ts_hi);
  // MEMBER(DATA32 ts_lo);
  // MEMBER(DATA32 tpat);
  // MEMBER(DATA8 trig);
  // UINT32 ts_lsb NOENCODE
  // {
    //  0_31: t_lsb;
    // ENCODE(ts_lo,(value=t_lsb));
  // }
  // UINT32 ts_msb NOENCODE
  // {
    //  0_30: t_msb;
    //    31: missed_event;
    // ENCODE(ts_hi,(value=t_msb));
  // }
  // UINT32 info NOENCODE
  // {
    //  0_23: tpat;
    // 24_27: trig;
    // 28_31: cnt;
    // ENCODE(tpat,(value=tpat));
    // ENCODE(trig,(value=trig));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRIGBUF_ENTRY::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRIGBUF.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF(multi_events)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRIGBUF
class TRIGBUF
#else//PACKER_CODE
# define DECLARED_PACKER_TRIGBUF
class PACKER_TRIGBUF
#endif//PACKER_CODE

{
public:
  // UINT32 header
  // {
    //  0_11: entries;
    // 12_31: multi_events;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 entries : 12; // 0..11
      uint32 multi_events : 20; // 12..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 multi_events : 20; // 12..31
      uint32 entries : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // list(0<=i<multi_events)

    // multi entry = TRIGBUF_ENTRY();
    MULTI(TRIGBUF_ENTRY,entry);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 multi_events);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 multi_events);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 multi_events);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRIGBUF);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRIGBUF.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF(multi_events)
template<typename __data_src_t>
void TRIGBUF::__unpack(__data_src_t &__buffer,uint32 multi_events)
{
  // UINT32 header
  // {
    //  0_11: entries;
    // 12_31: multi_events;
  // }
  READ_FROM_BUFFER_FULL(833,uint32 ,header,header.u32);
  // list(0<=i<multi_events)

  for (uint32 i = 0; i < (uint32) (multi_events); ++i)
  {
    // multi entry = TRIGBUF_ENTRY();
    UNPACK_DECL(836,TRIGBUF_ENTRY,multi_entry.next_free());
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRIGBUF::__unpack,uint32 multi_events);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRIGBUF.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF(multi_events)
template<typename __data_src_t>
bool TRIGBUF::__match(__data_src_t &__buffer,uint32 multi_events)
{
  // UINT32 header
  // {
    //  0_11: entries;
    // 12_31: multi_events;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 entries : 12; // 0..11
      uint32 multi_events : 20; // 12..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 multi_events : 20; // 12..31
      uint32 entries : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(833,uint32 ,header,__header.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRIGBUF::__match,uint32 multi_events);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRIGBUF.
 *
 * Do not edit - automatically generated.
 */

// TRIGBUF(multi_events)
template<typename __data_dest_t>
void PACKER_TRIGBUF::__packer(__data_dest_t &__buffer,uint32 multi_events)
{
  // UINT32 header
  // {
    //  0_11: entries;
    // 12_31: multi_events;
  // }
  // list(0<=i<multi_events)

  {
    // multi entry = TRIGBUF_ENTRY();
    PACK_DECL(836,TRIGBUF_ENTRY,multi_entry.next_free());
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRIGBUF::__packer,uint32 multi_events);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLO
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLO.
 *
 * Do not edit - automatically generated.
 */

// TRLO(id,multi_events)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLO
class TRLO
#else//PACKER_CODE
# define DECLARED_PACKER_TRLO
class PACKER_TRLO
#endif//PACKER_CODE

{
public:
  // wr_ts = TIMESTAMP_WHITERABBIT(id=id);
  // serial_ts = SERIAL_TS();
  // trigbuf = TRIGBUF(multi_events=multi_events);
  SINGLE(TIMESTAMP_WHITERABBIT,wr_ts);
  SINGLE(TRIGBUF,trigbuf);
  SINGLE(SERIAL_TS,serial_ts);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id,uint32 multi_events);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id,uint32 multi_events);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id,uint32 multi_events);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLO);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLO.
 *
 * Do not edit - automatically generated.
 */

// TRLO(id,multi_events)
template<typename __data_src_t>
void TRLO::__unpack(__data_src_t &__buffer,uint32 id,uint32 multi_events)
{
  // wr_ts = TIMESTAMP_WHITERABBIT(id=id);
  UNPACK_DECL(869,TIMESTAMP_WHITERABBIT,wr_ts,/*id*/id);
  // serial_ts = SERIAL_TS();
  UNPACK_DECL(870,SERIAL_TS,serial_ts);
  // trigbuf = TRIGBUF(multi_events=multi_events);
  UNPACK_DECL(871,TRIGBUF,trigbuf,/*multi_events*/multi_events);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO::__unpack,uint32 id,uint32 multi_events);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLO.
 *
 * Do not edit - automatically generated.
 */

// TRLO(id,multi_events)
template<typename __data_src_t>
bool TRLO::__match(__data_src_t &__buffer,uint32 id,uint32 multi_events)
{
  // wr_ts = TIMESTAMP_WHITERABBIT(id=id);
  CHECK_MATCH_DECL(869,TIMESTAMP_WHITERABBIT,wr_ts,/*id*/id);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLO::__match,uint32 id,uint32 multi_events);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLO.
 *
 * Do not edit - automatically generated.
 */

// TRLO(id,multi_events)
template<typename __data_dest_t>
void PACKER_TRLO::__packer(__data_dest_t &__buffer,uint32 id,uint32 multi_events)
{
  // wr_ts = TIMESTAMP_WHITERABBIT(id=id);
  PACK_DECL(869,TIMESTAMP_WHITERABBIT,wr_ts,/*id*/id);
  // serial_ts = SERIAL_TS();
  PACK_DECL(870,SERIAL_TS,serial_ts);
  // trigbuf = TRIGBUF(multi_events=multi_events);
  PACK_DECL(871,TRIGBUF,trigbuf,/*multi_events*/multi_events);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO::__packer,uint32 id,uint32 multi_events);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLO_EVENT_TRIGGER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLO_EVENT_TRIGGER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_EVENT_TRIGGER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLO_EVENT_TRIGGER
class TRLO_EVENT_TRIGGER
#else//PACKER_CODE
# define DECLARED_PACKER_TRLO_EVENT_TRIGGER
class PACKER_TRLO_EVENT_TRIGGER
#endif//PACKER_CODE

{
public:
  // UINT32 time_lo
  // {
    //  0_31: val;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 val : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 val : 32; // 0..31
#endif
    };
    uint32  u32;
  } time_lo;
  // UINT32 time_hi
  // {
    //  0_30: val;
    //    31: missed_event;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 val : 31; // 0..30
      uint32 missed_event : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 missed_event : 1; // 31
      uint32 val : 31; // 0..30
#endif
    };
    uint32  u32;
  } time_hi;
  // UINT32 status
  // {
    //  0_23: tpat;
    // 24_27: trig;
    // 28_31: count;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 tpat : 24; // 0..23
      uint32 trig : 4; // 24..27
      uint32 count : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 count : 4; // 28..31
      uint32 trig : 4; // 24..27
      uint32 tpat : 24; // 0..23
#endif
    };
    uint32  u32;
  } status;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLO_EVENT_TRIGGER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLO_EVENT_TRIGGER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_EVENT_TRIGGER()
template<typename __data_src_t>
void TRLO_EVENT_TRIGGER::__unpack(__data_src_t &__buffer)
{
  // UINT32 time_lo
  // {
    //  0_31: val;
  // }
  READ_FROM_BUFFER_FULL(971,uint32 ,time_lo,time_lo.u32);
  // UINT32 time_hi
  // {
    //  0_30: val;
    //    31: missed_event;
  // }
  READ_FROM_BUFFER_FULL(976,uint32 ,time_hi,time_hi.u32);
  // UINT32 status
  // {
    //  0_23: tpat;
    // 24_27: trig;
    // 28_31: count;
  // }
  READ_FROM_BUFFER_FULL(982,uint32 ,status,status.u32);
}
FORCE_IMPL_DATA_SRC_FCN(void,TRLO_EVENT_TRIGGER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLO_EVENT_TRIGGER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_EVENT_TRIGGER()
template<typename __data_src_t>
bool TRLO_EVENT_TRIGGER::__match(__data_src_t &__buffer)
{
  // UINT32 time_lo
  // {
    //  0_31: val;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 val : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 val : 32; // 0..31
#endif
    };
    uint32  u32;
  } __time_lo;
  READ_FROM_BUFFER_FULL(971,uint32 ,time_lo,__time_lo.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TRLO_EVENT_TRIGGER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLO_EVENT_TRIGGER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_EVENT_TRIGGER()
template<typename __data_dest_t>
void PACKER_TRLO_EVENT_TRIGGER::__packer(__data_dest_t &__buffer)
{
  // UINT32 time_lo
  // {
    //  0_31: val;
  // }
  // UINT32 time_hi
  // {
    //  0_30: val;
    //    31: missed_event;
  // }
  // UINT32 status
  // {
    //  0_23: tpat;
    // 24_27: trig;
    // 28_31: count;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TRLO_EVENT_TRIGGER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLO_SAMPLER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLO_SAMPLER
class TRLO_SAMPLER
#else//PACKER_CODE
# define DECLARED_PACKER_TRLO_SAMPLER
class PACKER_TRLO_SAMPLER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,512> stamps;
  // UINT32 header
  // {
    //  0_09: count;
    //    10: missing_at_end;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 10; // 0..9
      uint32 missing_at_end : 1; // 10
      uint32 dummy_11_23 : 13;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_11_23 : 13;
      uint32 missing_at_end : 1; // 10
      uint32 count : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 data NOENCODE
    // {
      //  0_31: stamp;
      // ENCODE(stamps APPEND_LIST,(value=stamp));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLO_SAMPLER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
template<typename __data_src_t>
void TRLO_SAMPLER::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  // UINT32 header
  // {
    //  0_09: count;
    //    10: missing_at_end;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(950,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(949,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(950,header.u32,0x00fff800);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 data NOENCODE
    // {
      //  0_31: stamp;
      // ENCODE(stamps APPEND_LIST,(value=stamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 stamp : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 stamp : 32; // 0..31
#endif
      };
      uint32  u32;
    } data;
    READ_FROM_BUFFER_FULL(962,uint32 ,data,data.u32);
    {
      typedef __typeof__(*(&(stamps))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = stamps.append_item(961);
      __item.value = data.stamp;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO_SAMPLER::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
template<typename __data_src_t>
bool TRLO_SAMPLER::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  // UINT32 header
  // {
    //  0_09: count;
    //    10: missing_at_end;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 10; // 0..9
      uint32 missing_at_end : 1; // 10
      uint32 dummy_11_23 : 13;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_11_23 : 13;
      uint32 missing_at_end : 1; // 10
      uint32 count : 10; // 0..9
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(950,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(949,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(950,__header.u32,0x00fff800);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLO_SAMPLER::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
template<typename __data_dest_t>
void PACKER_TRLO_SAMPLER::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  // UINT32 header
  // {
    //  0_09: count;
    //    10: missing_at_end;
    // 24_31: id = MATCH(id);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 data NOENCODE
    // {
      //  0_31: stamp;
      // ENCODE(stamps APPEND_LIST,(value=stamp));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO_SAMPLER::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLO_TRIG_SCALER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLO_TRIG_SCALER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_TRIG_SCALER(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLO_TRIG_SCALER
class TRLO_TRIG_SCALER
#else//PACKER_CODE
# define DECLARED_PACKER_TRLO_TRIG_SCALER
class PACKER_TRLO_TRIG_SCALER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 before_lmu[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> before_lmu;
  // MEMBER(DATA32 before_lmu_mux[1] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,1> before_lmu_mux;
  // MEMBER(DATA32 before_lmu_aux[4] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,4> before_lmu_aux;
  // MEMBER(DATA32 before_deadtime[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> before_deadtime;
  // MEMBER(DATA32 after_deadtime[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> after_deadtime;
  // MEMBER(DATA32 after_reduction[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> after_reduction;
  // UINT32 header
  // {
    //  0_05: before_lmu = RANGE(0,16);
    //  6_10: before_lmu_mux = RANGE(0,1);
    // 11_15: before_lmu_aux = RANGE(0,4);
    // 16_21: after_lmu = RANGE(0,16);
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 before_lmu : 6; // 0..5
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu_aux : 5; // 11..15
      uint32 after_lmu : 6; // 16..21
      uint32 dummy_22_23 : 2;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_22_23 : 2;
      uint32 after_lmu : 6; // 16..21
      uint32 before_lmu_aux : 5; // 11..15
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu : 6; // 0..5
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.before_lmu)

    // UINT32 b_lmu NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu[index],(value=value));
    // }
  // list(0<=index<header.before_lmu_mux)

    // UINT32 b_lmu_mux NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_mux[index],(value=value));
    // }
  // list(0<=index<header.before_lmu_aux)

    // UINT32 b_lmu_aux NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_aux[index],(value=value));
    // }
  // list(0<=index<header.after_lmu)

    // UINT32 b_deadtime NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_deadtime[index],(value=value));
    // }
  // list(0<=index<header.after_lmu)

    // UINT32 a_deadtime NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_deadtime[index],(value=value));
    // }
  // list(0<=index<header.after_lmu)

    // UINT32 a_reduction NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_reduction[index],(value=value));
    // }
  // list(0<=index<16)

    // UINT32 val;
    uint32  val;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLO_TRIG_SCALER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLO_TRIG_SCALER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_TRIG_SCALER(id)
template<typename __data_src_t>
void TRLO_TRIG_SCALER::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 before_lmu[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_mux[1] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_aux[4] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_deadtime[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_deadtime[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_reduction[16] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_05: before_lmu = RANGE(0,16);
    //  6_10: before_lmu_mux = RANGE(0,1);
    // 11_15: before_lmu_aux = RANGE(0,4);
    // 16_21: after_lmu = RANGE(0,16);
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(893,uint32 ,header,header.u32);
  CHECK_BITS_RANGE_MAX(888,header.before_lmu,16);
  CHECK_BITS_RANGE_MAX(889,header.before_lmu_mux,1);
  CHECK_BITS_RANGE_MAX(890,header.before_lmu_aux,4);
  CHECK_BITS_RANGE_MAX(891,header.after_lmu,16);
  CHECK_BITS_EQUAL(892,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(893,header.u32,0x00c00000);
  // list(0<=index<header.before_lmu)

  for (uint32 index = 0; index < (uint32) (header.before_lmu); ++index)
  {
    // UINT32 b_lmu NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } b_lmu;
    READ_FROM_BUFFER_FULL(899,uint32 ,b_lmu,b_lmu.u32);
    {
      typedef __typeof__(*(&(before_lmu))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_lmu.insert_index(898,index);
      __item.value = b_lmu.value;
    }
  }
  // list(0<=index<header.before_lmu_mux)

  for (uint32 index = 0; index < (uint32) (header.before_lmu_mux); ++index)
  {
    // UINT32 b_lmu_mux NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_mux[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } b_lmu_mux;
    READ_FROM_BUFFER_FULL(905,uint32 ,b_lmu_mux,b_lmu_mux.u32);
    {
      typedef __typeof__(*(&(before_lmu_mux))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_lmu_mux.insert_index(904,index);
      __item.value = b_lmu_mux.value;
    }
  }
  // list(0<=index<header.before_lmu_aux)

  for (uint32 index = 0; index < (uint32) (header.before_lmu_aux); ++index)
  {
    // UINT32 b_lmu_aux NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_aux[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } b_lmu_aux;
    READ_FROM_BUFFER_FULL(911,uint32 ,b_lmu_aux,b_lmu_aux.u32);
    {
      typedef __typeof__(*(&(before_lmu_aux))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_lmu_aux.insert_index(910,index);
      __item.value = b_lmu_aux.value;
    }
  }
  // list(0<=index<header.after_lmu)

  for (uint32 index = 0; index < (uint32) (header.after_lmu); ++index)
  {
    // UINT32 b_deadtime NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_deadtime[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } b_deadtime;
    READ_FROM_BUFFER_FULL(918,uint32 ,b_deadtime,b_deadtime.u32);
    {
      typedef __typeof__(*(&(before_deadtime))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_deadtime.insert_index(917,index);
      __item.value = b_deadtime.value;
    }
  }
  // list(0<=index<header.after_lmu)

  for (uint32 index = 0; index < (uint32) (header.after_lmu); ++index)
  {
    // UINT32 a_deadtime NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_deadtime[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } a_deadtime;
    READ_FROM_BUFFER_FULL(925,uint32 ,a_deadtime,a_deadtime.u32);
    {
      typedef __typeof__(*(&(after_deadtime))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = after_deadtime.insert_index(924,index);
      __item.value = a_deadtime.value;
    }
  }
  // list(0<=index<header.after_lmu)

  for (uint32 index = 0; index < (uint32) (header.after_lmu); ++index)
  {
    // UINT32 a_reduction NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_reduction[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } a_reduction;
    READ_FROM_BUFFER_FULL(932,uint32 ,a_reduction,a_reduction.u32);
    {
      typedef __typeof__(*(&(after_reduction))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = after_reduction.insert_index(931,index);
      __item.value = a_reduction.value;
    }
  }
  // list(0<=index<16)

  for (uint32 index = 0; index < (uint32) (16); ++index)
  {
    // UINT32 val;
    READ_FROM_BUFFER(937,uint32 ,val);
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO_TRIG_SCALER::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLO_TRIG_SCALER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_TRIG_SCALER(id)
template<typename __data_src_t>
bool TRLO_TRIG_SCALER::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 before_lmu[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_mux[1] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_aux[4] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_deadtime[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_deadtime[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_reduction[16] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_05: before_lmu = RANGE(0,16);
    //  6_10: before_lmu_mux = RANGE(0,1);
    // 11_15: before_lmu_aux = RANGE(0,4);
    // 16_21: after_lmu = RANGE(0,16);
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 before_lmu : 6; // 0..5
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu_aux : 5; // 11..15
      uint32 after_lmu : 6; // 16..21
      uint32 dummy_22_23 : 2;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_22_23 : 2;
      uint32 after_lmu : 6; // 16..21
      uint32 before_lmu_aux : 5; // 11..15
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu : 6; // 0..5
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(893,uint32 ,header,__header.u32);
  MATCH_BITS_RANGE_MAX(888,__header.before_lmu,16);
  MATCH_BITS_RANGE_MAX(889,__header.before_lmu_mux,1);
  MATCH_BITS_RANGE_MAX(890,__header.before_lmu_aux,4);
  MATCH_BITS_RANGE_MAX(891,__header.after_lmu,16);
  MATCH_BITS_EQUAL(892,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(893,__header.u32,0x00c00000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLO_TRIG_SCALER::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLO_TRIG_SCALER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_TRIG_SCALER(id)
template<typename __data_dest_t>
void PACKER_TRLO_TRIG_SCALER::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 before_lmu[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_mux[1] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_aux[4] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_deadtime[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_deadtime[16] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_reduction[16] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_05: before_lmu = RANGE(0,16);
    //  6_10: before_lmu_mux = RANGE(0,1);
    // 11_15: before_lmu_aux = RANGE(0,4);
    // 16_21: after_lmu = RANGE(0,16);
    // 24_31: id = MATCH(id);
  // }
  // list(0<=index<header.before_lmu)

  {
    // UINT32 b_lmu NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu[index],(value=value));
    // }
  }
  // list(0<=index<header.before_lmu_mux)

  {
    // UINT32 b_lmu_mux NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_mux[index],(value=value));
    // }
  }
  // list(0<=index<header.before_lmu_aux)

  {
    // UINT32 b_lmu_aux NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_aux[index],(value=value));
    // }
  }
  // list(0<=index<header.after_lmu)

  {
    // UINT32 b_deadtime NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_deadtime[index],(value=value));
    // }
  }
  // list(0<=index<header.after_lmu)

  {
    // UINT32 a_deadtime NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_deadtime[index],(value=value));
    // }
  }
  // list(0<=index<header.after_lmu)

  {
    // UINT32 a_reduction NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_reduction[index],(value=value));
    // }
  }
  // list(0<=index<16)

  {
    // UINT32 val;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO_TRIG_SCALER::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190
//
//
// Generating code for: VME_CAEN_V1190_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SUBTDC
class VME_CAEN_V1190_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SUBTDC
class PACKER_VME_CAEN_V1190_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;
  // MARK_COUNT(tdc_end);
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1190_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id
                                                           ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._data;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  READ_FROM_BUFFER_FULL(422,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(418,header.event_id,event_id);
  CHECK_BITS_EQUAL(420,header.tdc,tdc);
  CHECK_BITS_EQUAL(421,header.unnamed_27_31,1);
  CHECK_UNNAMED_BITS_ZERO(422,header.u32,0x04000000);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_0;
  PEEK_FROM_BUFFER_FULL(449,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(434,ch_data.tdc,tdc,data_done_0);
  CHECK_JUMP_BITS_EQUAL(439,ch_data.unnamed_27_31,0,data_done_0);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(447,((ch_data.tdc << 5) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
  }
  data_done_0:;
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  if (__buffer.empty()) goto data_done_1;
  PEEK_FROM_BUFFER_FULL(457,uint32 ,error_flags,__error_flags.u32);
  CHECK_JUMP_BITS_EQUAL(455,__error_flags.tdc,tdc,data_done_1);
  CHECK_JUMP_BITS_EQUAL(456,__error_flags.unnamed_27_31,4,data_done_1);
  CHECK_JUMP_UNNAMED_BITS_ZERO(457,__error_flags.u32,0x04ff8000,data_done_1);
  error_flags.u32 = __error_flags.u32;
  __buffer.advance(sizeof(__error_flags.u32));
  data_done_1:;
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  READ_FROM_BUFFER_FULL(468,uint32 ,trailer,trailer.u32);
  CHECK_WORD_COUNT(463,trailer.word_count,tdc_start,tdc_end,4,4);
  CHECK_BITS_EQUAL(464,trailer.event_id,header.event_id);
  CHECK_BITS_EQUAL(466,trailer.tdc,tdc);
  CHECK_BITS_EQUAL(467,trailer.unnamed_27_31,3);
  CHECK_UNNAMED_BITS_ZERO(468,trailer.u32,0x04000000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SUBTDC::__unpack,uint32 tdc
                                                                ,uint32 event_id
                                                                ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1190_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(422,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(418,__header.event_id,event_id);
  MATCH_BITS_EQUAL(420,__header.tdc,tdc);
  MATCH_BITS_EQUAL(421,__header.unnamed_27_31,1);
  MATCH_UNNAMED_BITS_ZERO(422,__header.u32,0x04000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SUBTDC::__match,uint32 tdc
                                                               ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                   ,uint32 event_id
                                                                   ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SUBTDC::__packer,uint32 tdc
                                                                ,uint32 event_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190
class VME_CAEN_V1190
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190
class PACKER_VME_CAEN_V1190
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  SINGLE(VME_CAEN_V1190_SUBTDC,tdc[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_src_t>
void VME_CAEN_V1190::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(483,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(480,header.geom,geom);
  CHECK_BITS_EQUAL(482,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1190_SUBTDC tdc[0]: (s32) => (0xff000000,0x08000000)
    // optimized match 2: VME_CAEN_V1190_SUBTDC tdc[1]: (s32) => (0xff000000,0x09000000)
    // optimized match 3: VME_CAEN_V1190_SUBTDC tdc[2]: (s32) => (0xff000000,0x0a000000)
    // optimized match 4: VME_CAEN_V1190_SUBTDC tdc[3]: (s32) => (0xff000000,0x0b000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(491,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(487,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(487,VME_CAEN_V1190_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(488,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(488,VME_CAEN_V1190_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(489,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(489,VME_CAEN_V1190_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(490,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(490,VME_CAEN_V1190_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(497,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(496,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(509,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(503,trailer.geom,geom);
  CHECK_WORD_COUNT(504,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(508,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(509,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_src_t>
bool VME_CAEN_V1190::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(483,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(480,__header.geom,geom);
  MATCH_BITS_EQUAL(482,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  {
    PACK_DECL(487,VME_CAEN_V1190_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(488,VME_CAEN_V1190_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(489,VME_CAEN_V1190_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(490,VME_CAEN_V1190_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_SHORT
//
//
// Generating code for: VME_CAEN_V1190_SHORT_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT_SUBTDC
class VME_CAEN_V1190_SHORT_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT_SUBTDC
class PACKER_VME_CAEN_V1190_SHORT_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc
                                                                 ,uint32 event_id
                                                                 ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(546,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(531,ch_data.tdc,tdc);
  CHECK_BITS_EQUAL(536,ch_data.unnamed_27_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(544,((ch_data.tdc << 5) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC::__unpack,uint32 tdc
                                                                      ,uint32 event_id
                                                                      ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc
                                                                ,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(546,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(531,ch_data.tdc,tdc);
  MATCH_BITS_EQUAL(536,ch_data.unnamed_27_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT_SUBTDC::__match,uint32 tdc
                                                                     ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                         ,uint32 event_id
                                                                         ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC::__packer,uint32 tdc
                                                                      ,uint32 event_id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_SHORT_SUBTDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
class VME_CAEN_V1190_SHORT_SUBTDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
class PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT_SUBTDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__unpack(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  READ_FROM_BUFFER_FULL(557,uint32 ,error_flags,error_flags.u32);
  CHECK_BITS_EQUAL(555,error_flags.tdc,tdc);
  CHECK_BITS_EQUAL(556,error_flags.unnamed_27_31,4);
  CHECK_UNNAMED_BITS_ZERO(557,error_flags.u32,0x04ff8000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__unpack,uint32 tdc);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__match(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  READ_FROM_BUFFER_FULL(557,uint32 ,error_flags,__error_flags.u32);
  MATCH_BITS_EQUAL(555,__error_flags.tdc,tdc);
  MATCH_BITS_EQUAL(556,__error_flags.unnamed_27_31,4);
  MATCH_UNNAMED_BITS_ZERO(557,__error_flags.u32,0x04ff8000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__match,uint32 tdc);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__packer(__data_dest_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__packer,uint32 tdc);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT
class VME_CAEN_V1190_SHORT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT
class PACKER_VME_CAEN_V1190_SHORT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  SINGLE(VME_CAEN_V1190_SHORT_SUBTDC,tdc[4]);
  SINGLE(VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(572,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(569,header.geom,geom);
  CHECK_BITS_EQUAL(571,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  bitsone<4> __visited1;
  __visited1.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1190_SHORT_SUBTDC tdc[0]: (s32) => (0xfb000000,0x00000000)
    // optimized match 2: VME_CAEN_V1190_SHORT_SUBTDC tdc[1]: (s32) => (0xfb000000,0x01000000)
    // optimized match 3: VME_CAEN_V1190_SHORT_SUBTDC tdc[2]: (s32) => (0xfb000000,0x02000000)
    // optimized match 4: VME_CAEN_V1190_SHORT_SUBTDC tdc[3]: (s32) => (0xfb000000,0x03000000)
    // optimized match 5: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[0]: (s32) => (0xffff8000,0x20000000)
    // optimized match 6: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[1]: (s32) => (0xffff8000,0x21000000)
    // optimized match 7: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[2]: (s32) => (0xffff8000,0x22000000)
    // optimized match 8: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[3]: (s32) => (0xffff8000,0x23000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(585,uint32,__match_peek);
    // differ = 23000000 : 24 25 29
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003) | /* 29,29 */ ((__match_peek >> 27) & 0x00000004);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 6, 7, 8, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(576,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(576,VME_CAEN_V1190_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(577,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(577,VME_CAEN_V1190_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(578,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(578,VME_CAEN_V1190_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(579,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(579,VME_CAEN_V1190_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(581,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/0);
        UNPACK_CHECK_NO_REVISIT(581,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],__visited1,0);
        UNPACK_DECL(581,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(582,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/1);
        UNPACK_CHECK_NO_REVISIT(582,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],__visited1,1);
        UNPACK_DECL(582,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(583,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/2);
        UNPACK_CHECK_NO_REVISIT(583,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],__visited1,2);
        UNPACK_DECL(583,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(584,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/3);
        UNPACK_CHECK_NO_REVISIT(584,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],__visited1,3);
        UNPACK_DECL(584,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
        break;
    }
  }
  spurious_match_abort_loop_1:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(591,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(590,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(603,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(597,trailer.geom,geom);
  CHECK_WORD_COUNT(598,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(602,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(603,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(572,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(569,__header.geom,geom);
  MATCH_BITS_EQUAL(571,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  {
    PACK_DECL(576,VME_CAEN_V1190_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(577,VME_CAEN_V1190_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(578,VME_CAEN_V1190_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(579,VME_CAEN_V1190_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(581,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
    PACK_DECL(582,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
    PACK_DECL(583,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
    PACK_DECL(584,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290
//
//
// Generating code for: VME_CAEN_V1290_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SUBTDC
class VME_CAEN_V1290_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SUBTDC
class PACKER_VME_CAEN_V1290_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;
  // MARK_COUNT(tdc_end);
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1290_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id
                                                           ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._data;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  READ_FROM_BUFFER_FULL(217,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(213,header.event_id,event_id);
  CHECK_BITS_EQUAL(215,header.tdc,tdc);
  CHECK_BITS_EQUAL(216,header.unnamed_27_31,1);
  CHECK_UNNAMED_BITS_ZERO(217,header.u32,0x04000000);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_2;
  PEEK_FROM_BUFFER_FULL(244,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(224,ch_data.tdc,tdc,data_done_2);
  CHECK_JUMP_BITS_EQUAL(234,ch_data.unnamed_27_31,0,data_done_2);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(238,((ch_data.tdc << 3) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
  }
  data_done_2:;
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  if (__buffer.empty()) goto data_done_3;
  PEEK_FROM_BUFFER_FULL(252,uint32 ,error_flags,__error_flags.u32);
  CHECK_JUMP_BITS_EQUAL(250,__error_flags.tdc,tdc,data_done_3);
  CHECK_JUMP_BITS_EQUAL(251,__error_flags.unnamed_27_31,4,data_done_3);
  CHECK_JUMP_UNNAMED_BITS_ZERO(252,__error_flags.u32,0x04ff8000,data_done_3);
  error_flags.u32 = __error_flags.u32;
  __buffer.advance(sizeof(__error_flags.u32));
  data_done_3:;
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  READ_FROM_BUFFER_FULL(263,uint32 ,trailer,trailer.u32);
  CHECK_WORD_COUNT(258,trailer.word_count,tdc_start,tdc_end,4,4);
  CHECK_BITS_EQUAL(259,trailer.event_id,header.event_id);
  CHECK_BITS_EQUAL(261,trailer.tdc,tdc);
  CHECK_BITS_EQUAL(262,trailer.unnamed_27_31,3);
  CHECK_UNNAMED_BITS_ZERO(263,trailer.u32,0x04000000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SUBTDC::__unpack,uint32 tdc
                                                                ,uint32 event_id
                                                                ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1290_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(217,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(213,__header.event_id,event_id);
  MATCH_BITS_EQUAL(215,__header.tdc,tdc);
  MATCH_BITS_EQUAL(216,__header.unnamed_27_31,1);
  MATCH_UNNAMED_BITS_ZERO(217,__header.u32,0x04000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SUBTDC::__match,uint32 tdc
                                                               ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                   ,uint32 event_id
                                                                   ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SUBTDC::__packer,uint32 tdc
                                                                ,uint32 event_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290
class VME_CAEN_V1290
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290
class PACKER_VME_CAEN_V1290
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  SINGLE(VME_CAEN_V1290_SUBTDC,tdc[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_src_t>
void VME_CAEN_V1290::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(278,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(275,header.geom,geom);
  CHECK_BITS_EQUAL(277,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_SUBTDC tdc[0]: (s32) => (0xff000000,0x08000000)
    // optimized match 2: VME_CAEN_V1290_SUBTDC tdc[1]: (s32) => (0xff000000,0x09000000)
    // optimized match 3: VME_CAEN_V1290_SUBTDC tdc[2]: (s32) => (0xff000000,0x0a000000)
    // optimized match 4: VME_CAEN_V1290_SUBTDC tdc[3]: (s32) => (0xff000000,0x0b000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(286,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(282,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(282,VME_CAEN_V1290_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(283,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(283,VME_CAEN_V1290_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(284,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(284,VME_CAEN_V1290_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(285,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(285,VME_CAEN_V1290_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_2:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(292,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(291,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(304,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(298,trailer.geom,geom);
  CHECK_WORD_COUNT(299,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(303,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(304,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_src_t>
bool VME_CAEN_V1290::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(278,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(275,__header.geom,geom);
  MATCH_BITS_EQUAL(277,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  {
    PACK_DECL(282,VME_CAEN_V1290_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(283,VME_CAEN_V1290_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(284,VME_CAEN_V1290_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(285,VME_CAEN_V1290_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_SHORT
//
//
// Generating code for: VME_CAEN_V1290_SHORT_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT_SUBTDC
class VME_CAEN_V1290_SHORT_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT_SUBTDC
class PACKER_VME_CAEN_V1290_SHORT_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc
                                                                 ,uint32 event_id
                                                                 ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(341,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(321,ch_data.tdc,tdc);
  CHECK_BITS_EQUAL(331,ch_data.unnamed_27_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(335,((ch_data.tdc << 3) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC::__unpack,uint32 tdc
                                                                      ,uint32 event_id
                                                                      ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc
                                                                ,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(341,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(321,ch_data.tdc,tdc);
  MATCH_BITS_EQUAL(331,ch_data.unnamed_27_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT_SUBTDC::__match,uint32 tdc
                                                                     ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                         ,uint32 event_id
                                                                         ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC::__packer,uint32 tdc
                                                                      ,uint32 event_id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_SHORT_SUBTDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
class VME_CAEN_V1290_SHORT_SUBTDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
class PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT_SUBTDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__unpack(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  READ_FROM_BUFFER_FULL(352,uint32 ,error_flags,error_flags.u32);
  CHECK_BITS_EQUAL(350,error_flags.tdc,tdc);
  CHECK_BITS_EQUAL(351,error_flags.unnamed_27_31,4);
  CHECK_UNNAMED_BITS_ZERO(352,error_flags.u32,0x04ff8000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__unpack,uint32 tdc);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__match(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  READ_FROM_BUFFER_FULL(352,uint32 ,error_flags,__error_flags.u32);
  MATCH_BITS_EQUAL(350,__error_flags.tdc,tdc);
  MATCH_BITS_EQUAL(351,__error_flags.unnamed_27_31,4);
  MATCH_UNNAMED_BITS_ZERO(352,__error_flags.u32,0x04ff8000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__match,uint32 tdc);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__packer(__data_dest_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__packer,uint32 tdc);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT
class VME_CAEN_V1290_SHORT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT
class PACKER_VME_CAEN_V1290_SHORT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  SINGLE(VME_CAEN_V1290_SHORT_SUBTDC,tdc[4]);
  SINGLE(VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(367,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(364,header.geom,geom);
  CHECK_BITS_EQUAL(366,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  bitsone<4> __visited2;
  __visited2.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_SHORT_SUBTDC tdc[0]: (s32) => (0xfb000000,0x00000000)
    // optimized match 2: VME_CAEN_V1290_SHORT_SUBTDC tdc[1]: (s32) => (0xfb000000,0x01000000)
    // optimized match 3: VME_CAEN_V1290_SHORT_SUBTDC tdc[2]: (s32) => (0xfb000000,0x02000000)
    // optimized match 4: VME_CAEN_V1290_SHORT_SUBTDC tdc[3]: (s32) => (0xfb000000,0x03000000)
    // optimized match 5: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[0]: (s32) => (0xffff8000,0x20000000)
    // optimized match 6: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[1]: (s32) => (0xffff8000,0x21000000)
    // optimized match 7: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[2]: (s32) => (0xffff8000,0x22000000)
    // optimized match 8: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[3]: (s32) => (0xffff8000,0x23000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(380,uint32,__match_peek);
    // differ = 23000000 : 24 25 29
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003) | /* 29,29 */ ((__match_peek >> 27) & 0x00000004);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 6, 7, 8, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(371,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(371,VME_CAEN_V1290_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(372,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(372,VME_CAEN_V1290_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(373,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(373,VME_CAEN_V1290_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(374,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(374,VME_CAEN_V1290_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(376,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/0);
        UNPACK_CHECK_NO_REVISIT(376,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],__visited2,0);
        UNPACK_DECL(376,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(377,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/1);
        UNPACK_CHECK_NO_REVISIT(377,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],__visited2,1);
        UNPACK_DECL(377,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(378,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/2);
        UNPACK_CHECK_NO_REVISIT(378,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],__visited2,2);
        UNPACK_DECL(378,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(379,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/3);
        UNPACK_CHECK_NO_REVISIT(379,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],__visited2,3);
        UNPACK_DECL(379,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
        break;
    }
  }
  spurious_match_abort_loop_3:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(386,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(385,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(398,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(392,trailer.geom,geom);
  CHECK_WORD_COUNT(393,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(397,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(398,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(367,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(364,__header.geom,geom);
  MATCH_BITS_EQUAL(366,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  {
    PACK_DECL(371,VME_CAEN_V1290_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(372,VME_CAEN_V1290_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(373,VME_CAEN_V1290_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(374,VME_CAEN_V1290_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(376,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
    PACK_DECL(377,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
    PACK_DECL(378,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
    PACK_DECL(379,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V775
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V775
class VME_CAEN_V775
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V775
class PACKER_VME_CAEN_V775
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,32> data;
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 event_number : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 crate);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 crate);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 crate);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V775);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_src_t>
void VME_CAEN_V775::__unpack(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 dummy_0_7 : 8;
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 dummy_0_7 : 8;
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(136,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(133,header.crate,crate);
  CHECK_BITS_EQUAL(134,header.unnamed_24_26,2);
  CHECK_BITS_EQUAL(135,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(136,header.u32,0x0000c0ff);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 overflow : 1; // 12
        uint32 underflow : 1; // 13
        uint32 valid : 1; // 14
        uint32 dummy_15 : 1;
        uint32 channel : 5; // 16..20
        uint32 dummy_21_23 : 3;
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 dummy_21_23 : 3;
        uint32 channel : 5; // 16..20
        uint32 dummy_15 : 1;
        uint32 valid : 1; // 14
        uint32 underflow : 1; // 13
        uint32 overflow : 1; // 12
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(156,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(152,ch_data.unnamed_24_26,0);
    CHECK_BITS_EQUAL(153,ch_data.geom,geom);
    CHECK_UNNAMED_BITS_ZERO(156,ch_data.u32,0x00e08000);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(155,ch_data.channel);
      __item.value = ch_data.value;
      __item.overflow = ch_data.overflow;
    }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  READ_FROM_BUFFER_FULL(165,uint32 ,eob,eob.u32);
  CHECK_BITS_EQUAL(162,eob.unnamed_24_26,4);
  CHECK_BITS_EQUAL(163,eob.geom,geom);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V775::__unpack,uint32 geom,uint32 crate);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_src_t>
bool VME_CAEN_V775::__match(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 dummy_0_7 : 8;
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 dummy_0_7 : 8;
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(136,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(133,header.crate,crate);
  MATCH_BITS_EQUAL(134,header.unnamed_24_26,2);
  MATCH_BITS_EQUAL(135,header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(136,header.u32,0x0000c0ff);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V775::__match,uint32 geom,uint32 crate);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V775::__packer(__data_dest_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V775::__packer,uint32 geom,uint32 crate);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V830
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V830
class VME_CAEN_V830
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V830
class PACKER_VME_CAEN_V830
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 dummy_24_25 : 2;
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 dummy_24_25 : 2;
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V830);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
void VME_CAEN_V830::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  READ_FROM_BUFFER_FULL(184,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(182,header.unnamed_26_26,1);
  CHECK_BITS_EQUAL(183,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(184,header.u32,0x03000000);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 26; // 0..25
        uint32 unnamed_26_26 : 1; // 26
        uint32 channel : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel : 5; // 27..31
        uint32 unnamed_26_26 : 1; // 26
        uint32 value : 26; // 0..25
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(195,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(191,ch_data.unnamed_26_26,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(194,ch_data.channel);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
bool VME_CAEN_V830::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 dummy_24_25 : 2;
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 dummy_24_25 : 2;
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(184,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(182,__header.unnamed_26_26,1);
  MATCH_BITS_EQUAL(183,__header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(184,__header.u32,0x03000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V830::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V830::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MADC32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MADC32
class VME_MESYTEC_MADC32
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MADC32
class PACKER_VME_MESYTEC_MADC32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA14_OVERFLOW,DATA14_OVERFLOW,32> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MADC32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
void VME_MESYTEC_MADC32::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(623,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(620,header.geom,geom);
  CHECK_BITS_EQUAL(621,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(622,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 13; // 0..12
      uint32 dummy_13 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_15 : 1;
      uint32 channel : 5; // 16..20
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 channel : 5; // 16..20
      uint32 dummy_15 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_13 : 1;
      uint32 value : 13; // 0..12
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_4;
  PEEK_FROM_BUFFER_FULL(634,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(630,ch_data.unnamed_21_29,32,data_done_4);
  CHECK_JUMP_BITS_EQUAL(631,ch_data.unnamed_30_31,0,data_done_4);
  CHECK_JUMP_UNNAMED_BITS_ZERO(634,ch_data.u32,0x0000a000,data_done_4);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(633,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.outofrange;
  }
  }
  data_done_4:;
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  if (__buffer.empty()) goto data_done_5;
  PEEK_FROM_BUFFER_FULL(640,uint32 ,filler,filler.u32);
  CHECK_JUMP_BITS_EQUAL(639,filler.unnamed_0_31,0,data_done_5);
  __buffer.advance(sizeof(filler.u32));
  data_done_5:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(646,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(645,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(649,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MADC32::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(623,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(620,header.geom,geom);
  MATCH_BITS_EQUAL(621,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(622,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MADC32::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MADC32::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MDPP16
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MDPP16
class VME_MESYTEC_MDPP16
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MDPP16
class PACKER_VME_MESYTEC_MDPP16
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16_OVERFLOW,DATA16_OVERFLOW,34,100> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MDPP16);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_src_t>
void VME_MESYTEC_MDPP16::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 10; // 0..9
      uint32 adc_res : 3; // 10..12
      uint32 tdc_res : 3; // 13..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_res : 3; // 13..15
      uint32 adc_res : 3; // 10..12
      uint32 word_number : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(667,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(664,header.geom,geom);
  CHECK_BITS_EQUAL(665,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(666,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 16; // 0..15
      uint32 channel : 6; // 16..21
      uint32 overflow : 1; // 22
      uint32 pileup : 1; // 23
      uint32 unnamed_24_27 : 4; // 24..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 unnamed_24_27 : 4; // 24..27
      uint32 pileup : 1; // 23
      uint32 overflow : 1; // 22
      uint32 channel : 6; // 16..21
      uint32 value : 16; // 0..15
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_6;
  PEEK_FROM_BUFFER_FULL(679,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(675,ch_data.unnamed_24_27,0,data_done_6);
  CHECK_JUMP_BITS_EQUAL(676,ch_data.unnamed_28_31,1,data_done_6);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(678,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.overflow;
    __item.pileup = ch_data.pileup;
  }
  }
  data_done_6:;
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } fill_word;
  if (__buffer.empty()) goto data_done_7;
  PEEK_FROM_BUFFER_FULL(684,uint32 ,fill_word,fill_word.u32);
  CHECK_JUMP_BITS_EQUAL(683,fill_word.unnamed_0_31,0,data_done_7);
  __buffer.advance(sizeof(fill_word.u32));
  }
  data_done_7:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(690,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(689,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(693,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MDPP16::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MDPP16::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 10; // 0..9
      uint32 adc_res : 3; // 10..12
      uint32 tdc_res : 3; // 13..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_res : 3; // 13..15
      uint32 adc_res : 3; // 10..12
      uint32 word_number : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(667,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(664,header.geom,geom);
  MATCH_BITS_EQUAL(665,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(666,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MDPP16::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MDPP16::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MDPP16::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESY_MADC32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESY_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESY_MADC32
class VME_MESY_MADC32
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESY_MADC32
class PACKER_VME_MESY_MADC32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,32> data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // list(0<=index<(header.word_number - 1))

    // UINT32 ch_data NOENCODE
    // {
      //  0_12: value;
      //    14: outofrange;
      // 16_20: channel;
      // 21_29: 32;
      // 30_31: 0;
      // ENCODE(data[channel],(value=value));
    // }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESY_MADC32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESY_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32(geom)
template<typename __data_src_t>
void VME_MESY_MADC32::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16 data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(720,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(717,header.geom,geom);
  CHECK_BITS_EQUAL(718,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(719,header.unnamed_30_31,1);
  // list(0<=index<(header.word_number - 1))

  for (uint32 index = 0; index < (uint32) ((header.word_number - 1)); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_12: value;
      //    14: outofrange;
      // 16_20: channel;
      // 21_29: 32;
      // 30_31: 0;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 13; // 0..12
        uint32 dummy_13 : 1;
        uint32 outofrange : 1; // 14
        uint32 dummy_15 : 1;
        uint32 channel : 5; // 16..20
        uint32 unnamed_21_29 : 9; // 21..29
        uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_30_31 : 2; // 30..31
        uint32 unnamed_21_29 : 9; // 21..29
        uint32 channel : 5; // 16..20
        uint32 dummy_15 : 1;
        uint32 outofrange : 1; // 14
        uint32 dummy_13 : 1;
        uint32 value : 13; // 0..12
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(733,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(729,ch_data.unnamed_21_29,32);
    CHECK_BITS_EQUAL(730,ch_data.unnamed_30_31,0);
    CHECK_UNNAMED_BITS_ZERO(733,ch_data.u32,0x0000a000);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(732,ch_data.channel);
      __item.value = ch_data.value;
    }
  }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  READ_FROM_BUFFER_FULL(740,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(739,end_of_event.unnamed_30_31,3);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESY_MADC32::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESY_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32(geom)
template<typename __data_src_t>
bool VME_MESY_MADC32::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16 data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(720,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(717,header.geom,geom);
  MATCH_BITS_EQUAL(718,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(719,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESY_MADC32::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESY_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32(geom)
template<typename __data_dest_t>
void PACKER_VME_MESY_MADC32::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16 data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // list(0<=index<(header.word_number - 1))

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_12: value;
      //    14: outofrange;
      // 16_20: channel;
      // 21_29: 32;
      // 30_31: 0;
      // ENCODE(data[channel],(value=value));
    // }
  }
  // UINT32 end_of_event NOENCODE
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESY_MADC32::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESY_MADC32_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESY_MADC32_PADDING.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESY_MADC32_PADDING
class VME_MESY_MADC32_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESY_MADC32_PADDING
class PACKER_VME_MESY_MADC32_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 padding NOENCODE
  // {
    //  0_31: value = MATCH(0x32323232);
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESY_MADC32_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESY_MADC32_PADDING.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32_PADDING()
template<typename __data_src_t>
void VME_MESY_MADC32_PADDING::__unpack(__data_src_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_31: value = MATCH(0x32323232);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 value : 32; // 0..31
#endif
    };
    uint32  u32;
  } padding;
  READ_FROM_BUFFER_FULL(705,uint32 ,padding,padding.u32);
  CHECK_BITS_EQUAL(704,padding.value,0x32323232);
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_MESY_MADC32_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESY_MADC32_PADDING.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32_PADDING()
template<typename __data_src_t>
bool VME_MESY_MADC32_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_31: value = MATCH(0x32323232);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 value : 32; // 0..31
#endif
    };
    uint32  u32;
  } padding;
  READ_FROM_BUFFER_FULL(705,uint32 ,padding,padding.u32);
  MATCH_BITS_EQUAL(704,padding.value,0x32323232);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_MESY_MADC32_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESY_MADC32_PADDING.
 *
 * Do not edit - automatically generated.
 */

// VME_MESY_MADC32_PADDING()
template<typename __data_dest_t>
void PACKER_VME_MESY_MADC32_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_31: value = MATCH(0x32323232);
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_MESY_MADC32_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_STRUCK_SIS3316
//
//
// Generating code for: VME_STRUCK_SIS3316_CHANNEL
//
//
// Generating code for: VME_STRUCK_SIS3316_CHANNEL_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_STRUCK_SIS3316_CHANNEL_DATA.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL_DATA(id,ch)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_STRUCK_SIS3316_CHANNEL_DATA
class VME_STRUCK_SIS3316_CHANNEL_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_VME_STRUCK_SIS3316_CHANNEL_DATA
class PACKER_VME_STRUCK_SIS3316_CHANNEL_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 ts[2] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,2> ts;
  // MEMBER(DATA32 gate[8] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,8> gate;
  // MEMBER(DATA32 maw[3] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,3> maw;
  // MEMBER(DATA32 maxe[2] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,2> maxe;
  // UINT32 header0
  // {
    //     0: has_acc6;
    //     1: has_acc2;
    //     2: has_maw;
    //     3: has_e;
    //  4_07: chanNo = MATCH(ch);
    //  8_15: id = MATCH(id);
    // 16_31: timeS;
    // ENCODE(ts[0],(value=timeS));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 has_acc6 : 1; // 0
      uint32 has_acc2 : 1; // 1
      uint32 has_maw : 1; // 2
      uint32 has_e : 1; // 3
      uint32 chanNo : 4; // 4..7
      uint32 id : 8; // 8..15
      uint32 timeS : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timeS : 16; // 16..31
      uint32 id : 8; // 8..15
      uint32 chanNo : 4; // 4..7
      uint32 has_e : 1; // 3
      uint32 has_maw : 1; // 2
      uint32 has_acc2 : 1; // 1
      uint32 has_acc6 : 1; // 0
#endif
    };
    uint32  u32;
  } header0;
  // UINT32 header2
  // {
    //  0_31: timeS;
    // ENCODE(ts[1],(value=timeS));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timeS : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timeS : 32; // 0..31
#endif
    };
    uint32  u32;
  } header2;
  // if(header0.has_acc6)

    // UINT32 peak NOENCODE
    // {
      //  0_15: peakValue;
      // 16_31: peakIndex;
    // }
    // UINT32 gate_group_1
    // {
      //  0_23: sum;
      // 24_27: reserved;
      //    28: has_pileup;
      //    29: has_repileup;
      //    30: has_underflow;
      //    31: has_overflow;
      // ENCODE(gate[0],(value=sum));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 sum : 24; // 0..23
        uint32 reserved : 4; // 24..27
        uint32 has_pileup : 1; // 28
        uint32 has_repileup : 1; // 29
        uint32 has_underflow : 1; // 30
        uint32 has_overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 has_overflow : 1; // 31
        uint32 has_underflow : 1; // 30
        uint32 has_repileup : 1; // 29
        uint32 has_pileup : 1; // 28
        uint32 reserved : 4; // 24..27
        uint32 sum : 24; // 0..23
#endif
      };
      uint32  u32;
    } gate_group_1;
    // list(1<=i<6)

      // UINT32 gate_group_2_6
      // {
        //  0_27: sum;
        // 28_31: 0;
        // ENCODE(gate[i],(value=sum));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 sum : 28; // 0..27
          uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_28_31 : 4; // 28..31
          uint32 sum : 28; // 0..27
#endif
        };
        uint32  u32;
      } gate_group_2_6;
  // if(header0.has_acc2)

    // list(6<=i<8)

      // UINT32 gate_group_7_8
      // {
        //  0_27: sum;
        // 28_31: 0;
        // ENCODE(gate[i],(value=sum));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 sum : 28; // 0..27
          uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_28_31 : 4; // 28..31
          uint32 sum : 28; // 0..27
#endif
        };
        uint32  u32;
      } gate_group_7_8;
  // if(header0.has_maw)

    // UINT32 maw1
    // {
      //  0_31: max;
      // ENCODE(maw[0],(value=max));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 max : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 max : 32; // 0..31
#endif
      };
      uint32  u32;
    } maw1;
    // UINT32 maw2
    // {
      //  0_31: after;
      // ENCODE(maw[1],(value=after));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 after : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 after : 32; // 0..31
#endif
      };
      uint32  u32;
    } maw2;
    // UINT32 maw3
    // {
      //  0_31: before;
      // ENCODE(maw[2],(value=before));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 before : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 before : 32; // 0..31
#endif
      };
      uint32  u32;
    } maw3;
  // if(header0.has_e)

    // UINT32 maxe1
    // {
      //  0_31: start;
      // ENCODE(maxe[0],(value=(start + 0x08000000)));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 start : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 start : 32; // 0..31
#endif
      };
      uint32  u32;
    } maxe1;
    // UINT32 maxe2
    // {
      //  0_31: max;
      // ENCODE(maxe[1],(value=(max + 0x08000000)));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 max : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 max : 32; // 0..31
#endif
      };
      uint32  u32;
    } maxe2;
  // UINT32 header3
  // {
    //  0_25: sampleLength;
    //    26: pileup;
    //    27: mawFlag;
    // 28_31: 14;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 sampleLength : 26; // 0..25
      uint32 pileup : 1; // 26
      uint32 mawFlag : 1; // 27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 mawFlag : 1; // 27
      uint32 pileup : 1; // 26
      uint32 sampleLength : 26; // 0..25
#endif
    };
    uint32  u32;
  } header3;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id,uint32 ch);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id,uint32 ch);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id,uint32 ch);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_STRUCK_SIS3316_CHANNEL_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_STRUCK_SIS3316_CHANNEL_DATA.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL_DATA(id,ch)
template<typename __data_src_t>
void VME_STRUCK_SIS3316_CHANNEL_DATA::__unpack(__data_src_t &__buffer,uint32 id
                                                                     ,uint32 ch)
{
  // MEMBER(DATA32 ts[2] ZERO_SUPPRESS);
  // MEMBER(DATA32 gate[8] ZERO_SUPPRESS);
  // MEMBER(DATA32 maw[3] ZERO_SUPPRESS);
  // MEMBER(DATA32 maxe[2] ZERO_SUPPRESS);
  // UINT32 header0
  // {
    //     0: has_acc6;
    //     1: has_acc2;
    //     2: has_maw;
    //     3: has_e;
    //  4_07: chanNo = MATCH(ch);
    //  8_15: id = MATCH(id);
    // 16_31: timeS;
    // ENCODE(ts[0],(value=timeS));
  // }
  READ_FROM_BUFFER_FULL(1148,uint32 ,header0,header0.u32);
  CHECK_BITS_EQUAL(1144,header0.chanNo,ch);
  CHECK_BITS_EQUAL(1145,header0.id,id);
  {
    typedef __typeof__(*(&(ts))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts.insert_index(1147,0);
    __item.value = header0.timeS;
  }
  // UINT32 header2
  // {
    //  0_31: timeS;
    // ENCODE(ts[1],(value=timeS));
  // }
  READ_FROM_BUFFER_FULL(1154,uint32 ,header2,header2.u32);
  {
    typedef __typeof__(*(&(ts))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts.insert_index(1153,1);
    __item.value = header2.timeS;
  }
  // if(header0.has_acc6)

  if (header0.has_acc6)
  {
    // UINT32 peak NOENCODE
    // {
      //  0_15: peakValue;
      // 16_31: peakIndex;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 peakValue : 16; // 0..15
        uint32 peakIndex : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 peakIndex : 16; // 16..31
        uint32 peakValue : 16; // 0..15
#endif
      };
      uint32  u32;
    } peak;
    READ_FROM_BUFFER_FULL(1161,uint32 ,peak,peak.u32);
    // UINT32 gate_group_1
    // {
      //  0_23: sum;
      // 24_27: reserved;
      //    28: has_pileup;
      //    29: has_repileup;
      //    30: has_underflow;
      //    31: has_overflow;
      // ENCODE(gate[0],(value=sum));
    // }
    READ_FROM_BUFFER_FULL(1173,uint32 ,gate_group_1,gate_group_1.u32);
    {
      typedef __typeof__(*(&(gate))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = gate.insert_index(1172,0);
      __item.value = gate_group_1.sum;
    }
    // list(1<=i<6)

    for (uint32 i = 1; i < (uint32) (6); ++i)
    {
      // UINT32 gate_group_2_6
      // {
        //  0_27: sum;
        // 28_31: 0;
        // ENCODE(gate[i],(value=sum));
      // }
      READ_FROM_BUFFER_FULL(1183,uint32 ,gate_group_2_6,gate_group_2_6.u32);
      CHECK_BITS_EQUAL(1181,gate_group_2_6.unnamed_28_31,0);
      {
        typedef __typeof__(*(&(gate))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = gate.insert_index(1182,i);
        __item.value = gate_group_2_6.sum;
      }
    }
  }
  // if(header0.has_acc2)

  if (header0.has_acc2)
  {
    // list(6<=i<8)

    for (uint32 i = 6; i < (uint32) (8); ++i)
    {
      // UINT32 gate_group_7_8
      // {
        //  0_27: sum;
        // 28_31: 0;
        // ENCODE(gate[i],(value=sum));
      // }
      READ_FROM_BUFFER_FULL(1196,uint32 ,gate_group_7_8,gate_group_7_8.u32);
      CHECK_BITS_EQUAL(1194,gate_group_7_8.unnamed_28_31,0);
      {
        typedef __typeof__(*(&(gate))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = gate.insert_index(1195,i);
        __item.value = gate_group_7_8.sum;
      }
    }
  }
  // if(header0.has_maw)

  if (header0.has_maw)
  {
    // UINT32 maw1
    // {
      //  0_31: max;
      // ENCODE(maw[0],(value=max));
    // }
    READ_FROM_BUFFER_FULL(1205,uint32 ,maw1,maw1.u32);
    {
      typedef __typeof__(*(&(maw))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = maw.insert_index(1204,0);
      __item.value = maw1.max;
    }
    // UINT32 maw2
    // {
      //  0_31: after;
      // ENCODE(maw[1],(value=after));
    // }
    READ_FROM_BUFFER_FULL(1211,uint32 ,maw2,maw2.u32);
    {
      typedef __typeof__(*(&(maw))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = maw.insert_index(1210,1);
      __item.value = maw2.after;
    }
    // UINT32 maw3
    // {
      //  0_31: before;
      // ENCODE(maw[2],(value=before));
    // }
    READ_FROM_BUFFER_FULL(1217,uint32 ,maw3,maw3.u32);
    {
      typedef __typeof__(*(&(maw))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = maw.insert_index(1216,2);
      __item.value = maw3.before;
    }
  }
  // if(header0.has_e)

  if (header0.has_e)
  {
    // UINT32 maxe1
    // {
      //  0_31: start;
      // ENCODE(maxe[0],(value=(start + 0x08000000)));
    // }
    READ_FROM_BUFFER_FULL(1225,uint32 ,maxe1,maxe1.u32);
    {
      typedef __typeof__(*(&(maxe))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = maxe.insert_index(1224,0);
      __item.value = (maxe1.start + 0x08000000);
    }
    // UINT32 maxe2
    // {
      //  0_31: max;
      // ENCODE(maxe[1],(value=(max + 0x08000000)));
    // }
    READ_FROM_BUFFER_FULL(1231,uint32 ,maxe2,maxe2.u32);
    {
      typedef __typeof__(*(&(maxe))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = maxe.insert_index(1230,1);
      __item.value = (maxe2.max + 0x08000000);
    }
  }
  // UINT32 header3
  // {
    //  0_25: sampleLength;
    //    26: pileup;
    //    27: mawFlag;
    // 28_31: 14;
  // }
  READ_FROM_BUFFER_FULL(1240,uint32 ,header3,header3.u32);
  CHECK_BITS_EQUAL(1239,header3.unnamed_28_31,14);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_STRUCK_SIS3316_CHANNEL_DATA::__unpack,uint32 id
                                                                          ,uint32 ch);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_STRUCK_SIS3316_CHANNEL_DATA.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL_DATA(id,ch)
template<typename __data_src_t>
bool VME_STRUCK_SIS3316_CHANNEL_DATA::__match(__data_src_t &__buffer,uint32 id
                                                                    ,uint32 ch)
{
  // MEMBER(DATA32 ts[2] ZERO_SUPPRESS);
  // MEMBER(DATA32 gate[8] ZERO_SUPPRESS);
  // MEMBER(DATA32 maw[3] ZERO_SUPPRESS);
  // MEMBER(DATA32 maxe[2] ZERO_SUPPRESS);
  // UINT32 header0
  // {
    //     0: has_acc6;
    //     1: has_acc2;
    //     2: has_maw;
    //     3: has_e;
    //  4_07: chanNo = MATCH(ch);
    //  8_15: id = MATCH(id);
    // 16_31: timeS;
    // ENCODE(ts[0],(value=timeS));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 has_acc6 : 1; // 0
      uint32 has_acc2 : 1; // 1
      uint32 has_maw : 1; // 2
      uint32 has_e : 1; // 3
      uint32 chanNo : 4; // 4..7
      uint32 id : 8; // 8..15
      uint32 timeS : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 timeS : 16; // 16..31
      uint32 id : 8; // 8..15
      uint32 chanNo : 4; // 4..7
      uint32 has_e : 1; // 3
      uint32 has_maw : 1; // 2
      uint32 has_acc2 : 1; // 1
      uint32 has_acc6 : 1; // 0
#endif
    };
    uint32  u32;
  } __header0;
  READ_FROM_BUFFER_FULL(1148,uint32 ,header0,__header0.u32);
  MATCH_BITS_EQUAL(1144,__header0.chanNo,ch);
  MATCH_BITS_EQUAL(1145,__header0.id,id);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_STRUCK_SIS3316_CHANNEL_DATA::__match,uint32 id
                                                                         ,uint32 ch);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_STRUCK_SIS3316_CHANNEL_DATA.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL_DATA(id,ch)
template<typename __data_dest_t>
void PACKER_VME_STRUCK_SIS3316_CHANNEL_DATA::__packer(__data_dest_t &__buffer,uint32 id
                                                                             ,uint32 ch)
{
  // MEMBER(DATA32 ts[2] ZERO_SUPPRESS);
  // MEMBER(DATA32 gate[8] ZERO_SUPPRESS);
  // MEMBER(DATA32 maw[3] ZERO_SUPPRESS);
  // MEMBER(DATA32 maxe[2] ZERO_SUPPRESS);
  // UINT32 header0
  // {
    //     0: has_acc6;
    //     1: has_acc2;
    //     2: has_maw;
    //     3: has_e;
    //  4_07: chanNo = MATCH(ch);
    //  8_15: id = MATCH(id);
    // 16_31: timeS;
    // ENCODE(ts[0],(value=timeS));
  // }
  // UINT32 header2
  // {
    //  0_31: timeS;
    // ENCODE(ts[1],(value=timeS));
  // }
  // if(header0.has_acc6)

  if (header0.has_acc6)
  {
    // UINT32 peak NOENCODE
    // {
      //  0_15: peakValue;
      // 16_31: peakIndex;
    // }
    // UINT32 gate_group_1
    // {
      //  0_23: sum;
      // 24_27: reserved;
      //    28: has_pileup;
      //    29: has_repileup;
      //    30: has_underflow;
      //    31: has_overflow;
      // ENCODE(gate[0],(value=sum));
    // }
    // list(1<=i<6)

    {
      // UINT32 gate_group_2_6
      // {
        //  0_27: sum;
        // 28_31: 0;
        // ENCODE(gate[i],(value=sum));
      // }
    }
  }
  // if(header0.has_acc2)

  if (header0.has_acc2)
  {
    // list(6<=i<8)

    {
      // UINT32 gate_group_7_8
      // {
        //  0_27: sum;
        // 28_31: 0;
        // ENCODE(gate[i],(value=sum));
      // }
    }
  }
  // if(header0.has_maw)

  if (header0.has_maw)
  {
    // UINT32 maw1
    // {
      //  0_31: max;
      // ENCODE(maw[0],(value=max));
    // }
    // UINT32 maw2
    // {
      //  0_31: after;
      // ENCODE(maw[1],(value=after));
    // }
    // UINT32 maw3
    // {
      //  0_31: before;
      // ENCODE(maw[2],(value=before));
    // }
  }
  // if(header0.has_e)

  if (header0.has_e)
  {
    // UINT32 maxe1
    // {
      //  0_31: start;
      // ENCODE(maxe[0],(value=(start + 0x08000000)));
    // }
    // UINT32 maxe2
    // {
      //  0_31: max;
      // ENCODE(maxe[1],(value=(max + 0x08000000)));
    // }
  }
  // UINT32 header3
  // {
    //  0_25: sampleLength;
    //    26: pileup;
    //    27: mawFlag;
    // 28_31: 14;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_STRUCK_SIS3316_CHANNEL_DATA::__packer,uint32 id
                                                                          ,uint32 ch);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_STRUCK_SIS3316_CHANNEL.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL(id,ch)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_STRUCK_SIS3316_CHANNEL
class VME_STRUCK_SIS3316_CHANNEL
#else//PACKER_CODE
# define DECLARED_PACKER_VME_STRUCK_SIS3316_CHANNEL
class PACKER_VME_STRUCK_SIS3316_CHANNEL
#endif//PACKER_CODE

{
public:
  // UINT32 channel_header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_11: ch = MATCH(ch);
    // 12_15: padding_words;
    // 16_31: module = MATCH(0x3316);
  // }
  // list(0<=n<channel_header.padding_words)

    // UINT32 padding NOENCODE
    // {
      //  0_07: id = MATCH(id);
      //  8_15: ch = MATCH(ch);
      // 16_31: module = MATCH(0x3316);
    // }
  // select several

    // multi data = VME_STRUCK_SIS3316_CHANNEL_DATA(id=id,ch=ch);
  MULTI(VME_STRUCK_SIS3316_CHANNEL_DATA,data);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id,uint32 ch);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id,uint32 ch);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id,uint32 ch);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_STRUCK_SIS3316_CHANNEL);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_STRUCK_SIS3316_CHANNEL.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL(id,ch)
template<typename __data_src_t>
void VME_STRUCK_SIS3316_CHANNEL::__unpack(__data_src_t &__buffer,uint32 id
                                                                ,uint32 ch)
{
  // UINT32 channel_header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_11: ch = MATCH(ch);
    // 12_15: padding_words;
    // 16_31: module = MATCH(0x3316);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 8; // 0..7
      uint32 ch : 4; // 8..11
      uint32 padding_words : 4; // 12..15
      uint32 module : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 module : 16; // 16..31
      uint32 padding_words : 4; // 12..15
      uint32 ch : 4; // 8..11
      uint32 id : 8; // 0..7
#endif
    };
    uint32  u32;
  } channel_header;
  READ_FROM_BUFFER_FULL(1111,uint32 ,channel_header,channel_header.u32);
  CHECK_BITS_EQUAL(1110,channel_header.id,id);
  CHECK_BITS_EQUAL(1109,channel_header.ch,ch);
  CHECK_BITS_EQUAL(1107,channel_header.module,0x3316);
  // list(0<=n<channel_header.padding_words)

  for (uint32 n = 0; n < (uint32) (channel_header.padding_words); ++n)
  {
    // UINT32 padding NOENCODE
    // {
      //  0_07: id = MATCH(id);
      //  8_15: ch = MATCH(ch);
      // 16_31: module = MATCH(0x3316);
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 id : 8; // 0..7
        uint32 ch : 8; // 8..15
        uint32 module : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 module : 16; // 16..31
        uint32 ch : 8; // 8..15
        uint32 id : 8; // 0..7
#endif
      };
      uint32  u32;
    } padding;
    READ_FROM_BUFFER_FULL(1120,uint32 ,padding,padding.u32);
    CHECK_BITS_EQUAL(1119,padding.id,id);
    CHECK_BITS_EQUAL(1118,padding.ch,ch);
    CHECK_BITS_EQUAL(1117,padding.module,0x3316);
  }
  // select several

    // multi data = VME_STRUCK_SIS3316_CHANNEL_DATA(id=id,ch=ch);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_STRUCK_SIS3316_CHANNEL_DATA data: (s32) => (0x00000000,0x00000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1125,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1124,spurious_match_abort_loop_4,VME_STRUCK_SIS3316_CHANNEL_DATA,/*id*/id,/*ch*/ch);
        UNPACK_DECL(1124,VME_STRUCK_SIS3316_CHANNEL_DATA,multi_data.next_free(),/*id*/id,/*ch*/ch);
        break;
    }
  }
  spurious_match_abort_loop_4:;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_STRUCK_SIS3316_CHANNEL::__unpack,uint32 id
                                                                     ,uint32 ch);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_STRUCK_SIS3316_CHANNEL.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL(id,ch)
template<typename __data_src_t>
bool VME_STRUCK_SIS3316_CHANNEL::__match(__data_src_t &__buffer,uint32 id
                                                               ,uint32 ch)
{
  // UINT32 channel_header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_11: ch = MATCH(ch);
    // 12_15: padding_words;
    // 16_31: module = MATCH(0x3316);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 8; // 0..7
      uint32 ch : 4; // 8..11
      uint32 padding_words : 4; // 12..15
      uint32 module : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 module : 16; // 16..31
      uint32 padding_words : 4; // 12..15
      uint32 ch : 4; // 8..11
      uint32 id : 8; // 0..7
#endif
    };
    uint32  u32;
  } channel_header;
  READ_FROM_BUFFER_FULL(1111,uint32 ,channel_header,channel_header.u32);
  MATCH_BITS_EQUAL(1110,channel_header.id,id);
  MATCH_BITS_EQUAL(1109,channel_header.ch,ch);
  MATCH_BITS_EQUAL(1107,channel_header.module,0x3316);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_STRUCK_SIS3316_CHANNEL::__match,uint32 id
                                                                    ,uint32 ch);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_STRUCK_SIS3316_CHANNEL.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316_CHANNEL(id,ch)
template<typename __data_dest_t>
void PACKER_VME_STRUCK_SIS3316_CHANNEL::__packer(__data_dest_t &__buffer,uint32 id
                                                                        ,uint32 ch)
{
  // UINT32 channel_header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_11: ch = MATCH(ch);
    // 12_15: padding_words;
    // 16_31: module = MATCH(0x3316);
  // }
  // list(0<=n<channel_header.padding_words)

  {
    // UINT32 padding NOENCODE
    // {
      //  0_07: id = MATCH(id);
      //  8_15: ch = MATCH(ch);
      // 16_31: module = MATCH(0x3316);
    // }
  }
  // select several

    // multi data = VME_STRUCK_SIS3316_CHANNEL_DATA(id=id,ch=ch);
  {
    PACK_DECL(1124,VME_STRUCK_SIS3316_CHANNEL_DATA,data,/*id*/id,/*ch*/ch);
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_STRUCK_SIS3316_CHANNEL::__packer,uint32 id
                                                                     ,uint32 ch);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_STRUCK_SIS3316.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_STRUCK_SIS3316
class VME_STRUCK_SIS3316
#else//PACKER_CODE
# define DECLARED_PACKER_VME_STRUCK_SIS3316
class PACKER_VME_STRUCK_SIS3316
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 n_ch);
  DATA8 n_ch;
  // UINT32 header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_15: nofCH;
    // 16_31: module = MATCH(0x3316);
    // ENCODE(n_ch,(value=nofCH));
  // }
  // select several

    // channel[0] = VME_STRUCK_SIS3316_CHANNEL(ch=0,id=id);
    // channel[1] = VME_STRUCK_SIS3316_CHANNEL(ch=1,id=id);
    // channel[2] = VME_STRUCK_SIS3316_CHANNEL(ch=2,id=id);
    // channel[3] = VME_STRUCK_SIS3316_CHANNEL(ch=3,id=id);
    // channel[4] = VME_STRUCK_SIS3316_CHANNEL(ch=4,id=id);
    // channel[5] = VME_STRUCK_SIS3316_CHANNEL(ch=5,id=id);
    // channel[6] = VME_STRUCK_SIS3316_CHANNEL(ch=6,id=id);
    // channel[7] = VME_STRUCK_SIS3316_CHANNEL(ch=7,id=id);
    // channel[8] = VME_STRUCK_SIS3316_CHANNEL(ch=8,id=id);
    // channel[9] = VME_STRUCK_SIS3316_CHANNEL(ch=9,id=id);
    // channel[10] = VME_STRUCK_SIS3316_CHANNEL(ch=10,id=id);
    // channel[11] = VME_STRUCK_SIS3316_CHANNEL(ch=11,id=id);
    // channel[12] = VME_STRUCK_SIS3316_CHANNEL(ch=12,id=id);
    // channel[13] = VME_STRUCK_SIS3316_CHANNEL(ch=13,id=id);
    // channel[14] = VME_STRUCK_SIS3316_CHANNEL(ch=14,id=id);
    // channel[15] = VME_STRUCK_SIS3316_CHANNEL(ch=15,id=id);
  SINGLE(VME_STRUCK_SIS3316_CHANNEL,channel[16]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_STRUCK_SIS3316);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_STRUCK_SIS3316.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316(id)
template<typename __data_src_t>
void VME_STRUCK_SIS3316::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA8 n_ch);
  // UINT32 header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_15: nofCH;
    // 16_31: module = MATCH(0x3316);
    // ENCODE(n_ch,(value=nofCH));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 8; // 0..7
      uint32 nofCH : 8; // 8..15
      uint32 module : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 module : 16; // 16..31
      uint32 nofCH : 8; // 8..15
      uint32 id : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(1080,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(1078,header.id,id);
  CHECK_BITS_EQUAL(1076,header.module,0x3316);
  {
    n_ch.value = header.nofCH;
  }
  // select several

    // channel[0] = VME_STRUCK_SIS3316_CHANNEL(ch=0,id=id);
    // channel[1] = VME_STRUCK_SIS3316_CHANNEL(ch=1,id=id);
    // channel[2] = VME_STRUCK_SIS3316_CHANNEL(ch=2,id=id);
    // channel[3] = VME_STRUCK_SIS3316_CHANNEL(ch=3,id=id);
    // channel[4] = VME_STRUCK_SIS3316_CHANNEL(ch=4,id=id);
    // channel[5] = VME_STRUCK_SIS3316_CHANNEL(ch=5,id=id);
    // channel[6] = VME_STRUCK_SIS3316_CHANNEL(ch=6,id=id);
    // channel[7] = VME_STRUCK_SIS3316_CHANNEL(ch=7,id=id);
    // channel[8] = VME_STRUCK_SIS3316_CHANNEL(ch=8,id=id);
    // channel[9] = VME_STRUCK_SIS3316_CHANNEL(ch=9,id=id);
    // channel[10] = VME_STRUCK_SIS3316_CHANNEL(ch=10,id=id);
    // channel[11] = VME_STRUCK_SIS3316_CHANNEL(ch=11,id=id);
    // channel[12] = VME_STRUCK_SIS3316_CHANNEL(ch=12,id=id);
    // channel[13] = VME_STRUCK_SIS3316_CHANNEL(ch=13,id=id);
    // channel[14] = VME_STRUCK_SIS3316_CHANNEL(ch=14,id=id);
    // channel[15] = VME_STRUCK_SIS3316_CHANNEL(ch=15,id=id);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_STRUCK_SIS3316_CHANNEL channel[0]: (s32) => (0xffff0f00,0x33160000)
    // optimized match 2: VME_STRUCK_SIS3316_CHANNEL channel[1]: (s32) => (0xffff0f00,0x33160100)
    // optimized match 3: VME_STRUCK_SIS3316_CHANNEL channel[2]: (s32) => (0xffff0f00,0x33160200)
    // optimized match 4: VME_STRUCK_SIS3316_CHANNEL channel[3]: (s32) => (0xffff0f00,0x33160300)
    // optimized match 5: VME_STRUCK_SIS3316_CHANNEL channel[4]: (s32) => (0xffff0f00,0x33160400)
    // optimized match 6: VME_STRUCK_SIS3316_CHANNEL channel[5]: (s32) => (0xffff0f00,0x33160500)
    // optimized match 7: VME_STRUCK_SIS3316_CHANNEL channel[6]: (s32) => (0xffff0f00,0x33160600)
    // optimized match 8: VME_STRUCK_SIS3316_CHANNEL channel[7]: (s32) => (0xffff0f00,0x33160700)
    // optimized match 9: VME_STRUCK_SIS3316_CHANNEL channel[8]: (s32) => (0xffff0f00,0x33160800)
    // optimized match 10: VME_STRUCK_SIS3316_CHANNEL channel[9]: (s32) => (0xffff0f00,0x33160900)
    // optimized match 11: VME_STRUCK_SIS3316_CHANNEL channel[10]: (s32) => (0xffff0f00,0x33160a00)
    // optimized match 12: VME_STRUCK_SIS3316_CHANNEL channel[11]: (s32) => (0xffff0f00,0x33160b00)
    // optimized match 13: VME_STRUCK_SIS3316_CHANNEL channel[12]: (s32) => (0xffff0f00,0x33160c00)
    // optimized match 14: VME_STRUCK_SIS3316_CHANNEL channel[13]: (s32) => (0xffff0f00,0x33160d00)
    // optimized match 15: VME_STRUCK_SIS3316_CHANNEL channel[14]: (s32) => (0xffff0f00,0x33160e00)
    // optimized match 16: VME_STRUCK_SIS3316_CHANNEL channel[15]: (s32) => (0xffff0f00,0x33160f00)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1100,uint32,__match_peek);
    // differ = 00000f00 : 8 9 10 11
    uint32 __match_index = 0 | /* 8,11 */ ((__match_peek >> 8) & 0x0000000f);
    static const sint8 __match_index_array[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(1084,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/0);
        UNPACK_DECL(1084,VME_STRUCK_SIS3316_CHANNEL,channel[0],/*id*/id,/*ch*/0);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(1085,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/1);
        UNPACK_DECL(1085,VME_STRUCK_SIS3316_CHANNEL,channel[1],/*id*/id,/*ch*/1);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(1086,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/2);
        UNPACK_DECL(1086,VME_STRUCK_SIS3316_CHANNEL,channel[2],/*id*/id,/*ch*/2);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(1087,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/3);
        UNPACK_DECL(1087,VME_STRUCK_SIS3316_CHANNEL,channel[3],/*id*/id,/*ch*/3);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(1088,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/4);
        UNPACK_DECL(1088,VME_STRUCK_SIS3316_CHANNEL,channel[4],/*id*/id,/*ch*/4);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(1089,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/5);
        UNPACK_DECL(1089,VME_STRUCK_SIS3316_CHANNEL,channel[5],/*id*/id,/*ch*/5);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(1090,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/6);
        UNPACK_DECL(1090,VME_STRUCK_SIS3316_CHANNEL,channel[6],/*id*/id,/*ch*/6);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(1091,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/7);
        UNPACK_DECL(1091,VME_STRUCK_SIS3316_CHANNEL,channel[7],/*id*/id,/*ch*/7);
        break;
      case 9:
        CHECK_SPURIOUS_MATCH_DECL(1092,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/8);
        UNPACK_DECL(1092,VME_STRUCK_SIS3316_CHANNEL,channel[8],/*id*/id,/*ch*/8);
        break;
      case 10:
        CHECK_SPURIOUS_MATCH_DECL(1093,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/9);
        UNPACK_DECL(1093,VME_STRUCK_SIS3316_CHANNEL,channel[9],/*id*/id,/*ch*/9);
        break;
      case 11:
        CHECK_SPURIOUS_MATCH_DECL(1094,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/10);
        UNPACK_DECL(1094,VME_STRUCK_SIS3316_CHANNEL,channel[10],/*id*/id,/*ch*/10);
        break;
      case 12:
        CHECK_SPURIOUS_MATCH_DECL(1095,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/11);
        UNPACK_DECL(1095,VME_STRUCK_SIS3316_CHANNEL,channel[11],/*id*/id,/*ch*/11);
        break;
      case 13:
        CHECK_SPURIOUS_MATCH_DECL(1096,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/12);
        UNPACK_DECL(1096,VME_STRUCK_SIS3316_CHANNEL,channel[12],/*id*/id,/*ch*/12);
        break;
      case 14:
        CHECK_SPURIOUS_MATCH_DECL(1097,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/13);
        UNPACK_DECL(1097,VME_STRUCK_SIS3316_CHANNEL,channel[13],/*id*/id,/*ch*/13);
        break;
      case 15:
        CHECK_SPURIOUS_MATCH_DECL(1098,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/14);
        UNPACK_DECL(1098,VME_STRUCK_SIS3316_CHANNEL,channel[14],/*id*/id,/*ch*/14);
        break;
      case 16:
        CHECK_SPURIOUS_MATCH_DECL(1099,spurious_match_abort_loop_5,VME_STRUCK_SIS3316_CHANNEL,/*id*/id,/*ch*/15);
        UNPACK_DECL(1099,VME_STRUCK_SIS3316_CHANNEL,channel[15],/*id*/id,/*ch*/15);
        break;
    }
  }
  spurious_match_abort_loop_5:;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_STRUCK_SIS3316::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_STRUCK_SIS3316.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316(id)
template<typename __data_src_t>
bool VME_STRUCK_SIS3316::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA8 n_ch);
  // UINT32 header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_15: nofCH;
    // 16_31: module = MATCH(0x3316);
    // ENCODE(n_ch,(value=nofCH));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 8; // 0..7
      uint32 nofCH : 8; // 8..15
      uint32 module : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 module : 16; // 16..31
      uint32 nofCH : 8; // 8..15
      uint32 id : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(1080,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(1078,header.id,id);
  MATCH_BITS_EQUAL(1076,header.module,0x3316);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_STRUCK_SIS3316::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_STRUCK_SIS3316.
 *
 * Do not edit - automatically generated.
 */

// VME_STRUCK_SIS3316(id)
template<typename __data_dest_t>
void PACKER_VME_STRUCK_SIS3316::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA8 n_ch);
  // UINT32 header NOENCODE
  // {
    //  0_07: id = MATCH(id);
    //  8_15: nofCH;
    // 16_31: module = MATCH(0x3316);
    // ENCODE(n_ch,(value=nofCH));
  // }
  // select several

    // channel[0] = VME_STRUCK_SIS3316_CHANNEL(ch=0,id=id);
    // channel[1] = VME_STRUCK_SIS3316_CHANNEL(ch=1,id=id);
    // channel[2] = VME_STRUCK_SIS3316_CHANNEL(ch=2,id=id);
    // channel[3] = VME_STRUCK_SIS3316_CHANNEL(ch=3,id=id);
    // channel[4] = VME_STRUCK_SIS3316_CHANNEL(ch=4,id=id);
    // channel[5] = VME_STRUCK_SIS3316_CHANNEL(ch=5,id=id);
    // channel[6] = VME_STRUCK_SIS3316_CHANNEL(ch=6,id=id);
    // channel[7] = VME_STRUCK_SIS3316_CHANNEL(ch=7,id=id);
    // channel[8] = VME_STRUCK_SIS3316_CHANNEL(ch=8,id=id);
    // channel[9] = VME_STRUCK_SIS3316_CHANNEL(ch=9,id=id);
    // channel[10] = VME_STRUCK_SIS3316_CHANNEL(ch=10,id=id);
    // channel[11] = VME_STRUCK_SIS3316_CHANNEL(ch=11,id=id);
    // channel[12] = VME_STRUCK_SIS3316_CHANNEL(ch=12,id=id);
    // channel[13] = VME_STRUCK_SIS3316_CHANNEL(ch=13,id=id);
    // channel[14] = VME_STRUCK_SIS3316_CHANNEL(ch=14,id=id);
    // channel[15] = VME_STRUCK_SIS3316_CHANNEL(ch=15,id=id);
  {
    PACK_DECL(1084,VME_STRUCK_SIS3316_CHANNEL,channel[0],/*id*/id,/*ch*/0);
    PACK_DECL(1085,VME_STRUCK_SIS3316_CHANNEL,channel[1],/*id*/id,/*ch*/1);
    PACK_DECL(1086,VME_STRUCK_SIS3316_CHANNEL,channel[2],/*id*/id,/*ch*/2);
    PACK_DECL(1087,VME_STRUCK_SIS3316_CHANNEL,channel[3],/*id*/id,/*ch*/3);
    PACK_DECL(1088,VME_STRUCK_SIS3316_CHANNEL,channel[4],/*id*/id,/*ch*/4);
    PACK_DECL(1089,VME_STRUCK_SIS3316_CHANNEL,channel[5],/*id*/id,/*ch*/5);
    PACK_DECL(1090,VME_STRUCK_SIS3316_CHANNEL,channel[6],/*id*/id,/*ch*/6);
    PACK_DECL(1091,VME_STRUCK_SIS3316_CHANNEL,channel[7],/*id*/id,/*ch*/7);
    PACK_DECL(1092,VME_STRUCK_SIS3316_CHANNEL,channel[8],/*id*/id,/*ch*/8);
    PACK_DECL(1093,VME_STRUCK_SIS3316_CHANNEL,channel[9],/*id*/id,/*ch*/9);
    PACK_DECL(1094,VME_STRUCK_SIS3316_CHANNEL,channel[10],/*id*/id,/*ch*/10);
    PACK_DECL(1095,VME_STRUCK_SIS3316_CHANNEL,channel[11],/*id*/id,/*ch*/11);
    PACK_DECL(1096,VME_STRUCK_SIS3316_CHANNEL,channel[12],/*id*/id,/*ch*/12);
    PACK_DECL(1097,VME_STRUCK_SIS3316_CHANNEL,channel[13],/*id*/id,/*ch*/13);
    PACK_DECL(1098,VME_STRUCK_SIS3316_CHANNEL,channel[14],/*id*/id,/*ch*/14);
    PACK_DECL(1099,VME_STRUCK_SIS3316_CHANNEL,channel[15],/*id*/id,/*ch*/15);
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_STRUCK_SIS3316::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(793,uint32 ,hi,hi.u32);
  {
    time_hi.value = hi.time;
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(797,uint32 ,lo,lo.u32);
  {
    time_lo.value = lo.time;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(793,uint32 ,hi,hi.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SCALERS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SCALERS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SCALERS)
#if !PACKER_CODE
# define DECLARED_UNPACK_SCALERS
class SCALERS
#else//PACKER_CODE
# define DECLARED_PACKER_SCALERS
class PACKER_SCALERS
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // trlo = TRLO_TRIG_SCALER(id=18);
    // caen_scaler = VME_CAEN_V830(geom=31);
  SINGLE(TRLO_TRIG_SCALER,trlo);
  SINGLE(VME_CAEN_V830,caen_scaler);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SCALERS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SCALERS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SCALERS)
template<typename __data_src_t>
void SCALERS::__unpack(__data_src_t &__buffer)
{
  // select several

    // trlo = TRLO_TRIG_SCALER(id=18);
    // caen_scaler = VME_CAEN_V830(geom=31);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRLO_TRIG_SCALER trlo: (s32) => (0xffe0c7a0,0x12000000)
    // optimized match 2: VME_CAEN_V830 caen_scaler: (s32) => (0xff000000,0xfc000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1292,uint32,__match_peek);
    // differ = ee000000 : 25 26 27 29 30 31
    uint32 __match_index = 0 | /* 25,27 */ ((__match_peek >> 25) & 0x00000007) | /* 29,31 */ ((__match_peek >> 26) & 0x00000038);
    static const sint8 __match_index_array[64] = { 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1290,TRLO_TRIG_SCALER,trlo,/*id*/18);
        break;
      case 2:
        UNPACK_DECL(1291,VME_CAEN_V830,caen_scaler,/*geom*/31);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SCALERS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SCALERS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SCALERS)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SCALERS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SCALERS)
template<typename __data_dest_t>
void PACKER_SCALERS::__packer(__data_dest_t &__buffer)
{
  // select several

    // trlo = TRLO_TRIG_SCALER(id=18);
    // caen_scaler = VME_CAEN_V830(geom=31);
  {
    PACK_DECL(1290,TRLO_TRIG_SCALER,trlo,/*id*/18);
    PACK_DECL(1291,VME_CAEN_V830,caen_scaler,/*geom*/31);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,SCALERS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TS)
#if !PACKER_CODE
# define DECLARED_UNPACK_TS
class TS
#else//PACKER_CODE
# define DECLARED_PACKER_TS
class PACKER_TS
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // trlo = TRLO(id=2,multi_events=29);
  SINGLE(TRLO,trlo);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TS)
template<typename __data_src_t>
void TS::__unpack(__data_src_t &__buffer)
{
  // trlo = TRLO(id=2,multi_events=29);
  UNPACK_DECL(1298,TRLO,trlo,/*id*/2,/*multi_events*/29);
}
FORCE_IMPL_DATA_SRC_FCN(void,TS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TS)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TS.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TS)
template<typename __data_dest_t>
void PACKER_TS::__packer(__data_dest_t &__buffer)
{
  // trlo = TRLO(id=2,multi_events=29);
  PACK_DECL(1298,TRLO,trlo,/*id*/2,/*multi_events*/29);
}
FORCE_IMPL_DATA_SRC_FCN(void,TS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME
class VME
#else//PACKER_CODE
# define DECLARED_PACKER_VME
class PACKER_VME
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // header = LAND_STD_VME();
  // select several

    // sis3316[0] = VME_STRUCK_SIS3316(id=3);
    // sis3316[1] = VME_STRUCK_SIS3316(id=4);
    // sis3316[2] = VME_STRUCK_SIS3316(id=5);
    // multi tdc = CAEN_V775(geom=31,crate=0);
    // mesy_padding = VME_MESY_MADC32_PADDING();
    // multi adc = VME_MESY_MADC32(geom=5);
  MULTI(CAEN_V775,tdc);
  SINGLE(VME_STRUCK_SIS3316,sis3316[3]);
  SINGLE(VME_MESY_MADC32_PADDING,mesy_padding);
  MULTI(VME_MESY_MADC32,adc);
  SINGLE(LAND_STD_VME,header);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME)
template<typename __data_src_t>
void VME::__unpack(__data_src_t &__buffer)
{
  // header = LAND_STD_VME();
  UNPACK_DECL(1303,LAND_STD_VME,header);
  // select several

    // sis3316[0] = VME_STRUCK_SIS3316(id=3);
    // sis3316[1] = VME_STRUCK_SIS3316(id=4);
    // sis3316[2] = VME_STRUCK_SIS3316(id=5);
    // multi tdc = CAEN_V775(geom=31,crate=0);
    // mesy_padding = VME_MESY_MADC32_PADDING();
    // multi adc = VME_MESY_MADC32(geom=5);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_STRUCK_SIS3316 sis3316[0]: (s32) => (0xffff00ff,0x33160003)
    // optimized match 2: VME_STRUCK_SIS3316 sis3316[1]: (s32) => (0xffff00ff,0x33160004)
    // optimized match 3: VME_STRUCK_SIS3316 sis3316[2]: (s32) => (0xffff00ff,0x33160005)
    // optimized match 4: CAEN_V775 tdc: (s32) => (0xffffc000,0xfa000000)
    // optimized match 5: VME_MESY_MADC32_PADDING mesy_padding: (s32) => (0xffffffff,0x32323232)
    // optimized match 6: VME_MESY_MADC32 adc: (s32) => (0xffff0000,0x40050000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1317,uint32,__match_peek);
    // differ = fb373237 : 0 1 2 4 5 9 12 13 16 17 18 20 21 24 25 27 28 29 30 31
    // select on bit 24, partition: 1:3(d3) 0:3(d3)
    if (__match_peek & 0x01000000) {
      MATCH_DECL_QUICK(1306,__match_no,1,sis3316[0],__match_peek,0xffff00ff,0x33160003);
      MATCH_DECL_QUICK(1307,__match_no,2,sis3316[1],__match_peek,0xffff00ff,0x33160004);
      MATCH_DECL_QUICK(1308,__match_no,3,sis3316[2],__match_peek,0xffff00ff,0x33160005);
    } else {
      MATCH_DECL_QUICK(1309,__match_no,4,tdc,__match_peek,0xffffc000,0xfa000000);
      MATCH_DECL_QUICK(1310,__match_no,5,mesy_padding,__match_peek,0xffffffff,0x32323232);
      MATCH_DECL_QUICK(1315,__match_no,6,adc,__match_peek,0xffff0000,0x40050000);
    }
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1306,VME_STRUCK_SIS3316,sis3316[0],/*id*/3);
        break;
      case 2:
        UNPACK_DECL(1307,VME_STRUCK_SIS3316,sis3316[1],/*id*/4);
        break;
      case 3:
        UNPACK_DECL(1308,VME_STRUCK_SIS3316,sis3316[2],/*id*/5);
        break;
      case 4:
        UNPACK_DECL(1309,CAEN_V775,multi_tdc.next_free(),/*geom*/31,/*crate*/0);
        break;
      case 5:
        UNPACK_DECL(1310,VME_MESY_MADC32_PADDING,mesy_padding);
        break;
      case 6:
        UNPACK_DECL(1315,VME_MESY_MADC32,multi_adc.next_free(),/*geom*/5);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME)
template<typename __data_dest_t>
void PACKER_VME::__packer(__data_dest_t &__buffer)
{
  // header = LAND_STD_VME();
  PACK_DECL(1303,LAND_STD_VME,header);
  // select several

    // sis3316[0] = VME_STRUCK_SIS3316(id=3);
    // sis3316[1] = VME_STRUCK_SIS3316(id=4);
    // sis3316[2] = VME_STRUCK_SIS3316(id=5);
    // multi tdc = CAEN_V775(geom=31,crate=0);
    // mesy_padding = VME_MESY_MADC32_PADDING();
    // multi adc = VME_MESY_MADC32(geom=5);
  {
    PACK_DECL(1306,VME_STRUCK_SIS3316,sis3316[0],/*id*/3);
    PACK_DECL(1307,VME_STRUCK_SIS3316,sis3316[1],/*id*/4);
    PACK_DECL(1308,VME_STRUCK_SIS3316,sis3316[2],/*id*/5);
    PACK_DECL(1309,CAEN_V775,tdc,/*geom*/31,/*crate*/0);
    PACK_DECL(1310,VME_MESY_MADC32_PADDING,mesy_padding);
    PACK_DECL(1315,VME_MESY_MADC32,adc,/*geom*/5);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // ts = TS(type=10,subtype=1,control=5,subcrate=1);
  // vme = VME(type=88,subtype=0x2260,control=5,subcrate=1);
  // scalers = SCALERS(type=12,subtype=0xd80,control=5,subcrate=1);
  // ignore_unknown_subevent;
SINGLE(TS,ts);
SINGLE(SCALERS,scalers);
SINGLE(VME,vme);
public:
#ifndef __PSDC__
  bitsone<4> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // ts = TS(type=10,subtype=1,control=5,subcrate=1);
  // vme = VME(type=88,subtype=0x2260,control=5,subcrate=1);
  // scalers = SCALERS(type=12,subtype=0xd80,control=5,subcrate=1);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1322,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),ts);
  MATCH_SUBEVENT_DECL(1323,__match_no,2,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),vme);
  MATCH_SUBEVENT_DECL(1324,__match_no,3,((VES10_1_type==12)&&(VES10_1_subtype==0xd80)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),scalers);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1322,TS,ts,0);
      UNPACK_SUBEVENT_DECL(1322,0,TS,ts);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1323,VME,vme,1);
      UNPACK_SUBEVENT_DECL(1323,0,VME,vme);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1324,SCALERS,scalers,2);
      UNPACK_SUBEVENT_DECL(1324,0,SCALERS,scalers);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // ts = TS(type=10,subtype=1,control=5,subcrate=1);
  // vme = VME(type=88,subtype=0x2260,control=5,subcrate=1);
  // scalers = SCALERS(type=12,subtype=0xd80,control=5,subcrate=1);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // ts = TS(type=10,subtype=1,control=5,subcrate=1);
  // vme = VME(type=88,subtype=0x2260,control=5,subcrate=1);
  // scalers = SCALERS(type=12,subtype=0xd80,control=5,subcrate=1);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1322,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),ts);
  MATCH_SUBEVENT_DECL(1323,__match_no,2,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),vme);
  MATCH_SUBEVENT_DECL(1324,__match_no,3,((VES10_1_type==12)&&(VES10_1_subtype==0xd80)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),scalers);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1322,TS,ts,0);
      REVOKE_SUBEVENT_DECL(1322,0,TS,ts);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1323,VME,vme,1);
      REVOKE_SUBEVENT_DECL(1323,0,VME,vme);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1324,SCALERS,scalers,2);
      REVOKE_SUBEVENT_DECL(1324,0,SCALERS,scalers);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "ts", "type=10:subtype=1:control=5:subcrate=1" },
{ "vme", "type=88:subtype=0x2260:control=5:subcrate=1" },
{ "scalers", "type=12:subtype=0xd80:control=5:subcrate=1" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_event_TS
{
public:
  DATA32 HI;
  DATA32 LO;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TS);
#endif//!__PSDC__
} ;

//DUMPY: 16 0
class raw_event_ADC_TS
{
public:
  DATA32 H;
  DATA32 L;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_ADC_TS);
#endif//!__PSDC__
} ;

//DUMPY: 14 0
class raw_event_ADC_CH
{
public:
//DUMPY: 2 0
  DATA32 MAXE[2];
//DUMPY: 3 0
  DATA32 T[3];
//DUMPY: 8 0
  DATA32 GATE[8];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_ADC_CH);
#endif//!__PSDC__
} ;

//DUMPY: 3 0
class raw_event_ADC
{
public:
  DATA8 N;
//DUMPY: 16 0
  raw_event_ADC_TS
  /* {
  public:
    DATA32 H;
    DATA32 L;
  } */ TS[16];
//DUMPY: 14 0
  raw_event_ADC_CH
  /* {
  public:
//DUMPY: 2 0
    DATA32 MAXE[2];
//DUMPY: 3 0
    DATA32 T[3];
//DUMPY: 8 0
    DATA32 GATE[8];
  } */ CH[14];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_ADC);
#endif//!__PSDC__
} ;

//DUMPY: 4 0
class raw_event_LABRL
{
public:
  DATA12 T;
  DATA32 S;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_LABRL);
#endif//!__PSDC__
} ;

//DUMPY: 4 0
class raw_event_LABR
{
public:
  DATA32 S;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_LABR);
#endif//!__PSDC__
} ;

//DUMPY: 4 0
class raw_event_HPGEL
{
public:
  DATA12 T;
  DATA32 S;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_HPGEL);
#endif//!__PSDC__
} ;

//DUMPY: 4 0
class raw_event_HPGE
{
public:
  DATA32 S;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_HPGE);
#endif//!__PSDC__
} ;

//DUMPY: 8 0
class raw_event_N
{
public:
  DATA12 T;
  DATA32 S;
  DATA16 E;
  DATA16 P;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_N);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
  raw_event_TS
  /* {
  public:
    DATA32 HI;
    DATA32 LO;
  } */ TS;
  DATA32 TPAT;
  DATA8 TRIG;
//DUMPY: 16 0
  DATA32 TRLORAW[16];
//DUMPY: 16 0
  DATA32 TRLOBDT[16];
//DUMPY: 16 0
  DATA32 TRLOADT[16];
//DUMPY: 16 0
  DATA32 TRLOARD[16];
//DUMPY: 3 0
  raw_event_ADC
  /* {
  public:
    DATA8 N;
//DUMPY: 16 0
    raw_event_ADC_TS
    {
    public:
      DATA32 H;
      DATA32 L;
    } TS[16];
//DUMPY: 14 0
    raw_event_ADC_CH
    {
    public:
//DUMPY: 2 0
      DATA32 MAXE[2];
//DUMPY: 3 0
      DATA32 T[3];
//DUMPY: 8 0
      DATA32 GATE[8];
    } CH[14];
  } */ ADC[3];
//DUMPY: 12 0
  DATA12 TRIGT[12];
//DUMPY: 4 0
  raw_event_LABRL
  /* {
  public:
    DATA12 T;
    DATA32 S;
  } */ LABRL[4];
//DUMPY: 4 0
  raw_event_LABR
  /* {
  public:
    DATA32 S;
  } */ LABR[4];
//DUMPY: 4 0
  raw_event_HPGEL
  /* {
  public:
    DATA12 T;
    DATA32 S;
  } */ HPGEL[4];
//DUMPY: 4 0
  raw_event_HPGE
  /* {
  public:
    DATA32 S;
  } */ HPGE[4];
//DUMPY: 8 0
  DATA32 CRM[8];
//DUMPY: 8 0
  raw_event_N
  /* {
  public:
    DATA12 T;
    DATA32 S;
    DATA16 E;
    DATA16 P;
  } */ N[8];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA32,ADC1CH13MAXE1,vme.sis3316[0].channel[12].data.maxe[0],ADC[0].CH[12].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC1CH13MAXE2,vme.sis3316[0].channel[12].data.maxe[1],ADC[0].CH[12].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC1CH13T1,vme.sis3316[0].channel[12].data.maw[0],ADC[0].CH[12].T[0]);
SIGNAL_MAPPING(DATA32,ADC1CH13T2,vme.sis3316[0].channel[12].data.maw[1],ADC[0].CH[12].T[1]);
SIGNAL_MAPPING(DATA32,ADC1CH13T3,vme.sis3316[0].channel[12].data.maw[2],ADC[0].CH[12].T[2]);
SIGNAL_MAPPING(DATA32,ADC1CH1MAXE1,vme.sis3316[0].channel[0].data.maxe[0],ADC[0].CH[0].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC1CH1MAXE2,vme.sis3316[0].channel[0].data.maxe[1],ADC[0].CH[0].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC1CH1T1,vme.sis3316[0].channel[0].data.maw[0],ADC[0].CH[0].T[0]);
SIGNAL_MAPPING(DATA32,ADC1CH1T2,vme.sis3316[0].channel[0].data.maw[1],ADC[0].CH[0].T[1]);
SIGNAL_MAPPING(DATA32,ADC1CH1T3,vme.sis3316[0].channel[0].data.maw[2],ADC[0].CH[0].T[2]);
SIGNAL_MAPPING(DATA32,ADC1CH5MAXE1,vme.sis3316[0].channel[4].data.maxe[0],ADC[0].CH[4].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC1CH5MAXE2,vme.sis3316[0].channel[4].data.maxe[1],ADC[0].CH[4].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC1CH5T1,vme.sis3316[0].channel[4].data.maw[0],ADC[0].CH[4].T[0]);
SIGNAL_MAPPING(DATA32,ADC1CH5T2,vme.sis3316[0].channel[4].data.maw[1],ADC[0].CH[4].T[1]);
SIGNAL_MAPPING(DATA32,ADC1CH5T3,vme.sis3316[0].channel[4].data.maw[2],ADC[0].CH[4].T[2]);
SIGNAL_MAPPING(DATA32,ADC1CH9MAXE1,vme.sis3316[0].channel[8].data.maxe[0],ADC[0].CH[8].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC1CH9MAXE2,vme.sis3316[0].channel[8].data.maxe[1],ADC[0].CH[8].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC1CH9T1,vme.sis3316[0].channel[8].data.maw[0],ADC[0].CH[8].T[0]);
SIGNAL_MAPPING(DATA32,ADC1CH9T2,vme.sis3316[0].channel[8].data.maw[1],ADC[0].CH[8].T[1]);
SIGNAL_MAPPING(DATA32,ADC1CH9T3,vme.sis3316[0].channel[8].data.maw[2],ADC[0].CH[8].T[2]);
SIGNAL_MAPPING(DATA32,ADC1TS10H,vme.sis3316[0].channel[9].data.ts[0],ADC[0].TS[9].H);
SIGNAL_MAPPING(DATA32,ADC1TS10L,vme.sis3316[0].channel[9].data.ts[1],ADC[0].TS[9].L);
SIGNAL_MAPPING(DATA32,ADC1TS11H,vme.sis3316[0].channel[10].data.ts[0],ADC[0].TS[10].H);
SIGNAL_MAPPING(DATA32,ADC1TS11L,vme.sis3316[0].channel[10].data.ts[1],ADC[0].TS[10].L);
SIGNAL_MAPPING(DATA32,ADC1TS12H,vme.sis3316[0].channel[11].data.ts[0],ADC[0].TS[11].H);
SIGNAL_MAPPING(DATA32,ADC1TS12L,vme.sis3316[0].channel[11].data.ts[1],ADC[0].TS[11].L);
SIGNAL_MAPPING(DATA32,ADC1TS13H,vme.sis3316[0].channel[12].data.ts[0],ADC[0].TS[12].H);
SIGNAL_MAPPING(DATA32,ADC1TS13L,vme.sis3316[0].channel[12].data.ts[1],ADC[0].TS[12].L);
SIGNAL_MAPPING(DATA32,ADC1TS14H,vme.sis3316[0].channel[13].data.ts[0],ADC[0].TS[13].H);
SIGNAL_MAPPING(DATA32,ADC1TS14L,vme.sis3316[0].channel[13].data.ts[1],ADC[0].TS[13].L);
SIGNAL_MAPPING(DATA32,ADC1TS15H,vme.sis3316[0].channel[14].data.ts[0],ADC[0].TS[14].H);
SIGNAL_MAPPING(DATA32,ADC1TS15L,vme.sis3316[0].channel[14].data.ts[1],ADC[0].TS[14].L);
SIGNAL_MAPPING(DATA32,ADC1TS16H,vme.sis3316[0].channel[15].data.ts[0],ADC[0].TS[15].H);
SIGNAL_MAPPING(DATA32,ADC1TS16L,vme.sis3316[0].channel[15].data.ts[1],ADC[0].TS[15].L);
SIGNAL_MAPPING(DATA32,ADC1TS1H,vme.sis3316[0].channel[0].data.ts[0],ADC[0].TS[0].H);
SIGNAL_MAPPING(DATA32,ADC1TS1L,vme.sis3316[0].channel[0].data.ts[1],ADC[0].TS[0].L);
SIGNAL_MAPPING(DATA32,ADC1TS2H,vme.sis3316[0].channel[1].data.ts[0],ADC[0].TS[1].H);
SIGNAL_MAPPING(DATA32,ADC1TS2L,vme.sis3316[0].channel[1].data.ts[1],ADC[0].TS[1].L);
SIGNAL_MAPPING(DATA32,ADC1TS3H,vme.sis3316[0].channel[2].data.ts[0],ADC[0].TS[2].H);
SIGNAL_MAPPING(DATA32,ADC1TS3L,vme.sis3316[0].channel[2].data.ts[1],ADC[0].TS[2].L);
SIGNAL_MAPPING(DATA32,ADC1TS4H,vme.sis3316[0].channel[3].data.ts[0],ADC[0].TS[3].H);
SIGNAL_MAPPING(DATA32,ADC1TS4L,vme.sis3316[0].channel[3].data.ts[1],ADC[0].TS[3].L);
SIGNAL_MAPPING(DATA32,ADC1TS5H,vme.sis3316[0].channel[4].data.ts[0],ADC[0].TS[4].H);
SIGNAL_MAPPING(DATA32,ADC1TS5L,vme.sis3316[0].channel[4].data.ts[1],ADC[0].TS[4].L);
SIGNAL_MAPPING(DATA32,ADC1TS6H,vme.sis3316[0].channel[5].data.ts[0],ADC[0].TS[5].H);
SIGNAL_MAPPING(DATA32,ADC1TS6L,vme.sis3316[0].channel[5].data.ts[1],ADC[0].TS[5].L);
SIGNAL_MAPPING(DATA32,ADC1TS7H,vme.sis3316[0].channel[6].data.ts[0],ADC[0].TS[6].H);
SIGNAL_MAPPING(DATA32,ADC1TS7L,vme.sis3316[0].channel[6].data.ts[1],ADC[0].TS[6].L);
SIGNAL_MAPPING(DATA32,ADC1TS8H,vme.sis3316[0].channel[7].data.ts[0],ADC[0].TS[7].H);
SIGNAL_MAPPING(DATA32,ADC1TS8L,vme.sis3316[0].channel[7].data.ts[1],ADC[0].TS[7].L);
SIGNAL_MAPPING(DATA32,ADC1TS9H,vme.sis3316[0].channel[8].data.ts[0],ADC[0].TS[8].H);
SIGNAL_MAPPING(DATA32,ADC1TS9L,vme.sis3316[0].channel[8].data.ts[1],ADC[0].TS[8].L);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE1,vme.sis3316[1].channel[9].data.gate[0],ADC[1].CH[9].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE2,vme.sis3316[1].channel[9].data.gate[1],ADC[1].CH[9].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE3,vme.sis3316[1].channel[9].data.gate[2],ADC[1].CH[9].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE4,vme.sis3316[1].channel[9].data.gate[3],ADC[1].CH[9].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE5,vme.sis3316[1].channel[9].data.gate[4],ADC[1].CH[9].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE6,vme.sis3316[1].channel[9].data.gate[5],ADC[1].CH[9].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE7,vme.sis3316[1].channel[9].data.gate[6],ADC[1].CH[9].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH10GATE8,vme.sis3316[1].channel[9].data.gate[7],ADC[1].CH[9].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH10MAXE1,vme.sis3316[1].channel[9].data.maxe[0],ADC[1].CH[9].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH10MAXE2,vme.sis3316[1].channel[9].data.maxe[1],ADC[1].CH[9].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH10T1,vme.sis3316[1].channel[9].data.maw[0],ADC[1].CH[9].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH10T2,vme.sis3316[1].channel[9].data.maw[1],ADC[1].CH[9].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH10T3,vme.sis3316[1].channel[9].data.maw[2],ADC[1].CH[9].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE1,vme.sis3316[1].channel[12].data.gate[0],ADC[1].CH[12].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE2,vme.sis3316[1].channel[12].data.gate[1],ADC[1].CH[12].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE3,vme.sis3316[1].channel[12].data.gate[2],ADC[1].CH[12].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE4,vme.sis3316[1].channel[12].data.gate[3],ADC[1].CH[12].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE5,vme.sis3316[1].channel[12].data.gate[4],ADC[1].CH[12].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE6,vme.sis3316[1].channel[12].data.gate[5],ADC[1].CH[12].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE7,vme.sis3316[1].channel[12].data.gate[6],ADC[1].CH[12].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH13GATE8,vme.sis3316[1].channel[12].data.gate[7],ADC[1].CH[12].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH13MAXE1,vme.sis3316[1].channel[12].data.maxe[0],ADC[1].CH[12].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH13MAXE2,vme.sis3316[1].channel[12].data.maxe[1],ADC[1].CH[12].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH13T1,vme.sis3316[1].channel[12].data.maw[0],ADC[1].CH[12].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH13T2,vme.sis3316[1].channel[12].data.maw[1],ADC[1].CH[12].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH13T3,vme.sis3316[1].channel[12].data.maw[2],ADC[1].CH[12].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE1,vme.sis3316[1].channel[13].data.gate[0],ADC[1].CH[13].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE2,vme.sis3316[1].channel[13].data.gate[1],ADC[1].CH[13].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE3,vme.sis3316[1].channel[13].data.gate[2],ADC[1].CH[13].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE4,vme.sis3316[1].channel[13].data.gate[3],ADC[1].CH[13].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE5,vme.sis3316[1].channel[13].data.gate[4],ADC[1].CH[13].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE6,vme.sis3316[1].channel[13].data.gate[5],ADC[1].CH[13].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE7,vme.sis3316[1].channel[13].data.gate[6],ADC[1].CH[13].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH14GATE8,vme.sis3316[1].channel[13].data.gate[7],ADC[1].CH[13].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH14MAXE1,vme.sis3316[1].channel[13].data.maxe[0],ADC[1].CH[13].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH14MAXE2,vme.sis3316[1].channel[13].data.maxe[1],ADC[1].CH[13].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH14T1,vme.sis3316[1].channel[13].data.maw[0],ADC[1].CH[13].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH14T2,vme.sis3316[1].channel[13].data.maw[1],ADC[1].CH[13].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH14T3,vme.sis3316[1].channel[13].data.maw[2],ADC[1].CH[13].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE1,vme.sis3316[1].channel[0].data.gate[0],ADC[1].CH[0].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE2,vme.sis3316[1].channel[0].data.gate[1],ADC[1].CH[0].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE3,vme.sis3316[1].channel[0].data.gate[2],ADC[1].CH[0].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE4,vme.sis3316[1].channel[0].data.gate[3],ADC[1].CH[0].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE5,vme.sis3316[1].channel[0].data.gate[4],ADC[1].CH[0].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE6,vme.sis3316[1].channel[0].data.gate[5],ADC[1].CH[0].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE7,vme.sis3316[1].channel[0].data.gate[6],ADC[1].CH[0].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH1GATE8,vme.sis3316[1].channel[0].data.gate[7],ADC[1].CH[0].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH1MAXE1,vme.sis3316[1].channel[0].data.maxe[0],ADC[1].CH[0].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH1MAXE2,vme.sis3316[1].channel[0].data.maxe[1],ADC[1].CH[0].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH1T1,vme.sis3316[1].channel[0].data.maw[0],ADC[1].CH[0].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH1T2,vme.sis3316[1].channel[0].data.maw[1],ADC[1].CH[0].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH1T3,vme.sis3316[1].channel[0].data.maw[2],ADC[1].CH[0].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE1,vme.sis3316[1].channel[1].data.gate[0],ADC[1].CH[1].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE2,vme.sis3316[1].channel[1].data.gate[1],ADC[1].CH[1].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE3,vme.sis3316[1].channel[1].data.gate[2],ADC[1].CH[1].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE4,vme.sis3316[1].channel[1].data.gate[3],ADC[1].CH[1].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE5,vme.sis3316[1].channel[1].data.gate[4],ADC[1].CH[1].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE6,vme.sis3316[1].channel[1].data.gate[5],ADC[1].CH[1].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE7,vme.sis3316[1].channel[1].data.gate[6],ADC[1].CH[1].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH2GATE8,vme.sis3316[1].channel[1].data.gate[7],ADC[1].CH[1].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH2MAXE1,vme.sis3316[1].channel[1].data.maxe[0],ADC[1].CH[1].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH2MAXE2,vme.sis3316[1].channel[1].data.maxe[1],ADC[1].CH[1].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH2T1,vme.sis3316[1].channel[1].data.maw[0],ADC[1].CH[1].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH2T2,vme.sis3316[1].channel[1].data.maw[1],ADC[1].CH[1].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH2T3,vme.sis3316[1].channel[1].data.maw[2],ADC[1].CH[1].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE1,vme.sis3316[1].channel[4].data.gate[0],ADC[1].CH[4].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE2,vme.sis3316[1].channel[4].data.gate[1],ADC[1].CH[4].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE3,vme.sis3316[1].channel[4].data.gate[2],ADC[1].CH[4].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE4,vme.sis3316[1].channel[4].data.gate[3],ADC[1].CH[4].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE5,vme.sis3316[1].channel[4].data.gate[4],ADC[1].CH[4].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE6,vme.sis3316[1].channel[4].data.gate[5],ADC[1].CH[4].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE7,vme.sis3316[1].channel[4].data.gate[6],ADC[1].CH[4].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH5GATE8,vme.sis3316[1].channel[4].data.gate[7],ADC[1].CH[4].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH5MAXE1,vme.sis3316[1].channel[4].data.maxe[0],ADC[1].CH[4].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH5MAXE2,vme.sis3316[1].channel[4].data.maxe[1],ADC[1].CH[4].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH5T1,vme.sis3316[1].channel[4].data.maw[0],ADC[1].CH[4].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH5T2,vme.sis3316[1].channel[4].data.maw[1],ADC[1].CH[4].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH5T3,vme.sis3316[1].channel[4].data.maw[2],ADC[1].CH[4].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE1,vme.sis3316[1].channel[5].data.gate[0],ADC[1].CH[5].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE2,vme.sis3316[1].channel[5].data.gate[1],ADC[1].CH[5].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE3,vme.sis3316[1].channel[5].data.gate[2],ADC[1].CH[5].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE4,vme.sis3316[1].channel[5].data.gate[3],ADC[1].CH[5].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE5,vme.sis3316[1].channel[5].data.gate[4],ADC[1].CH[5].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE6,vme.sis3316[1].channel[5].data.gate[5],ADC[1].CH[5].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE7,vme.sis3316[1].channel[5].data.gate[6],ADC[1].CH[5].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH6GATE8,vme.sis3316[1].channel[5].data.gate[7],ADC[1].CH[5].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH6MAXE1,vme.sis3316[1].channel[5].data.maxe[0],ADC[1].CH[5].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH6MAXE2,vme.sis3316[1].channel[5].data.maxe[1],ADC[1].CH[5].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH6T1,vme.sis3316[1].channel[5].data.maw[0],ADC[1].CH[5].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH6T2,vme.sis3316[1].channel[5].data.maw[1],ADC[1].CH[5].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH6T3,vme.sis3316[1].channel[5].data.maw[2],ADC[1].CH[5].T[2]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE1,vme.sis3316[1].channel[8].data.gate[0],ADC[1].CH[8].GATE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE2,vme.sis3316[1].channel[8].data.gate[1],ADC[1].CH[8].GATE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE3,vme.sis3316[1].channel[8].data.gate[2],ADC[1].CH[8].GATE[2]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE4,vme.sis3316[1].channel[8].data.gate[3],ADC[1].CH[8].GATE[3]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE5,vme.sis3316[1].channel[8].data.gate[4],ADC[1].CH[8].GATE[4]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE6,vme.sis3316[1].channel[8].data.gate[5],ADC[1].CH[8].GATE[5]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE7,vme.sis3316[1].channel[8].data.gate[6],ADC[1].CH[8].GATE[6]);
SIGNAL_MAPPING(DATA32,ADC2CH9GATE8,vme.sis3316[1].channel[8].data.gate[7],ADC[1].CH[8].GATE[7]);
SIGNAL_MAPPING(DATA32,ADC2CH9MAXE1,vme.sis3316[1].channel[8].data.maxe[0],ADC[1].CH[8].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC2CH9MAXE2,vme.sis3316[1].channel[8].data.maxe[1],ADC[1].CH[8].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC2CH9T1,vme.sis3316[1].channel[8].data.maw[0],ADC[1].CH[8].T[0]);
SIGNAL_MAPPING(DATA32,ADC2CH9T2,vme.sis3316[1].channel[8].data.maw[1],ADC[1].CH[8].T[1]);
SIGNAL_MAPPING(DATA32,ADC2CH9T3,vme.sis3316[1].channel[8].data.maw[2],ADC[1].CH[8].T[2]);
SIGNAL_MAPPING(DATA32,ADC2TS10H,vme.sis3316[1].channel[9].data.ts[0],ADC[1].TS[9].H);
SIGNAL_MAPPING(DATA32,ADC2TS10L,vme.sis3316[1].channel[9].data.ts[1],ADC[1].TS[9].L);
SIGNAL_MAPPING(DATA32,ADC2TS11H,vme.sis3316[1].channel[10].data.ts[0],ADC[1].TS[10].H);
SIGNAL_MAPPING(DATA32,ADC2TS11L,vme.sis3316[1].channel[10].data.ts[1],ADC[1].TS[10].L);
SIGNAL_MAPPING(DATA32,ADC2TS12H,vme.sis3316[1].channel[11].data.ts[0],ADC[1].TS[11].H);
SIGNAL_MAPPING(DATA32,ADC2TS12L,vme.sis3316[1].channel[11].data.ts[1],ADC[1].TS[11].L);
SIGNAL_MAPPING(DATA32,ADC2TS13H,vme.sis3316[1].channel[12].data.ts[0],ADC[1].TS[12].H);
SIGNAL_MAPPING(DATA32,ADC2TS13L,vme.sis3316[1].channel[12].data.ts[1],ADC[1].TS[12].L);
SIGNAL_MAPPING(DATA32,ADC2TS14H,vme.sis3316[1].channel[13].data.ts[0],ADC[1].TS[13].H);
SIGNAL_MAPPING(DATA32,ADC2TS14L,vme.sis3316[1].channel[13].data.ts[1],ADC[1].TS[13].L);
SIGNAL_MAPPING(DATA32,ADC2TS15H,vme.sis3316[1].channel[14].data.ts[0],ADC[1].TS[14].H);
SIGNAL_MAPPING(DATA32,ADC2TS15L,vme.sis3316[1].channel[14].data.ts[1],ADC[1].TS[14].L);
SIGNAL_MAPPING(DATA32,ADC2TS16H,vme.sis3316[1].channel[15].data.ts[0],ADC[1].TS[15].H);
SIGNAL_MAPPING(DATA32,ADC2TS16L,vme.sis3316[1].channel[15].data.ts[1],ADC[1].TS[15].L);
SIGNAL_MAPPING(DATA32,ADC2TS1H,vme.sis3316[1].channel[0].data.ts[0],ADC[1].TS[0].H);
SIGNAL_MAPPING(DATA32,ADC2TS1L,vme.sis3316[1].channel[0].data.ts[1],ADC[1].TS[0].L);
SIGNAL_MAPPING(DATA32,ADC2TS2H,vme.sis3316[1].channel[1].data.ts[0],ADC[1].TS[1].H);
SIGNAL_MAPPING(DATA32,ADC2TS2L,vme.sis3316[1].channel[1].data.ts[1],ADC[1].TS[1].L);
SIGNAL_MAPPING(DATA32,ADC2TS3H,vme.sis3316[1].channel[2].data.ts[0],ADC[1].TS[2].H);
SIGNAL_MAPPING(DATA32,ADC2TS3L,vme.sis3316[1].channel[2].data.ts[1],ADC[1].TS[2].L);
SIGNAL_MAPPING(DATA32,ADC2TS4H,vme.sis3316[1].channel[3].data.ts[0],ADC[1].TS[3].H);
SIGNAL_MAPPING(DATA32,ADC2TS4L,vme.sis3316[1].channel[3].data.ts[1],ADC[1].TS[3].L);
SIGNAL_MAPPING(DATA32,ADC2TS5H,vme.sis3316[1].channel[4].data.ts[0],ADC[1].TS[4].H);
SIGNAL_MAPPING(DATA32,ADC2TS5L,vme.sis3316[1].channel[4].data.ts[1],ADC[1].TS[4].L);
SIGNAL_MAPPING(DATA32,ADC2TS6H,vme.sis3316[1].channel[5].data.ts[0],ADC[1].TS[5].H);
SIGNAL_MAPPING(DATA32,ADC2TS6L,vme.sis3316[1].channel[5].data.ts[1],ADC[1].TS[5].L);
SIGNAL_MAPPING(DATA32,ADC2TS7H,vme.sis3316[1].channel[6].data.ts[0],ADC[1].TS[6].H);
SIGNAL_MAPPING(DATA32,ADC2TS7L,vme.sis3316[1].channel[6].data.ts[1],ADC[1].TS[6].L);
SIGNAL_MAPPING(DATA32,ADC2TS8H,vme.sis3316[1].channel[7].data.ts[0],ADC[1].TS[7].H);
SIGNAL_MAPPING(DATA32,ADC2TS8L,vme.sis3316[1].channel[7].data.ts[1],ADC[1].TS[7].L);
SIGNAL_MAPPING(DATA32,ADC2TS9H,vme.sis3316[1].channel[8].data.ts[0],ADC[1].TS[8].H);
SIGNAL_MAPPING(DATA32,ADC2TS9L,vme.sis3316[1].channel[8].data.ts[1],ADC[1].TS[8].L);
SIGNAL_MAPPING(DATA32,ADC3CH13MAXE1,vme.sis3316[2].channel[12].data.maxe[0],ADC[2].CH[12].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC3CH13MAXE2,vme.sis3316[2].channel[12].data.maxe[1],ADC[2].CH[12].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC3CH13T1,vme.sis3316[2].channel[12].data.maw[0],ADC[2].CH[12].T[0]);
SIGNAL_MAPPING(DATA32,ADC3CH13T2,vme.sis3316[2].channel[12].data.maw[1],ADC[2].CH[12].T[1]);
SIGNAL_MAPPING(DATA32,ADC3CH13T3,vme.sis3316[2].channel[12].data.maw[2],ADC[2].CH[12].T[2]);
SIGNAL_MAPPING(DATA32,ADC3CH1MAXE1,vme.sis3316[2].channel[0].data.maxe[0],ADC[2].CH[0].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC3CH1MAXE2,vme.sis3316[2].channel[0].data.maxe[1],ADC[2].CH[0].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC3CH1T1,vme.sis3316[2].channel[0].data.maw[0],ADC[2].CH[0].T[0]);
SIGNAL_MAPPING(DATA32,ADC3CH1T2,vme.sis3316[2].channel[0].data.maw[1],ADC[2].CH[0].T[1]);
SIGNAL_MAPPING(DATA32,ADC3CH1T3,vme.sis3316[2].channel[0].data.maw[2],ADC[2].CH[0].T[2]);
SIGNAL_MAPPING(DATA32,ADC3CH5MAXE1,vme.sis3316[2].channel[4].data.maxe[0],ADC[2].CH[4].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC3CH5MAXE2,vme.sis3316[2].channel[4].data.maxe[1],ADC[2].CH[4].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC3CH5T1,vme.sis3316[2].channel[4].data.maw[0],ADC[2].CH[4].T[0]);
SIGNAL_MAPPING(DATA32,ADC3CH5T2,vme.sis3316[2].channel[4].data.maw[1],ADC[2].CH[4].T[1]);
SIGNAL_MAPPING(DATA32,ADC3CH5T3,vme.sis3316[2].channel[4].data.maw[2],ADC[2].CH[4].T[2]);
SIGNAL_MAPPING(DATA32,ADC3CH9MAXE1,vme.sis3316[2].channel[8].data.maxe[0],ADC[2].CH[8].MAXE[0]);
SIGNAL_MAPPING(DATA32,ADC3CH9MAXE2,vme.sis3316[2].channel[8].data.maxe[1],ADC[2].CH[8].MAXE[1]);
SIGNAL_MAPPING(DATA32,ADC3CH9T1,vme.sis3316[2].channel[8].data.maw[0],ADC[2].CH[8].T[0]);
SIGNAL_MAPPING(DATA32,ADC3CH9T2,vme.sis3316[2].channel[8].data.maw[1],ADC[2].CH[8].T[1]);
SIGNAL_MAPPING(DATA32,ADC3CH9T3,vme.sis3316[2].channel[8].data.maw[2],ADC[2].CH[8].T[2]);
SIGNAL_MAPPING(DATA32,ADC3TS10H,vme.sis3316[2].channel[9].data.ts[0],ADC[2].TS[9].H);
SIGNAL_MAPPING(DATA32,ADC3TS10L,vme.sis3316[2].channel[9].data.ts[1],ADC[2].TS[9].L);
SIGNAL_MAPPING(DATA32,ADC3TS11H,vme.sis3316[2].channel[10].data.ts[0],ADC[2].TS[10].H);
SIGNAL_MAPPING(DATA32,ADC3TS11L,vme.sis3316[2].channel[10].data.ts[1],ADC[2].TS[10].L);
SIGNAL_MAPPING(DATA32,ADC3TS12H,vme.sis3316[2].channel[11].data.ts[0],ADC[2].TS[11].H);
SIGNAL_MAPPING(DATA32,ADC3TS12L,vme.sis3316[2].channel[11].data.ts[1],ADC[2].TS[11].L);
SIGNAL_MAPPING(DATA32,ADC3TS13H,vme.sis3316[2].channel[12].data.ts[0],ADC[2].TS[12].H);
SIGNAL_MAPPING(DATA32,ADC3TS13L,vme.sis3316[2].channel[12].data.ts[1],ADC[2].TS[12].L);
SIGNAL_MAPPING(DATA32,ADC3TS14H,vme.sis3316[2].channel[13].data.ts[0],ADC[2].TS[13].H);
SIGNAL_MAPPING(DATA32,ADC3TS14L,vme.sis3316[2].channel[13].data.ts[1],ADC[2].TS[13].L);
SIGNAL_MAPPING(DATA32,ADC3TS15H,vme.sis3316[2].channel[14].data.ts[0],ADC[2].TS[14].H);
SIGNAL_MAPPING(DATA32,ADC3TS15L,vme.sis3316[2].channel[14].data.ts[1],ADC[2].TS[14].L);
SIGNAL_MAPPING(DATA32,ADC3TS16H,vme.sis3316[2].channel[15].data.ts[0],ADC[2].TS[15].H);
SIGNAL_MAPPING(DATA32,ADC3TS16L,vme.sis3316[2].channel[15].data.ts[1],ADC[2].TS[15].L);
SIGNAL_MAPPING(DATA32,ADC3TS1H,vme.sis3316[2].channel[0].data.ts[0],ADC[2].TS[0].H);
SIGNAL_MAPPING(DATA32,ADC3TS1L,vme.sis3316[2].channel[0].data.ts[1],ADC[2].TS[0].L);
SIGNAL_MAPPING(DATA32,ADC3TS2H,vme.sis3316[2].channel[1].data.ts[0],ADC[2].TS[1].H);
SIGNAL_MAPPING(DATA32,ADC3TS2L,vme.sis3316[2].channel[1].data.ts[1],ADC[2].TS[1].L);
SIGNAL_MAPPING(DATA32,ADC3TS3H,vme.sis3316[2].channel[2].data.ts[0],ADC[2].TS[2].H);
SIGNAL_MAPPING(DATA32,ADC3TS3L,vme.sis3316[2].channel[2].data.ts[1],ADC[2].TS[2].L);
SIGNAL_MAPPING(DATA32,ADC3TS4H,vme.sis3316[2].channel[3].data.ts[0],ADC[2].TS[3].H);
SIGNAL_MAPPING(DATA32,ADC3TS4L,vme.sis3316[2].channel[3].data.ts[1],ADC[2].TS[3].L);
SIGNAL_MAPPING(DATA32,ADC3TS5H,vme.sis3316[2].channel[4].data.ts[0],ADC[2].TS[4].H);
SIGNAL_MAPPING(DATA32,ADC3TS5L,vme.sis3316[2].channel[4].data.ts[1],ADC[2].TS[4].L);
SIGNAL_MAPPING(DATA32,ADC3TS6H,vme.sis3316[2].channel[5].data.ts[0],ADC[2].TS[5].H);
SIGNAL_MAPPING(DATA32,ADC3TS6L,vme.sis3316[2].channel[5].data.ts[1],ADC[2].TS[5].L);
SIGNAL_MAPPING(DATA32,ADC3TS7H,vme.sis3316[2].channel[6].data.ts[0],ADC[2].TS[6].H);
SIGNAL_MAPPING(DATA32,ADC3TS7L,vme.sis3316[2].channel[6].data.ts[1],ADC[2].TS[6].L);
SIGNAL_MAPPING(DATA32,ADC3TS8H,vme.sis3316[2].channel[7].data.ts[0],ADC[2].TS[7].H);
SIGNAL_MAPPING(DATA32,ADC3TS8L,vme.sis3316[2].channel[7].data.ts[1],ADC[2].TS[7].L);
SIGNAL_MAPPING(DATA32,ADC3TS9H,vme.sis3316[2].channel[8].data.ts[0],ADC[2].TS[8].H);
SIGNAL_MAPPING(DATA32,ADC3TS9L,vme.sis3316[2].channel[8].data.ts[1],ADC[2].TS[8].L);
SIGNAL_MAPPING(DATA8,ADC_1_N,vme.sis3316[0].n_ch,ADC[0].N);
SIGNAL_MAPPING(DATA8,ADC_2_N,vme.sis3316[1].n_ch,ADC[1].N);
SIGNAL_MAPPING(DATA8,ADC_3_N,vme.sis3316[2].n_ch,ADC[2].N);
SIGNAL_MAPPING(DATA32,CRM_1,scalers.caen_scaler.data[16],CRM[0]);
SIGNAL_MAPPING(DATA32,CRM_2,scalers.caen_scaler.data[17],CRM[1]);
SIGNAL_MAPPING(DATA32,CRM_3,scalers.caen_scaler.data[18],CRM[2]);
SIGNAL_MAPPING(DATA32,CRM_4,scalers.caen_scaler.data[19],CRM[3]);
SIGNAL_MAPPING(DATA32,CRM_5,scalers.caen_scaler.data[20],CRM[4]);
SIGNAL_MAPPING(DATA32,CRM_6,scalers.caen_scaler.data[21],CRM[5]);
SIGNAL_MAPPING(DATA32,CRM_7,scalers.caen_scaler.data[22],CRM[6]);
SIGNAL_MAPPING(DATA32,CRM_8,scalers.caen_scaler.data[23],CRM[7]);
SIGNAL_MAPPING(DATA32,HPGEL_1S,scalers.caen_scaler.data[8],HPGEL[0].S);
SIGNAL_MAPPING(DATA12,HPGEL_1T,vme.tdc.data[4],HPGEL[0].T);
SIGNAL_MAPPING(DATA32,HPGEL_2S,scalers.caen_scaler.data[9],HPGEL[1].S);
SIGNAL_MAPPING(DATA12,HPGEL_2T,vme.tdc.data[5],HPGEL[1].T);
SIGNAL_MAPPING(DATA32,HPGEL_3S,scalers.caen_scaler.data[10],HPGEL[2].S);
SIGNAL_MAPPING(DATA12,HPGEL_3T,vme.tdc.data[6],HPGEL[2].T);
SIGNAL_MAPPING(DATA32,HPGEL_4S,scalers.caen_scaler.data[11],HPGEL[3].S);
SIGNAL_MAPPING(DATA12,HPGEL_4T,vme.tdc.data[7],HPGEL[3].T);
SIGNAL_MAPPING(DATA32,HPGE_1S,scalers.caen_scaler.data[12],HPGE[0].S);
SIGNAL_MAPPING(DATA32,HPGE_2S,scalers.caen_scaler.data[13],HPGE[1].S);
SIGNAL_MAPPING(DATA32,HPGE_3S,scalers.caen_scaler.data[14],HPGE[2].S);
SIGNAL_MAPPING(DATA32,HPGE_4S,scalers.caen_scaler.data[15],HPGE[3].S);
SIGNAL_MAPPING(DATA32,LABRL_1S,scalers.caen_scaler.data[0],LABRL[0].S);
SIGNAL_MAPPING(DATA12,LABRL_1T,vme.tdc.data[0],LABRL[0].T);
SIGNAL_MAPPING(DATA32,LABRL_2S,scalers.caen_scaler.data[1],LABRL[1].S);
SIGNAL_MAPPING(DATA12,LABRL_2T,vme.tdc.data[1],LABRL[1].T);
SIGNAL_MAPPING(DATA32,LABRL_3S,scalers.caen_scaler.data[2],LABRL[2].S);
SIGNAL_MAPPING(DATA12,LABRL_3T,vme.tdc.data[2],LABRL[2].T);
SIGNAL_MAPPING(DATA32,LABRL_4S,scalers.caen_scaler.data[3],LABRL[3].S);
SIGNAL_MAPPING(DATA12,LABRL_4T,vme.tdc.data[3],LABRL[3].T);
SIGNAL_MAPPING(DATA32,LABR_1S,scalers.caen_scaler.data[4],LABR[0].S);
SIGNAL_MAPPING(DATA32,LABR_2S,scalers.caen_scaler.data[5],LABR[1].S);
SIGNAL_MAPPING(DATA32,LABR_3S,scalers.caen_scaler.data[6],LABR[2].S);
SIGNAL_MAPPING(DATA32,LABR_4S,scalers.caen_scaler.data[7],LABR[3].S);
SIGNAL_MAPPING(DATA16,N_1E,vme.adc.data[0],N[0].E);
SIGNAL_MAPPING(DATA16,N_1P,vme.adc.data[1],N[0].P);
SIGNAL_MAPPING(DATA32,N_1S,scalers.caen_scaler.data[24],N[0].S);
SIGNAL_MAPPING(DATA12,N_1T,vme.tdc.data[8],N[0].T);
SIGNAL_MAPPING(DATA16,N_2E,vme.adc.data[2],N[1].E);
SIGNAL_MAPPING(DATA16,N_2P,vme.adc.data[3],N[1].P);
SIGNAL_MAPPING(DATA32,N_2S,scalers.caen_scaler.data[25],N[1].S);
SIGNAL_MAPPING(DATA12,N_2T,vme.tdc.data[9],N[1].T);
SIGNAL_MAPPING(DATA16,N_3E,vme.adc.data[4],N[2].E);
SIGNAL_MAPPING(DATA16,N_3P,vme.adc.data[5],N[2].P);
SIGNAL_MAPPING(DATA32,N_3S,scalers.caen_scaler.data[26],N[2].S);
SIGNAL_MAPPING(DATA12,N_3T,vme.tdc.data[10],N[2].T);
SIGNAL_MAPPING(DATA16,N_4E,vme.adc.data[6],N[3].E);
SIGNAL_MAPPING(DATA16,N_4P,vme.adc.data[7],N[3].P);
SIGNAL_MAPPING(DATA32,N_4S,scalers.caen_scaler.data[27],N[3].S);
SIGNAL_MAPPING(DATA12,N_4T,vme.tdc.data[11],N[3].T);
SIGNAL_MAPPING(DATA16,N_5E,vme.adc.data[16],N[4].E);
SIGNAL_MAPPING(DATA16,N_5P,vme.adc.data[17],N[4].P);
SIGNAL_MAPPING(DATA32,N_5S,scalers.caen_scaler.data[28],N[4].S);
SIGNAL_MAPPING(DATA12,N_5T,vme.tdc.data[12],N[4].T);
SIGNAL_MAPPING(DATA16,N_6E,vme.adc.data[18],N[5].E);
SIGNAL_MAPPING(DATA16,N_6P,vme.adc.data[19],N[5].P);
SIGNAL_MAPPING(DATA32,N_6S,scalers.caen_scaler.data[29],N[5].S);
SIGNAL_MAPPING(DATA12,N_6T,vme.tdc.data[13],N[5].T);
SIGNAL_MAPPING(DATA16,N_7E,vme.adc.data[20],N[6].E);
SIGNAL_MAPPING(DATA16,N_7P,vme.adc.data[21],N[6].P);
SIGNAL_MAPPING(DATA32,N_7S,scalers.caen_scaler.data[30],N[6].S);
SIGNAL_MAPPING(DATA12,N_7T,vme.tdc.data[14],N[6].T);
SIGNAL_MAPPING(DATA16,N_8E,vme.adc.data[22],N[7].E);
SIGNAL_MAPPING(DATA16,N_8P,vme.adc.data[23],N[7].P);
SIGNAL_MAPPING(DATA32,N_8S,scalers.caen_scaler.data[31],N[7].S);
SIGNAL_MAPPING(DATA12,N_8T,vme.tdc.data[15],N[7].T);
SIGNAL_MAPPING(DATA32,TPAT,ts.trlo.trigbuf.entry.tpat,TPAT);
SIGNAL_MAPPING(DATA8,TRIG,ts.trlo.trigbuf.entry.trig,TRIG);
SIGNAL_MAPPING(DATA12,TRIGT_1,vme.tdc.data[16],TRIGT[0]);
SIGNAL_MAPPING(DATA12,TRIGT_10,vme.tdc.data[25],TRIGT[9]);
SIGNAL_MAPPING(DATA12,TRIGT_11,vme.tdc.data[26],TRIGT[10]);
SIGNAL_MAPPING(DATA12,TRIGT_12,vme.tdc.data[27],TRIGT[11]);
SIGNAL_MAPPING(DATA12,TRIGT_2,vme.tdc.data[17],TRIGT[1]);
SIGNAL_MAPPING(DATA12,TRIGT_3,vme.tdc.data[18],TRIGT[2]);
SIGNAL_MAPPING(DATA12,TRIGT_4,vme.tdc.data[19],TRIGT[3]);
SIGNAL_MAPPING(DATA12,TRIGT_5,vme.tdc.data[20],TRIGT[4]);
SIGNAL_MAPPING(DATA12,TRIGT_6,vme.tdc.data[21],TRIGT[5]);
SIGNAL_MAPPING(DATA12,TRIGT_7,vme.tdc.data[22],TRIGT[6]);
SIGNAL_MAPPING(DATA12,TRIGT_8,vme.tdc.data[23],TRIGT[7]);
SIGNAL_MAPPING(DATA12,TRIGT_9,vme.tdc.data[24],TRIGT[8]);
SIGNAL_MAPPING(DATA32,TRLOADT1,scalers.trlo.after_deadtime[0],TRLOADT[0]);
SIGNAL_MAPPING(DATA32,TRLOADT10,scalers.trlo.after_deadtime[9],TRLOADT[9]);
SIGNAL_MAPPING(DATA32,TRLOADT11,scalers.trlo.after_deadtime[10],TRLOADT[10]);
SIGNAL_MAPPING(DATA32,TRLOADT12,scalers.trlo.after_deadtime[11],TRLOADT[11]);
SIGNAL_MAPPING(DATA32,TRLOADT13,scalers.trlo.after_deadtime[12],TRLOADT[12]);
SIGNAL_MAPPING(DATA32,TRLOADT14,scalers.trlo.after_deadtime[13],TRLOADT[13]);
SIGNAL_MAPPING(DATA32,TRLOADT15,scalers.trlo.after_deadtime[14],TRLOADT[14]);
SIGNAL_MAPPING(DATA32,TRLOADT16,scalers.trlo.after_deadtime[15],TRLOADT[15]);
SIGNAL_MAPPING(DATA32,TRLOADT2,scalers.trlo.after_deadtime[1],TRLOADT[1]);
SIGNAL_MAPPING(DATA32,TRLOADT3,scalers.trlo.after_deadtime[2],TRLOADT[2]);
SIGNAL_MAPPING(DATA32,TRLOADT4,scalers.trlo.after_deadtime[3],TRLOADT[3]);
SIGNAL_MAPPING(DATA32,TRLOADT5,scalers.trlo.after_deadtime[4],TRLOADT[4]);
SIGNAL_MAPPING(DATA32,TRLOADT6,scalers.trlo.after_deadtime[5],TRLOADT[5]);
SIGNAL_MAPPING(DATA32,TRLOADT7,scalers.trlo.after_deadtime[6],TRLOADT[6]);
SIGNAL_MAPPING(DATA32,TRLOADT8,scalers.trlo.after_deadtime[7],TRLOADT[7]);
SIGNAL_MAPPING(DATA32,TRLOADT9,scalers.trlo.after_deadtime[8],TRLOADT[8]);
SIGNAL_MAPPING(DATA32,TRLOARD1,scalers.trlo.after_reduction[0],TRLOARD[0]);
SIGNAL_MAPPING(DATA32,TRLOARD10,scalers.trlo.after_reduction[9],TRLOARD[9]);
SIGNAL_MAPPING(DATA32,TRLOARD11,scalers.trlo.after_reduction[10],TRLOARD[10]);
SIGNAL_MAPPING(DATA32,TRLOARD12,scalers.trlo.after_reduction[11],TRLOARD[11]);
SIGNAL_MAPPING(DATA32,TRLOARD13,scalers.trlo.after_reduction[12],TRLOARD[12]);
SIGNAL_MAPPING(DATA32,TRLOARD14,scalers.trlo.after_reduction[13],TRLOARD[13]);
SIGNAL_MAPPING(DATA32,TRLOARD15,scalers.trlo.after_reduction[14],TRLOARD[14]);
SIGNAL_MAPPING(DATA32,TRLOARD16,scalers.trlo.after_reduction[15],TRLOARD[15]);
SIGNAL_MAPPING(DATA32,TRLOARD2,scalers.trlo.after_reduction[1],TRLOARD[1]);
SIGNAL_MAPPING(DATA32,TRLOARD3,scalers.trlo.after_reduction[2],TRLOARD[2]);
SIGNAL_MAPPING(DATA32,TRLOARD4,scalers.trlo.after_reduction[3],TRLOARD[3]);
SIGNAL_MAPPING(DATA32,TRLOARD5,scalers.trlo.after_reduction[4],TRLOARD[4]);
SIGNAL_MAPPING(DATA32,TRLOARD6,scalers.trlo.after_reduction[5],TRLOARD[5]);
SIGNAL_MAPPING(DATA32,TRLOARD7,scalers.trlo.after_reduction[6],TRLOARD[6]);
SIGNAL_MAPPING(DATA32,TRLOARD8,scalers.trlo.after_reduction[7],TRLOARD[7]);
SIGNAL_MAPPING(DATA32,TRLOARD9,scalers.trlo.after_reduction[8],TRLOARD[8]);
SIGNAL_MAPPING(DATA32,TRLOBDT1,scalers.trlo.before_deadtime[0],TRLOBDT[0]);
SIGNAL_MAPPING(DATA32,TRLOBDT10,scalers.trlo.before_deadtime[9],TRLOBDT[9]);
SIGNAL_MAPPING(DATA32,TRLOBDT11,scalers.trlo.before_deadtime[10],TRLOBDT[10]);
SIGNAL_MAPPING(DATA32,TRLOBDT12,scalers.trlo.before_deadtime[11],TRLOBDT[11]);
SIGNAL_MAPPING(DATA32,TRLOBDT13,scalers.trlo.before_deadtime[12],TRLOBDT[12]);
SIGNAL_MAPPING(DATA32,TRLOBDT14,scalers.trlo.before_deadtime[13],TRLOBDT[13]);
SIGNAL_MAPPING(DATA32,TRLOBDT15,scalers.trlo.before_deadtime[14],TRLOBDT[14]);
SIGNAL_MAPPING(DATA32,TRLOBDT16,scalers.trlo.before_deadtime[15],TRLOBDT[15]);
SIGNAL_MAPPING(DATA32,TRLOBDT2,scalers.trlo.before_deadtime[1],TRLOBDT[1]);
SIGNAL_MAPPING(DATA32,TRLOBDT3,scalers.trlo.before_deadtime[2],TRLOBDT[2]);
SIGNAL_MAPPING(DATA32,TRLOBDT4,scalers.trlo.before_deadtime[3],TRLOBDT[3]);
SIGNAL_MAPPING(DATA32,TRLOBDT5,scalers.trlo.before_deadtime[4],TRLOBDT[4]);
SIGNAL_MAPPING(DATA32,TRLOBDT6,scalers.trlo.before_deadtime[5],TRLOBDT[5]);
SIGNAL_MAPPING(DATA32,TRLOBDT7,scalers.trlo.before_deadtime[6],TRLOBDT[6]);
SIGNAL_MAPPING(DATA32,TRLOBDT8,scalers.trlo.before_deadtime[7],TRLOBDT[7]);
SIGNAL_MAPPING(DATA32,TRLOBDT9,scalers.trlo.before_deadtime[8],TRLOBDT[8]);
SIGNAL_MAPPING(DATA32,TRLORAW1,scalers.trlo.before_lmu[0],TRLORAW[0]);
SIGNAL_MAPPING(DATA32,TRLORAW10,scalers.trlo.before_lmu[9],TRLORAW[9]);
SIGNAL_MAPPING(DATA32,TRLORAW11,scalers.trlo.before_lmu[10],TRLORAW[10]);
SIGNAL_MAPPING(DATA32,TRLORAW12,scalers.trlo.before_lmu[11],TRLORAW[11]);
SIGNAL_MAPPING(DATA32,TRLORAW13,scalers.trlo.before_lmu[12],TRLORAW[12]);
SIGNAL_MAPPING(DATA32,TRLORAW14,scalers.trlo.before_lmu[13],TRLORAW[13]);
SIGNAL_MAPPING(DATA32,TRLORAW15,scalers.trlo.before_lmu[14],TRLORAW[14]);
SIGNAL_MAPPING(DATA32,TRLORAW16,scalers.trlo.before_lmu[15],TRLORAW[15]);
SIGNAL_MAPPING(DATA32,TRLORAW2,scalers.trlo.before_lmu[1],TRLORAW[1]);
SIGNAL_MAPPING(DATA32,TRLORAW3,scalers.trlo.before_lmu[2],TRLORAW[2]);
SIGNAL_MAPPING(DATA32,TRLORAW4,scalers.trlo.before_lmu[3],TRLORAW[3]);
SIGNAL_MAPPING(DATA32,TRLORAW5,scalers.trlo.before_lmu[4],TRLORAW[4]);
SIGNAL_MAPPING(DATA32,TRLORAW6,scalers.trlo.before_lmu[5],TRLORAW[5]);
SIGNAL_MAPPING(DATA32,TRLORAW7,scalers.trlo.before_lmu[6],TRLORAW[6]);
SIGNAL_MAPPING(DATA32,TRLORAW8,scalers.trlo.before_lmu[7],TRLORAW[7]);
SIGNAL_MAPPING(DATA32,TRLORAW9,scalers.trlo.before_lmu[8],TRLORAW[8]);
SIGNAL_MAPPING(DATA32,TS_HI,ts.trlo.trigbuf.entry.ts_hi,TS.HI);
SIGNAL_MAPPING(DATA32,TS_LO,ts.trlo.trigbuf.entry.ts_lo,TS.LO);

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gamma3_2.spec" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gamma3_2.spec" },
  { 8, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 9, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 10, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_lecroy_4434.spec" },
  { 11, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_lecroy_4434.spec" },
  { 27, 24, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 28, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_silena_4418.spec" },
  { 29, 28, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_silena_4418.spec" },
  { 56, 25, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 57, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_phillips_7164.spec" },
  { 58, 26, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_phillips_7164.spec" },
  { 83, 26, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 85, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/fastbus.spec" },
  { 86, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/fastbus.spec" },
  { 121, 28, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 123, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v775.spec" },
  { 124, 26, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v775.spec" },
  { 168, 30, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 169, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v830.spec" },
  { 170, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v830.spec" },
  { 199, 31, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 200, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 201, 27, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 202, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 203, 39, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 401, 28, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 407, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 408, 39, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 606, 34, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 607, 32, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 609, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_madc32.spec" },
  { 610, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_madc32.spec" },
  { 652, 34, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 653, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_mdpp16.spec" },
  { 654, 35, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_mdpp16.spec" },
  { 696, 35, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 697, 2, "gamma3_2.spec" },
  { 698, 1, "vme_mesy_madc32.spec" },
  { 743, 3, "gamma3_2.spec" },
  { 744, 1, "trlo.spec" },
  { 748, 1, "../land_common/whiterabbit.spec" },
  { 800, 5, "trlo.spec" },
  { 874, 4, "gamma3_2.spec" },
  { 875, 1, "trlo_data.spec" },
  { 895, 34, "trlo_data.spec" },
  { 985, 5, "gamma3_2.spec" },
  { 986, 1, "caen_scaler_data.spec" },
  { 1016, 6, "gamma3_2.spec" },
  { 1017, 1, "caen_v775.spec" },
  { 1065, 7, "gamma3_2.spec" },
  { 1066, 1, "vme_struck_sis3316.spec" },
  { 1242, 191, "vme_struck_sis3316.spec" },
  { 1244, 8, "gamma3_2.spec" },
  { 1329, 1, "mapping.h" },
  { 1347, 73, "mapping.h" },
  { 1353, 97, "mapping.h" },
  { 1378, 140, "mapping.h" },
  { 1403, 183, "mapping.h" },
  { 1417, 204, "mapping.h" },
  { 1525, 92, "gamma3_2.spec" },
};

/** END_LOCATIONS *****************************************************/

