
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

FZD_Modul(geom)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  UINT32 header
  {
     0_23: 0;
    24_28: geom = MATCH(geom);
       29: 1;
       30: 0;
       31: 0;
  }
  select several
  {
    dummy = FZD_data_SUBITEM(geo=geom,data=data);
  }
  UINT32 EOB
  {
     0_23: 0;
    24_28: geom = MATCH(geom);
       29: 0;
       30: 1;
       31: 0;
  }
}

FZD_V1495(geom)
{
  MEMBER(DATA32 ts[8] ZERO_SUPPRESS);
  MEMBER(DATA32 RBWL[2] ZERO_SUPPRESS);
  MEMBER(DATA32 MP);
  UINT32 header
  {
     0_23: 0;
    24_28: geom = MATCH(geom);
       29: 1;
       30: 0;
       31: 0;
  }
  list(0<=index<5)
  {
    UINT32 ch_data NOENCODE
    {
       0_23: timestamp;
      24_28: channel = RANGE(0,4);
         29: 0;
         30: 0;
         31: 0;
      ENCODE(ts[channel],(value=timestamp));
    }
  }
  UINT32 ch_data NOENCODE
  {
     0_07: timestamp;
        8: dummy = RANGE(0,1);
        9: MPF = RANGE(0,1);
       10: RBWF = RANGE(0,1);
    11_23: 0;
    24_28: channel = RANGE(5,5);
       29: 0;
       30: 0;
       31: 0;
    ENCODE(MP,(value=MPF));
    ENCODE(ts[channel],(value=timestamp));
  }
  list(0<=index<2)
  {
    UINT32 ch_data NOENCODE
    {
       0_23: timestamp;
      24_28: channel = RANGE(6,7);
         29: 0;
         30: 0;
         31: 0;
      ENCODE(ts[channel],(value=timestamp));
    }
  }
  list(0<=index<2)
  {
    UINT32 ch_data NOENCODE
    {
       0_23: length;
      24_28: channel = RANGE(8,9);
         29: 0;
         30: 0;
         31: 0;
      ENCODE(RBWL[(channel - 8)],(value=length));
    }
  }
  UINT32 EOB
  {
     0_23: 0;
    24_28: geom = MATCH(geom);
       29: 0;
       30: 1;
       31: 0;
  }
}

FZD_data_SUBITEM(geo,data)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  UINT32 ch_data NOENCODE
  {
     0_23: data;
    24_28: channel = RANGE(0,32);
       29: 0;
       30: 0;
       31: 0;
    ENCODE(data[channel],(value=data));
  }
}

SUBEVENT(CRATE)
{
  select several
  {
    timestamp = FZD_V1495(geom=21);
    QDC1 = FZD_Modul(geom=7);
    QDC2 = FZD_Modul(geom=8);
    TDC1 = FZD_Modul(geom=5);
    Sca1 = FZD_Modul(geom=13);
    Sca2 = FZD_Modul(geom=14);
    Sca3 = FZD_Modul(geom=15);
    Sca4 = FZD_Modul(geom=16);
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  vme0 = CRATE(type=10,subtype=1);
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(U_MPflag,vme0.timestamp.MP,DATA32);
SIGNAL(U_QDC1CH1,vme0.QDC1.data[0],DATA32);
SIGNAL(U_QDC1CH10,vme0.QDC1.data[9],DATA32);
SIGNAL(U_QDC1CH11,vme0.QDC1.data[10],DATA32);
SIGNAL(U_QDC1CH12,vme0.QDC1.data[11],DATA32);
SIGNAL(U_QDC1CH13,vme0.QDC1.data[12],DATA32);
SIGNAL(U_QDC1CH14,vme0.QDC1.data[13],DATA32);
SIGNAL(U_QDC1CH15,vme0.QDC1.data[14],DATA32);
SIGNAL(U_QDC1CH16,vme0.QDC1.data[15],DATA32);
SIGNAL(U_QDC1CH2,vme0.QDC1.data[1],DATA32);
SIGNAL(U_QDC1CH3,vme0.QDC1.data[2],DATA32);
SIGNAL(U_QDC1CH4,vme0.QDC1.data[3],DATA32);
SIGNAL(U_QDC1CH5,vme0.QDC1.data[4],DATA32);
SIGNAL(U_QDC1CH6,vme0.QDC1.data[5],DATA32);
SIGNAL(U_QDC1CH7,vme0.QDC1.data[6],DATA32);
SIGNAL(U_QDC1CH8,vme0.QDC1.data[7],DATA32);
SIGNAL(U_QDC1CH9,vme0.QDC1.data[8],DATA32);
SIGNAL(U_QDC2CH1,vme0.QDC2.data[0],DATA32);
SIGNAL(U_QDC2CH10,vme0.QDC2.data[9],DATA32);
SIGNAL(U_QDC2CH11,vme0.QDC2.data[10],DATA32);
SIGNAL(U_QDC2CH12,vme0.QDC2.data[11],DATA32);
SIGNAL(U_QDC2CH13,vme0.QDC2.data[12],DATA32);
SIGNAL(U_QDC2CH14,vme0.QDC2.data[13],DATA32);
SIGNAL(U_QDC2CH15,vme0.QDC2.data[14],DATA32);
SIGNAL(U_QDC2CH16,vme0.QDC2.data[15],DATA32);
SIGNAL(U_QDC2CH2,vme0.QDC2.data[1],DATA32);
SIGNAL(U_QDC2CH3,vme0.QDC2.data[2],DATA32);
SIGNAL(U_QDC2CH4,vme0.QDC2.data[3],DATA32);
SIGNAL(U_QDC2CH5,vme0.QDC2.data[4],DATA32);
SIGNAL(U_QDC2CH6,vme0.QDC2.data[5],DATA32);
SIGNAL(U_QDC2CH7,vme0.QDC2.data[6],DATA32);
SIGNAL(U_QDC2CH8,vme0.QDC2.data[7],DATA32);
SIGNAL(U_QDC2CH9,vme0.QDC2.data[8],DATA32);
SIGNAL(U_RBWCH1,vme0.timestamp.RBWL[0],DATA32);
SIGNAL(U_RBWCH2,vme0.timestamp.RBWL[1],DATA32);
SIGNAL(U_Sca1CH1,vme0.Sca1.data[0],DATA32);
SIGNAL(U_Sca1CH2,vme0.Sca1.data[1],DATA32);
SIGNAL(U_Sca1CH3,vme0.Sca1.data[2],DATA32);
SIGNAL(U_Sca1CH4,vme0.Sca1.data[3],DATA32);
SIGNAL(U_Sca1CH5,vme0.Sca1.data[4],DATA32);
SIGNAL(U_Sca1CH6,vme0.Sca1.data[5],DATA32);
SIGNAL(U_Sca1CH7,vme0.Sca1.data[6],DATA32);
SIGNAL(U_Sca1CH8,vme0.Sca1.data[7],DATA32);
SIGNAL(U_Sca2CH1,vme0.Sca2.data[0],DATA32);
SIGNAL(U_Sca2CH10,vme0.Sca2.data[9],DATA32);
SIGNAL(U_Sca2CH11,vme0.Sca2.data[10],DATA32);
SIGNAL(U_Sca2CH12,vme0.Sca2.data[11],DATA32);
SIGNAL(U_Sca2CH13,vme0.Sca2.data[12],DATA32);
SIGNAL(U_Sca2CH14,vme0.Sca2.data[13],DATA32);
SIGNAL(U_Sca2CH15,vme0.Sca2.data[14],DATA32);
SIGNAL(U_Sca2CH16,vme0.Sca2.data[15],DATA32);
SIGNAL(U_Sca2CH17,vme0.Sca2.data[16],DATA32);
SIGNAL(U_Sca2CH18,vme0.Sca2.data[17],DATA32);
SIGNAL(U_Sca2CH19,vme0.Sca2.data[18],DATA32);
SIGNAL(U_Sca2CH2,vme0.Sca2.data[1],DATA32);
SIGNAL(U_Sca2CH20,vme0.Sca2.data[19],DATA32);
SIGNAL(U_Sca2CH21,vme0.Sca2.data[20],DATA32);
SIGNAL(U_Sca2CH22,vme0.Sca2.data[21],DATA32);
SIGNAL(U_Sca2CH23,vme0.Sca2.data[22],DATA32);
SIGNAL(U_Sca2CH24,vme0.Sca2.data[23],DATA32);
SIGNAL(U_Sca2CH25,vme0.Sca2.data[24],DATA32);
SIGNAL(U_Sca2CH26,vme0.Sca2.data[25],DATA32);
SIGNAL(U_Sca2CH27,vme0.Sca2.data[26],DATA32);
SIGNAL(U_Sca2CH28,vme0.Sca2.data[27],DATA32);
SIGNAL(U_Sca2CH29,vme0.Sca2.data[28],DATA32);
SIGNAL(U_Sca2CH3,vme0.Sca2.data[2],DATA32);
SIGNAL(U_Sca2CH30,vme0.Sca2.data[29],DATA32);
SIGNAL(U_Sca2CH31,vme0.Sca2.data[30],DATA32);
SIGNAL(U_Sca2CH32,vme0.Sca2.data[31],DATA32);
SIGNAL(U_Sca2CH4,vme0.Sca2.data[3],DATA32);
SIGNAL(U_Sca2CH5,vme0.Sca2.data[4],DATA32);
SIGNAL(U_Sca2CH6,vme0.Sca2.data[5],DATA32);
SIGNAL(U_Sca2CH7,vme0.Sca2.data[6],DATA32);
SIGNAL(U_Sca2CH8,vme0.Sca2.data[7],DATA32);
SIGNAL(U_Sca2CH9,vme0.Sca2.data[8],DATA32);
SIGNAL(U_Sca3CH1,vme0.Sca3.data[0],DATA32);
SIGNAL(U_Sca3CH10,vme0.Sca3.data[9],DATA32);
SIGNAL(U_Sca3CH11,vme0.Sca3.data[10],DATA32);
SIGNAL(U_Sca3CH12,vme0.Sca3.data[11],DATA32);
SIGNAL(U_Sca3CH13,vme0.Sca3.data[12],DATA32);
SIGNAL(U_Sca3CH14,vme0.Sca3.data[13],DATA32);
SIGNAL(U_Sca3CH15,vme0.Sca3.data[14],DATA32);
SIGNAL(U_Sca3CH16,vme0.Sca3.data[15],DATA32);
SIGNAL(U_Sca3CH17,vme0.Sca3.data[16],DATA32);
SIGNAL(U_Sca3CH18,vme0.Sca3.data[17],DATA32);
SIGNAL(U_Sca3CH19,vme0.Sca3.data[18],DATA32);
SIGNAL(U_Sca3CH2,vme0.Sca3.data[1],DATA32);
SIGNAL(U_Sca3CH20,vme0.Sca3.data[19],DATA32);
SIGNAL(U_Sca3CH21,vme0.Sca3.data[20],DATA32);
SIGNAL(U_Sca3CH22,vme0.Sca3.data[21],DATA32);
SIGNAL(U_Sca3CH23,vme0.Sca3.data[22],DATA32);
SIGNAL(U_Sca3CH24,vme0.Sca3.data[23],DATA32);
SIGNAL(U_Sca3CH25,vme0.Sca3.data[24],DATA32);
SIGNAL(U_Sca3CH26,vme0.Sca3.data[25],DATA32);
SIGNAL(U_Sca3CH27,vme0.Sca3.data[26],DATA32);
SIGNAL(U_Sca3CH28,vme0.Sca3.data[27],DATA32);
SIGNAL(U_Sca3CH29,vme0.Sca3.data[28],DATA32);
SIGNAL(U_Sca3CH3,vme0.Sca3.data[2],DATA32);
SIGNAL(U_Sca3CH30,vme0.Sca3.data[29],DATA32);
SIGNAL(U_Sca3CH31,vme0.Sca3.data[30],DATA32);
SIGNAL(U_Sca3CH32,vme0.Sca3.data[31],DATA32);
SIGNAL(U_Sca3CH4,vme0.Sca3.data[3],DATA32);
SIGNAL(U_Sca3CH5,vme0.Sca3.data[4],DATA32);
SIGNAL(U_Sca3CH6,vme0.Sca3.data[5],DATA32);
SIGNAL(U_Sca3CH7,vme0.Sca3.data[6],DATA32);
SIGNAL(U_Sca3CH8,vme0.Sca3.data[7],DATA32);
SIGNAL(U_Sca3CH9,vme0.Sca3.data[8],DATA32);
SIGNAL(U_Sca4CH1,vme0.Sca4.data[0],DATA32);
SIGNAL(U_Sca4CH10,vme0.Sca4.data[9],DATA32);
SIGNAL(U_Sca4CH11,vme0.Sca4.data[10],DATA32);
SIGNAL(U_Sca4CH12,vme0.Sca4.data[11],DATA32);
SIGNAL(U_Sca4CH13,vme0.Sca4.data[12],DATA32);
SIGNAL(U_Sca4CH14,vme0.Sca4.data[13],DATA32);
SIGNAL(U_Sca4CH15,vme0.Sca4.data[14],DATA32);
SIGNAL(U_Sca4CH16,vme0.Sca4.data[15],DATA32);
SIGNAL(U_Sca4CH17,vme0.Sca4.data[16],DATA32);
SIGNAL(U_Sca4CH18,vme0.Sca4.data[17],DATA32);
SIGNAL(U_Sca4CH19,vme0.Sca4.data[18],DATA32);
SIGNAL(U_Sca4CH2,vme0.Sca4.data[1],DATA32);
SIGNAL(U_Sca4CH20,vme0.Sca4.data[19],DATA32);
SIGNAL(U_Sca4CH21,vme0.Sca4.data[20],DATA32);
SIGNAL(U_Sca4CH22,vme0.Sca4.data[21],DATA32);
SIGNAL(U_Sca4CH23,vme0.Sca4.data[22],DATA32);
SIGNAL(U_Sca4CH24,vme0.Sca4.data[23],DATA32);
SIGNAL(U_Sca4CH25,vme0.Sca4.data[24],DATA32);
SIGNAL(U_Sca4CH26,vme0.Sca4.data[25],DATA32);
SIGNAL(U_Sca4CH27,vme0.Sca4.data[26],DATA32);
SIGNAL(U_Sca4CH28,vme0.Sca4.data[27],DATA32);
SIGNAL(U_Sca4CH29,vme0.Sca4.data[28],DATA32);
SIGNAL(U_Sca4CH3,vme0.Sca4.data[2],DATA32);
SIGNAL(U_Sca4CH30,vme0.Sca4.data[29],DATA32);
SIGNAL(U_Sca4CH31,vme0.Sca4.data[30],DATA32);
SIGNAL(U_Sca4CH32,vme0.Sca4.data[31],DATA32);
SIGNAL(U_Sca4CH4,vme0.Sca4.data[3],DATA32);
SIGNAL(U_Sca4CH5,vme0.Sca4.data[4],DATA32);
SIGNAL(U_Sca4CH6,vme0.Sca4.data[5],DATA32);
SIGNAL(U_Sca4CH7,vme0.Sca4.data[6],DATA32);
SIGNAL(U_Sca4CH8,vme0.Sca4.data[7],DATA32);
SIGNAL(U_Sca4CH9,vme0.Sca4.data[8],DATA32);
SIGNAL(U_TDC1CH10_1,vme0.TDC1.data[9],DATA32);
SIGNAL(U_TDC1CH11_1,vme0.TDC1.data[10],DATA32);
SIGNAL(U_TDC1CH12_1,vme0.TDC1.data[11],DATA32);
SIGNAL(U_TDC1CH13_1,vme0.TDC1.data[12],DATA32);
SIGNAL(U_TDC1CH14_1,vme0.TDC1.data[13],DATA32);
SIGNAL(U_TDC1CH15_1,vme0.TDC1.data[14],DATA32);
SIGNAL(U_TDC1CH16_1,vme0.TDC1.data[15],DATA32);
SIGNAL(U_TDC1CH17_1,vme0.TDC1.data[16],DATA32);
SIGNAL(U_TDC1CH18_1,vme0.TDC1.data[17],DATA32);
SIGNAL(U_TDC1CH19_1,vme0.TDC1.data[18],DATA32);
SIGNAL(U_TDC1CH1_1,vme0.TDC1.data[0],DATA32);
SIGNAL(U_TDC1CH20_1,vme0.TDC1.data[19],DATA32);
SIGNAL(U_TDC1CH21_1,vme0.TDC1.data[20],DATA32);
SIGNAL(U_TDC1CH22_1,vme0.TDC1.data[21],DATA32);
SIGNAL(U_TDC1CH23_1,vme0.TDC1.data[22],DATA32);
SIGNAL(U_TDC1CH24_1,vme0.TDC1.data[23],DATA32);
SIGNAL(U_TDC1CH25_1,vme0.TDC1.data[24],DATA32);
SIGNAL(U_TDC1CH26_1,vme0.TDC1.data[25],DATA32);
SIGNAL(U_TDC1CH27_1,vme0.TDC1.data[26],DATA32);
SIGNAL(U_TDC1CH28_1,vme0.TDC1.data[27],DATA32);
SIGNAL(U_TDC1CH29_1,vme0.TDC1.data[28],DATA32);
SIGNAL(U_TDC1CH2_1,vme0.TDC1.data[1],DATA32);
SIGNAL(U_TDC1CH30_1,vme0.TDC1.data[29],DATA32);
SIGNAL(U_TDC1CH31_1,vme0.TDC1.data[30],DATA32);
SIGNAL(U_TDC1CH32_1,vme0.TDC1.data[31],DATA32);
SIGNAL(U_TDC1CH3_1,vme0.TDC1.data[2],DATA32);
SIGNAL(U_TDC1CH4_1,vme0.TDC1.data[3],DATA32);
SIGNAL(U_TDC1CH5_1,vme0.TDC1.data[4],DATA32);
SIGNAL(U_TDC1CH6_1,vme0.TDC1.data[5],DATA32);
SIGNAL(U_TDC1CH7_1,vme0.TDC1.data[6],DATA32);
SIGNAL(U_TDC1CH8_1,vme0.TDC1.data[7],DATA32);
SIGNAL(U_TDC1CH9_1,vme0.TDC1.data[8],DATA32);
SIGNAL(U_tsCH1,vme0.timestamp.ts[0],DATA32);
SIGNAL(U_tsCH2,vme0.timestamp.ts[1],DATA32);
SIGNAL(U_tsCH3,vme0.timestamp.ts[2],DATA32);
SIGNAL(U_tsCH4,vme0.timestamp.ts[3],DATA32);
SIGNAL(U_tsCH5,vme0.timestamp.ts[4],DATA32);
SIGNAL(U_tsCH6,vme0.timestamp.ts[5],DATA32);
SIGNAL(U_tsCH7,vme0.timestamp.ts[6],DATA32);
SIGNAL(U_tsCH8,vme0.timestamp.ts[7],DATA32);
SIGNAL( NO_INDEX_LIST(5):U_TDC1CH1);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: FZD_Modul
//
//
// Generating code for: FZD_data_SUBITEM
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FZD_data_SUBITEM.
 *
 * Do not edit - automatically generated.
 */

// FZD_data_SUBITEM(geo,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_FZD_data_SUBITEM
class FZD_data_SUBITEM
#else//PACKER_CODE
# define DECLARED_PACKER_FZD_data_SUBITEM
class PACKER_FZD_data_SUBITEM
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 ch_data NOENCODE
  // {
    //  0_23: data;
    // 24_28: channel = RANGE(0,32);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(data[channel],(value=data));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geo,raw_array_multi_zero_suppress<DATA32,DATA32,32,5> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geo);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geo,raw_array_multi_zero_suppress<DATA32,DATA32,32,5> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FZD_data_SUBITEM);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FZD_data_SUBITEM.
 *
 * Do not edit - automatically generated.
 */

// FZD_data_SUBITEM(geo,data)
template<typename __data_src_t>
void FZD_data_SUBITEM::__unpack(__data_src_t &__buffer,uint32 geo,raw_array_multi_zero_suppress<DATA32,DATA32,32,5> &data)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 ch_data NOENCODE
  // {
    //  0_23: data;
    // 24_28: channel = RANGE(0,32);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(data[channel],(value=data));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 data : 24; // 0..23
      uint32 channel : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 channel : 5; // 24..28
      uint32 data : 24; // 0..23
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(117,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(112,ch_data.channel,32);
  CHECK_BITS_EQUAL(113,ch_data.unnamed_29_29,0);
  CHECK_BITS_EQUAL(114,ch_data.unnamed_30_30,0);
  CHECK_BITS_EQUAL(115,ch_data.unnamed_31_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(116,ch_data.channel);
    __item.value = ch_data.data;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FZD_data_SUBITEM::__unpack,uint32 geo,raw_array_multi_zero_suppress<DATA32,DATA32,32,5> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FZD_data_SUBITEM.
 *
 * Do not edit - automatically generated.
 */

// FZD_data_SUBITEM(geo,data)
template<typename __data_src_t>
bool FZD_data_SUBITEM::__match(__data_src_t &__buffer,uint32 geo)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 ch_data NOENCODE
  // {
    //  0_23: data;
    // 24_28: channel = RANGE(0,32);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(data[channel],(value=data));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 data : 24; // 0..23
      uint32 channel : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 channel : 5; // 24..28
      uint32 data : 24; // 0..23
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(117,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(112,ch_data.channel,32);
  MATCH_BITS_EQUAL(113,ch_data.unnamed_29_29,0);
  MATCH_BITS_EQUAL(114,ch_data.unnamed_30_30,0);
  MATCH_BITS_EQUAL(115,ch_data.unnamed_31_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FZD_data_SUBITEM::__match,uint32 geo);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FZD_data_SUBITEM.
 *
 * Do not edit - automatically generated.
 */

// FZD_data_SUBITEM(geo,data)
template<typename __data_dest_t>
void PACKER_FZD_data_SUBITEM::__packer(__data_dest_t &__buffer,uint32 geo
                                                              ,raw_array_multi_zero_suppress<DATA32,DATA32,32,5> &data)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 ch_data NOENCODE
  // {
    //  0_23: data;
    // 24_28: channel = RANGE(0,32);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(data[channel],(value=data));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FZD_data_SUBITEM::__packer,uint32 geo);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FZD_Modul.
 *
 * Do not edit - automatically generated.
 */

// FZD_Modul(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_FZD_Modul
class FZD_Modul
#else//PACKER_CODE
# define DECLARED_PACKER_FZD_Modul
class PACKER_FZD_Modul
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  raw_array_multi_zero_suppress<DATA32,DATA32,32,5> data;
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_23 : 24; // 0..23
      uint32 geom : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 geom : 5; // 24..28
      uint32 unnamed_0_23 : 24; // 0..23
#endif
    };
    uint32  u32;
  } header;
  // select several

    // dummy = FZD_data_SUBITEM(geo=geom,data=data);
  SINGLE(FZD_data_SUBITEM,dummy);
  // UINT32 EOB
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 0;
    //    30: 1;
    //    31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_23 : 24; // 0..23
      uint32 geom : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 geom : 5; // 24..28
      uint32 unnamed_0_23 : 24; // 0..23
#endif
    };
    uint32  u32;
  } EOB;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FZD_Modul);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FZD_Modul.
 *
 * Do not edit - automatically generated.
 */

// FZD_Modul(geom)
template<typename __data_src_t>
void FZD_Modul::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  READ_FROM_BUFFER_FULL(18,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(13,header.unnamed_0_23,0);
  CHECK_BITS_EQUAL(14,header.geom,geom);
  CHECK_BITS_EQUAL(15,header.unnamed_29_29,1);
  CHECK_BITS_EQUAL(16,header.unnamed_30_30,0);
  CHECK_BITS_EQUAL(17,header.unnamed_31_31,0);
  // select several

    // dummy = FZD_data_SUBITEM(geo=geom,data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FZD_data_SUBITEM dummy: (s32) => (0xe0000000,0x00000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(22,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(21,spurious_match_abort_loop_0,FZD_data_SUBITEM,/*geo*/geom/*,data:member*/);
        UNPACK_DECL(21,FZD_data_SUBITEM,dummy,/*geo*/geom,/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // UINT32 EOB
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 0;
    //    30: 1;
    //    31: 0;
  // }
  READ_FROM_BUFFER_FULL(30,uint32 ,EOB,EOB.u32);
  CHECK_BITS_EQUAL(25,EOB.unnamed_0_23,0);
  CHECK_BITS_EQUAL(26,EOB.geom,geom);
  CHECK_BITS_EQUAL(27,EOB.unnamed_29_29,0);
  CHECK_BITS_EQUAL(28,EOB.unnamed_30_30,1);
  CHECK_BITS_EQUAL(29,EOB.unnamed_31_31,0);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FZD_Modul::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FZD_Modul.
 *
 * Do not edit - automatically generated.
 */

// FZD_Modul(geom)
template<typename __data_src_t>
bool FZD_Modul::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_23 : 24; // 0..23
      uint32 geom : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 geom : 5; // 24..28
      uint32 unnamed_0_23 : 24; // 0..23
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(18,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(13,__header.unnamed_0_23,0);
  MATCH_BITS_EQUAL(14,__header.geom,geom);
  MATCH_BITS_EQUAL(15,__header.unnamed_29_29,1);
  MATCH_BITS_EQUAL(16,__header.unnamed_30_30,0);
  MATCH_BITS_EQUAL(17,__header.unnamed_31_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FZD_Modul::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FZD_Modul.
 *
 * Do not edit - automatically generated.
 */

// FZD_Modul(geom)
template<typename __data_dest_t>
void PACKER_FZD_Modul::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS_MULTI(5));
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  // select several

    // dummy = FZD_data_SUBITEM(geo=geom,data=data);
  {
    PACK_DECL(21,FZD_data_SUBITEM,dummy,/*geo*/geom,/*data*/data);
  }
  // UINT32 EOB
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 0;
    //    30: 1;
    //    31: 0;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FZD_Modul::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: FZD_V1495
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FZD_V1495.
 *
 * Do not edit - automatically generated.
 */

// FZD_V1495(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_FZD_V1495
class FZD_V1495
#else//PACKER_CODE
# define DECLARED_PACKER_FZD_V1495
class PACKER_FZD_V1495
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 ts[8] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,8> ts;
  // MEMBER(DATA32 RBWL[2] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,2> RBWL;
  // MEMBER(DATA32 MP);
  DATA32 MP;
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_23 : 24; // 0..23
      uint32 geom : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 geom : 5; // 24..28
      uint32 unnamed_0_23 : 24; // 0..23
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<5)

    // UINT32 ch_data NOENCODE
    // {
      //  0_23: timestamp;
      // 24_28: channel = RANGE(0,4);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(ts[channel],(value=timestamp));
    // }
  // UINT32 ch_data NOENCODE
  // {
    //  0_07: timestamp;
    //     8: dummy = RANGE(0,1);
    //     9: MPF = RANGE(0,1);
    //    10: RBWF = RANGE(0,1);
    // 11_23: 0;
    // 24_28: channel = RANGE(5,5);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(MP,(value=MPF));
    // ENCODE(ts[channel],(value=timestamp));
  // }
  // list(0<=index<2)

    // UINT32 ch_data NOENCODE
    // {
      //  0_23: timestamp;
      // 24_28: channel = RANGE(6,7);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(ts[channel],(value=timestamp));
    // }
  // list(0<=index<2)

    // UINT32 ch_data NOENCODE
    // {
      //  0_23: length;
      // 24_28: channel = RANGE(8,9);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(RBWL[(channel - 8)],(value=length));
    // }
  // UINT32 EOB
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 0;
    //    30: 1;
    //    31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_23 : 24; // 0..23
      uint32 geom : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 geom : 5; // 24..28
      uint32 unnamed_0_23 : 24; // 0..23
#endif
    };
    uint32  u32;
  } EOB;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FZD_V1495);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FZD_V1495.
 *
 * Do not edit - automatically generated.
 */

// FZD_V1495(geom)
template<typename __data_src_t>
void FZD_V1495::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 ts[8] ZERO_SUPPRESS);
  // MEMBER(DATA32 RBWL[2] ZERO_SUPPRESS);
  // MEMBER(DATA32 MP);
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  READ_FROM_BUFFER_FULL(45,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(40,header.unnamed_0_23,0);
  CHECK_BITS_EQUAL(41,header.geom,geom);
  CHECK_BITS_EQUAL(42,header.unnamed_29_29,1);
  CHECK_BITS_EQUAL(43,header.unnamed_30_30,0);
  CHECK_BITS_EQUAL(44,header.unnamed_31_31,0);
  // list(0<=index<5)

  for (uint32 index = 0; index < (uint32) (5); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: timestamp;
      // 24_28: channel = RANGE(0,4);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(ts[channel],(value=timestamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 timestamp : 24; // 0..23
        uint32 channel : 5; // 24..28
        uint32 unnamed_29_29 : 1; // 29
        uint32 unnamed_30_30 : 1; // 30
        uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_31_31 : 1; // 31
        uint32 unnamed_30_30 : 1; // 30
        uint32 unnamed_29_29 : 1; // 29
        uint32 channel : 5; // 24..28
        uint32 timestamp : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(56,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_RANGE_MAX(51,ch_data.channel,4);
    CHECK_BITS_EQUAL(52,ch_data.unnamed_29_29,0);
    CHECK_BITS_EQUAL(53,ch_data.unnamed_30_30,0);
    CHECK_BITS_EQUAL(54,ch_data.unnamed_31_31,0);
    {
      typedef __typeof__(*(&(ts))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts.insert_index(55,ch_data.channel);
      __item.value = ch_data.timestamp;
    }
  }
  // UINT32 ch_data NOENCODE
  // {
    //  0_07: timestamp;
    //     8: dummy = RANGE(0,1);
    //     9: MPF = RANGE(0,1);
    //    10: RBWF = RANGE(0,1);
    // 11_23: 0;
    // 24_28: channel = RANGE(5,5);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(MP,(value=MPF));
    // ENCODE(ts[channel],(value=timestamp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timestamp : 8; // 0..7
      uint32 dummy : 1; // 8
      uint32 MPF : 1; // 9
      uint32 RBWF : 1; // 10
      uint32 unnamed_11_23 : 13; // 11..23
      uint32 channel : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 channel : 5; // 24..28
      uint32 unnamed_11_23 : 13; // 11..23
      uint32 RBWF : 1; // 10
      uint32 MPF : 1; // 9
      uint32 dummy : 1; // 8
      uint32 timestamp : 8; // 0..7
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(71,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(61,ch_data.dummy,1);
  CHECK_BITS_RANGE_MAX(62,ch_data.MPF,1);
  CHECK_BITS_RANGE_MAX(63,ch_data.RBWF,1);
  CHECK_BITS_EQUAL(64,ch_data.unnamed_11_23,0);
  CHECK_BITS_RANGE(65,ch_data.channel,5,5);
  CHECK_BITS_EQUAL(66,ch_data.unnamed_29_29,0);
  CHECK_BITS_EQUAL(67,ch_data.unnamed_30_30,0);
  CHECK_BITS_EQUAL(68,ch_data.unnamed_31_31,0);
  {
    MP.value = ch_data.MPF;
  }
  {
    typedef __typeof__(*(&(ts))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = ts.insert_index(70,ch_data.channel);
    __item.value = ch_data.timestamp;
  }
  // list(0<=index<2)

  for (uint32 index = 0; index < (uint32) (2); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: timestamp;
      // 24_28: channel = RANGE(6,7);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(ts[channel],(value=timestamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 timestamp : 24; // 0..23
        uint32 channel : 5; // 24..28
        uint32 unnamed_29_29 : 1; // 29
        uint32 unnamed_30_30 : 1; // 30
        uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_31_31 : 1; // 31
        uint32 unnamed_30_30 : 1; // 30
        uint32 unnamed_29_29 : 1; // 29
        uint32 channel : 5; // 24..28
        uint32 timestamp : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(82,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_RANGE(77,ch_data.channel,6,7);
    CHECK_BITS_EQUAL(78,ch_data.unnamed_29_29,0);
    CHECK_BITS_EQUAL(79,ch_data.unnamed_30_30,0);
    CHECK_BITS_EQUAL(80,ch_data.unnamed_31_31,0);
    {
      typedef __typeof__(*(&(ts))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts.insert_index(81,ch_data.channel);
      __item.value = ch_data.timestamp;
    }
  }
  // list(0<=index<2)

  for (uint32 index = 0; index < (uint32) (2); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: length;
      // 24_28: channel = RANGE(8,9);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(RBWL[(channel - 8)],(value=length));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 length : 24; // 0..23
        uint32 channel : 5; // 24..28
        uint32 unnamed_29_29 : 1; // 29
        uint32 unnamed_30_30 : 1; // 30
        uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_31_31 : 1; // 31
        uint32 unnamed_30_30 : 1; // 30
        uint32 unnamed_29_29 : 1; // 29
        uint32 channel : 5; // 24..28
        uint32 length : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(94,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_RANGE(89,ch_data.channel,8,9);
    CHECK_BITS_EQUAL(90,ch_data.unnamed_29_29,0);
    CHECK_BITS_EQUAL(91,ch_data.unnamed_30_30,0);
    CHECK_BITS_EQUAL(92,ch_data.unnamed_31_31,0);
    {
      typedef __typeof__(*(&(RBWL))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = RBWL.insert_index(93,(ch_data.channel - 8));
      __item.value = ch_data.length;
    }
  }
  // UINT32 EOB
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 0;
    //    30: 1;
    //    31: 0;
  // }
  READ_FROM_BUFFER_FULL(103,uint32 ,EOB,EOB.u32);
  CHECK_BITS_EQUAL(98,EOB.unnamed_0_23,0);
  CHECK_BITS_EQUAL(99,EOB.geom,geom);
  CHECK_BITS_EQUAL(100,EOB.unnamed_29_29,0);
  CHECK_BITS_EQUAL(101,EOB.unnamed_30_30,1);
  CHECK_BITS_EQUAL(102,EOB.unnamed_31_31,0);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FZD_V1495::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FZD_V1495.
 *
 * Do not edit - automatically generated.
 */

// FZD_V1495(geom)
template<typename __data_src_t>
bool FZD_V1495::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 ts[8] ZERO_SUPPRESS);
  // MEMBER(DATA32 RBWL[2] ZERO_SUPPRESS);
  // MEMBER(DATA32 MP);
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_23 : 24; // 0..23
      uint32 geom : 5; // 24..28
      uint32 unnamed_29_29 : 1; // 29
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_30_30 : 1; // 30
      uint32 unnamed_29_29 : 1; // 29
      uint32 geom : 5; // 24..28
      uint32 unnamed_0_23 : 24; // 0..23
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(45,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(40,__header.unnamed_0_23,0);
  MATCH_BITS_EQUAL(41,__header.geom,geom);
  MATCH_BITS_EQUAL(42,__header.unnamed_29_29,1);
  MATCH_BITS_EQUAL(43,__header.unnamed_30_30,0);
  MATCH_BITS_EQUAL(44,__header.unnamed_31_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FZD_V1495::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FZD_V1495.
 *
 * Do not edit - automatically generated.
 */

// FZD_V1495(geom)
template<typename __data_dest_t>
void PACKER_FZD_V1495::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 ts[8] ZERO_SUPPRESS);
  // MEMBER(DATA32 RBWL[2] ZERO_SUPPRESS);
  // MEMBER(DATA32 MP);
  // UINT32 header
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 1;
    //    30: 0;
    //    31: 0;
  // }
  // list(0<=index<5)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: timestamp;
      // 24_28: channel = RANGE(0,4);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(ts[channel],(value=timestamp));
    // }
  }
  // UINT32 ch_data NOENCODE
  // {
    //  0_07: timestamp;
    //     8: dummy = RANGE(0,1);
    //     9: MPF = RANGE(0,1);
    //    10: RBWF = RANGE(0,1);
    // 11_23: 0;
    // 24_28: channel = RANGE(5,5);
    //    29: 0;
    //    30: 0;
    //    31: 0;
    // ENCODE(MP,(value=MPF));
    // ENCODE(ts[channel],(value=timestamp));
  // }
  // list(0<=index<2)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: timestamp;
      // 24_28: channel = RANGE(6,7);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(ts[channel],(value=timestamp));
    // }
  }
  // list(0<=index<2)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: length;
      // 24_28: channel = RANGE(8,9);
      //    29: 0;
      //    30: 0;
      //    31: 0;
      // ENCODE(RBWL[(channel - 8)],(value=length));
    // }
  }
  // UINT32 EOB
  // {
    //  0_23: 0;
    // 24_28: geom = MATCH(geom);
    //    29: 0;
    //    30: 1;
    //    31: 0;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FZD_V1495::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: CRATE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CRATE.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CRATE)
#if !PACKER_CODE
# define DECLARED_UNPACK_CRATE
class CRATE
#else//PACKER_CODE
# define DECLARED_PACKER_CRATE
class PACKER_CRATE
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // timestamp = FZD_V1495(geom=21);
    // QDC1 = FZD_Modul(geom=7);
    // QDC2 = FZD_Modul(geom=8);
    // TDC1 = FZD_Modul(geom=5);
    // Sca1 = FZD_Modul(geom=13);
    // Sca2 = FZD_Modul(geom=14);
    // Sca3 = FZD_Modul(geom=15);
    // Sca4 = FZD_Modul(geom=16);
  SINGLE(FZD_V1495,timestamp);
  SINGLE(FZD_Modul,QDC2);
  SINGLE(FZD_Modul,QDC1);
  SINGLE(FZD_Modul,TDC1);
  SINGLE(FZD_Modul,Sca1);
  SINGLE(FZD_Modul,Sca2);
  SINGLE(FZD_Modul,Sca3);
  SINGLE(FZD_Modul,Sca4);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CRATE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CRATE.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CRATE)
template<typename __data_src_t>
void CRATE::__unpack(__data_src_t &__buffer)
{
  // select several

    // timestamp = FZD_V1495(geom=21);
    // QDC1 = FZD_Modul(geom=7);
    // QDC2 = FZD_Modul(geom=8);
    // TDC1 = FZD_Modul(geom=5);
    // Sca1 = FZD_Modul(geom=13);
    // Sca2 = FZD_Modul(geom=14);
    // Sca3 = FZD_Modul(geom=15);
    // Sca4 = FZD_Modul(geom=16);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FZD_V1495 timestamp: (s32) => (0xffffffff,0x35000000)
    // optimized match 2: FZD_Modul QDC1: (s32) => (0xffffffff,0x27000000)
    // optimized match 3: FZD_Modul QDC2: (s32) => (0xffffffff,0x28000000)
    // optimized match 4: FZD_Modul TDC1: (s32) => (0xffffffff,0x25000000)
    // optimized match 5: FZD_Modul Sca1: (s32) => (0xffffffff,0x2d000000)
    // optimized match 6: FZD_Modul Sca2: (s32) => (0xffffffff,0x2e000000)
    // optimized match 7: FZD_Modul Sca3: (s32) => (0xffffffff,0x2f000000)
    // optimized match 8: FZD_Modul Sca4: (s32) => (0xffffffff,0x30000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(132,uint32,__match_peek);
    // differ = 1f000000 : 24 25 26 27 28
    uint32 __match_index = 0 | /* 24,28 */ ((__match_peek >> 24) & 0x0000001f);
    static const sint8 __match_index_array[32] = { 0, 0, 0, 0, 0, 4, 0, 2, 3, 0, 0, 0, 0, 5, 6, 7, 8, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(124,FZD_V1495,timestamp,/*geom*/21);
        break;
      case 2:
        UNPACK_DECL(125,FZD_Modul,QDC1,/*geom*/7);
        break;
      case 3:
        UNPACK_DECL(126,FZD_Modul,QDC2,/*geom*/8);
        break;
      case 4:
        UNPACK_DECL(127,FZD_Modul,TDC1,/*geom*/5);
        break;
      case 5:
        UNPACK_DECL(128,FZD_Modul,Sca1,/*geom*/13);
        break;
      case 6:
        UNPACK_DECL(129,FZD_Modul,Sca2,/*geom*/14);
        break;
      case 7:
        UNPACK_DECL(130,FZD_Modul,Sca3,/*geom*/15);
        break;
      case 8:
        UNPACK_DECL(131,FZD_Modul,Sca4,/*geom*/16);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CRATE::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CRATE.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CRATE)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CRATE.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CRATE)
template<typename __data_dest_t>
void PACKER_CRATE::__packer(__data_dest_t &__buffer)
{
  // select several

    // timestamp = FZD_V1495(geom=21);
    // QDC1 = FZD_Modul(geom=7);
    // QDC2 = FZD_Modul(geom=8);
    // TDC1 = FZD_Modul(geom=5);
    // Sca1 = FZD_Modul(geom=13);
    // Sca2 = FZD_Modul(geom=14);
    // Sca3 = FZD_Modul(geom=15);
    // Sca4 = FZD_Modul(geom=16);
  {
    PACK_DECL(124,FZD_V1495,timestamp,/*geom*/21);
    PACK_DECL(125,FZD_Modul,QDC1,/*geom*/7);
    PACK_DECL(126,FZD_Modul,QDC2,/*geom*/8);
    PACK_DECL(127,FZD_Modul,TDC1,/*geom*/5);
    PACK_DECL(128,FZD_Modul,Sca1,/*geom*/13);
    PACK_DECL(129,FZD_Modul,Sca2,/*geom*/14);
    PACK_DECL(130,FZD_Modul,Sca3,/*geom*/15);
    PACK_DECL(131,FZD_Modul,Sca4,/*geom*/16);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CRATE::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // vme0 = CRATE(type=10,subtype=1);
SINGLE(CRATE,vme0);
public:
#ifndef __PSDC__
  bitsone<1> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // vme0 = CRATE(type=10,subtype=1);
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(141,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)),vme0);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(141,CRATE,vme0,0);
      UNPACK_SUBEVENT_DECL(141,0,CRATE,vme0);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // vme0 = CRATE(type=10,subtype=1);
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // vme0 = CRATE(type=10,subtype=1);
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(141,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)),vme0);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(141,CRATE,vme0,0);
      REVOKE_SUBEVENT_DECL(141,0,CRATE,vme0);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "vme0", "type=10:subtype=1" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

//DUMPY: 2 0
class raw_event_U_QDC
{
public:
//DUMPY: 16 0
  DATA32 CH[16];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_U_QDC);
#endif//!__PSDC__
} ;

//DUMPY: 4 0
class raw_event_U_Sca
{
public:
//DUMPY: 32 0
  DATA32 CH[32];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_U_Sca);
#endif//!__PSDC__
} ;

//DUMPY: 1 0
class raw_event_U_TDC
{
public:
//DUMPY: 32 0
//DUMPY: 5 2
  raw_list_ii_zero_suppress<DATA32,DATA32,5> CH[32];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_U_TDC);
#endif//!__PSDC__
} ;

class raw_event_U
{
public:
  DATA32 MPflag;
//DUMPY: 2 0
  raw_event_U_QDC
  /* {
  public:
//DUMPY: 16 0
    DATA32 CH[16];
  } */ QDC[2];
//DUMPY: 2 0
  DATA32 RBWCH[2];
//DUMPY: 4 0
  raw_event_U_Sca
  /* {
  public:
//DUMPY: 32 0
    DATA32 CH[32];
  } */ Sca[4];
//DUMPY: 1 0
  raw_event_U_TDC
  /* {
  public:
//DUMPY: 32 0
//DUMPY: 5 2
    raw_list_ii_zero_suppress<DATA32,DATA32,5> CH[32];
  } */ TDC[1];
//DUMPY: 8 0
  DATA32 tsCH[8];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_U);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
  raw_event_U
  /* {
  public:
    DATA32 MPflag;
//DUMPY: 2 0
    raw_event_U_QDC
    {
    public:
//DUMPY: 16 0
      DATA32 CH[16];
    } QDC[2];
//DUMPY: 2 0
    DATA32 RBWCH[2];
//DUMPY: 4 0
    raw_event_U_Sca
    {
    public:
//DUMPY: 32 0
      DATA32 CH[32];
    } Sca[4];
//DUMPY: 1 0
    raw_event_U_TDC
    {
    public:
//DUMPY: 32 0
//DUMPY: 5 2
      raw_list_ii_zero_suppress<DATA32,DATA32,5> CH[32];
    } TDC[1];
//DUMPY: 8 0
    DATA32 tsCH[8];
  } */ U;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA32,U_MPflag,vme0.timestamp.MP,U.MPflag);
SIGNAL_MAPPING(DATA32,U_QDC1CH1,vme0.QDC1.data[0],U.QDC[0].CH[0]);
SIGNAL_MAPPING(DATA32,U_QDC1CH10,vme0.QDC1.data[9],U.QDC[0].CH[9]);
SIGNAL_MAPPING(DATA32,U_QDC1CH11,vme0.QDC1.data[10],U.QDC[0].CH[10]);
SIGNAL_MAPPING(DATA32,U_QDC1CH12,vme0.QDC1.data[11],U.QDC[0].CH[11]);
SIGNAL_MAPPING(DATA32,U_QDC1CH13,vme0.QDC1.data[12],U.QDC[0].CH[12]);
SIGNAL_MAPPING(DATA32,U_QDC1CH14,vme0.QDC1.data[13],U.QDC[0].CH[13]);
SIGNAL_MAPPING(DATA32,U_QDC1CH15,vme0.QDC1.data[14],U.QDC[0].CH[14]);
SIGNAL_MAPPING(DATA32,U_QDC1CH16,vme0.QDC1.data[15],U.QDC[0].CH[15]);
SIGNAL_MAPPING(DATA32,U_QDC1CH2,vme0.QDC1.data[1],U.QDC[0].CH[1]);
SIGNAL_MAPPING(DATA32,U_QDC1CH3,vme0.QDC1.data[2],U.QDC[0].CH[2]);
SIGNAL_MAPPING(DATA32,U_QDC1CH4,vme0.QDC1.data[3],U.QDC[0].CH[3]);
SIGNAL_MAPPING(DATA32,U_QDC1CH5,vme0.QDC1.data[4],U.QDC[0].CH[4]);
SIGNAL_MAPPING(DATA32,U_QDC1CH6,vme0.QDC1.data[5],U.QDC[0].CH[5]);
SIGNAL_MAPPING(DATA32,U_QDC1CH7,vme0.QDC1.data[6],U.QDC[0].CH[6]);
SIGNAL_MAPPING(DATA32,U_QDC1CH8,vme0.QDC1.data[7],U.QDC[0].CH[7]);
SIGNAL_MAPPING(DATA32,U_QDC1CH9,vme0.QDC1.data[8],U.QDC[0].CH[8]);
SIGNAL_MAPPING(DATA32,U_QDC2CH1,vme0.QDC2.data[0],U.QDC[1].CH[0]);
SIGNAL_MAPPING(DATA32,U_QDC2CH10,vme0.QDC2.data[9],U.QDC[1].CH[9]);
SIGNAL_MAPPING(DATA32,U_QDC2CH11,vme0.QDC2.data[10],U.QDC[1].CH[10]);
SIGNAL_MAPPING(DATA32,U_QDC2CH12,vme0.QDC2.data[11],U.QDC[1].CH[11]);
SIGNAL_MAPPING(DATA32,U_QDC2CH13,vme0.QDC2.data[12],U.QDC[1].CH[12]);
SIGNAL_MAPPING(DATA32,U_QDC2CH14,vme0.QDC2.data[13],U.QDC[1].CH[13]);
SIGNAL_MAPPING(DATA32,U_QDC2CH15,vme0.QDC2.data[14],U.QDC[1].CH[14]);
SIGNAL_MAPPING(DATA32,U_QDC2CH16,vme0.QDC2.data[15],U.QDC[1].CH[15]);
SIGNAL_MAPPING(DATA32,U_QDC2CH2,vme0.QDC2.data[1],U.QDC[1].CH[1]);
SIGNAL_MAPPING(DATA32,U_QDC2CH3,vme0.QDC2.data[2],U.QDC[1].CH[2]);
SIGNAL_MAPPING(DATA32,U_QDC2CH4,vme0.QDC2.data[3],U.QDC[1].CH[3]);
SIGNAL_MAPPING(DATA32,U_QDC2CH5,vme0.QDC2.data[4],U.QDC[1].CH[4]);
SIGNAL_MAPPING(DATA32,U_QDC2CH6,vme0.QDC2.data[5],U.QDC[1].CH[5]);
SIGNAL_MAPPING(DATA32,U_QDC2CH7,vme0.QDC2.data[6],U.QDC[1].CH[6]);
SIGNAL_MAPPING(DATA32,U_QDC2CH8,vme0.QDC2.data[7],U.QDC[1].CH[7]);
SIGNAL_MAPPING(DATA32,U_QDC2CH9,vme0.QDC2.data[8],U.QDC[1].CH[8]);
SIGNAL_MAPPING(DATA32,U_RBWCH1,vme0.timestamp.RBWL[0],U.RBWCH[0]);
SIGNAL_MAPPING(DATA32,U_RBWCH2,vme0.timestamp.RBWL[1],U.RBWCH[1]);
SIGNAL_MAPPING(DATA32,U_Sca1CH1,vme0.Sca1.data[0],U.Sca[0].CH[0]);
SIGNAL_MAPPING(DATA32,U_Sca1CH2,vme0.Sca1.data[1],U.Sca[0].CH[1]);
SIGNAL_MAPPING(DATA32,U_Sca1CH3,vme0.Sca1.data[2],U.Sca[0].CH[2]);
SIGNAL_MAPPING(DATA32,U_Sca1CH4,vme0.Sca1.data[3],U.Sca[0].CH[3]);
SIGNAL_MAPPING(DATA32,U_Sca1CH5,vme0.Sca1.data[4],U.Sca[0].CH[4]);
SIGNAL_MAPPING(DATA32,U_Sca1CH6,vme0.Sca1.data[5],U.Sca[0].CH[5]);
SIGNAL_MAPPING(DATA32,U_Sca1CH7,vme0.Sca1.data[6],U.Sca[0].CH[6]);
SIGNAL_MAPPING(DATA32,U_Sca1CH8,vme0.Sca1.data[7],U.Sca[0].CH[7]);
SIGNAL_MAPPING(DATA32,U_Sca2CH1,vme0.Sca2.data[0],U.Sca[1].CH[0]);
SIGNAL_MAPPING(DATA32,U_Sca2CH10,vme0.Sca2.data[9],U.Sca[1].CH[9]);
SIGNAL_MAPPING(DATA32,U_Sca2CH11,vme0.Sca2.data[10],U.Sca[1].CH[10]);
SIGNAL_MAPPING(DATA32,U_Sca2CH12,vme0.Sca2.data[11],U.Sca[1].CH[11]);
SIGNAL_MAPPING(DATA32,U_Sca2CH13,vme0.Sca2.data[12],U.Sca[1].CH[12]);
SIGNAL_MAPPING(DATA32,U_Sca2CH14,vme0.Sca2.data[13],U.Sca[1].CH[13]);
SIGNAL_MAPPING(DATA32,U_Sca2CH15,vme0.Sca2.data[14],U.Sca[1].CH[14]);
SIGNAL_MAPPING(DATA32,U_Sca2CH16,vme0.Sca2.data[15],U.Sca[1].CH[15]);
SIGNAL_MAPPING(DATA32,U_Sca2CH17,vme0.Sca2.data[16],U.Sca[1].CH[16]);
SIGNAL_MAPPING(DATA32,U_Sca2CH18,vme0.Sca2.data[17],U.Sca[1].CH[17]);
SIGNAL_MAPPING(DATA32,U_Sca2CH19,vme0.Sca2.data[18],U.Sca[1].CH[18]);
SIGNAL_MAPPING(DATA32,U_Sca2CH2,vme0.Sca2.data[1],U.Sca[1].CH[1]);
SIGNAL_MAPPING(DATA32,U_Sca2CH20,vme0.Sca2.data[19],U.Sca[1].CH[19]);
SIGNAL_MAPPING(DATA32,U_Sca2CH21,vme0.Sca2.data[20],U.Sca[1].CH[20]);
SIGNAL_MAPPING(DATA32,U_Sca2CH22,vme0.Sca2.data[21],U.Sca[1].CH[21]);
SIGNAL_MAPPING(DATA32,U_Sca2CH23,vme0.Sca2.data[22],U.Sca[1].CH[22]);
SIGNAL_MAPPING(DATA32,U_Sca2CH24,vme0.Sca2.data[23],U.Sca[1].CH[23]);
SIGNAL_MAPPING(DATA32,U_Sca2CH25,vme0.Sca2.data[24],U.Sca[1].CH[24]);
SIGNAL_MAPPING(DATA32,U_Sca2CH26,vme0.Sca2.data[25],U.Sca[1].CH[25]);
SIGNAL_MAPPING(DATA32,U_Sca2CH27,vme0.Sca2.data[26],U.Sca[1].CH[26]);
SIGNAL_MAPPING(DATA32,U_Sca2CH28,vme0.Sca2.data[27],U.Sca[1].CH[27]);
SIGNAL_MAPPING(DATA32,U_Sca2CH29,vme0.Sca2.data[28],U.Sca[1].CH[28]);
SIGNAL_MAPPING(DATA32,U_Sca2CH3,vme0.Sca2.data[2],U.Sca[1].CH[2]);
SIGNAL_MAPPING(DATA32,U_Sca2CH30,vme0.Sca2.data[29],U.Sca[1].CH[29]);
SIGNAL_MAPPING(DATA32,U_Sca2CH31,vme0.Sca2.data[30],U.Sca[1].CH[30]);
SIGNAL_MAPPING(DATA32,U_Sca2CH32,vme0.Sca2.data[31],U.Sca[1].CH[31]);
SIGNAL_MAPPING(DATA32,U_Sca2CH4,vme0.Sca2.data[3],U.Sca[1].CH[3]);
SIGNAL_MAPPING(DATA32,U_Sca2CH5,vme0.Sca2.data[4],U.Sca[1].CH[4]);
SIGNAL_MAPPING(DATA32,U_Sca2CH6,vme0.Sca2.data[5],U.Sca[1].CH[5]);
SIGNAL_MAPPING(DATA32,U_Sca2CH7,vme0.Sca2.data[6],U.Sca[1].CH[6]);
SIGNAL_MAPPING(DATA32,U_Sca2CH8,vme0.Sca2.data[7],U.Sca[1].CH[7]);
SIGNAL_MAPPING(DATA32,U_Sca2CH9,vme0.Sca2.data[8],U.Sca[1].CH[8]);
SIGNAL_MAPPING(DATA32,U_Sca3CH1,vme0.Sca3.data[0],U.Sca[2].CH[0]);
SIGNAL_MAPPING(DATA32,U_Sca3CH10,vme0.Sca3.data[9],U.Sca[2].CH[9]);
SIGNAL_MAPPING(DATA32,U_Sca3CH11,vme0.Sca3.data[10],U.Sca[2].CH[10]);
SIGNAL_MAPPING(DATA32,U_Sca3CH12,vme0.Sca3.data[11],U.Sca[2].CH[11]);
SIGNAL_MAPPING(DATA32,U_Sca3CH13,vme0.Sca3.data[12],U.Sca[2].CH[12]);
SIGNAL_MAPPING(DATA32,U_Sca3CH14,vme0.Sca3.data[13],U.Sca[2].CH[13]);
SIGNAL_MAPPING(DATA32,U_Sca3CH15,vme0.Sca3.data[14],U.Sca[2].CH[14]);
SIGNAL_MAPPING(DATA32,U_Sca3CH16,vme0.Sca3.data[15],U.Sca[2].CH[15]);
SIGNAL_MAPPING(DATA32,U_Sca3CH17,vme0.Sca3.data[16],U.Sca[2].CH[16]);
SIGNAL_MAPPING(DATA32,U_Sca3CH18,vme0.Sca3.data[17],U.Sca[2].CH[17]);
SIGNAL_MAPPING(DATA32,U_Sca3CH19,vme0.Sca3.data[18],U.Sca[2].CH[18]);
SIGNAL_MAPPING(DATA32,U_Sca3CH2,vme0.Sca3.data[1],U.Sca[2].CH[1]);
SIGNAL_MAPPING(DATA32,U_Sca3CH20,vme0.Sca3.data[19],U.Sca[2].CH[19]);
SIGNAL_MAPPING(DATA32,U_Sca3CH21,vme0.Sca3.data[20],U.Sca[2].CH[20]);
SIGNAL_MAPPING(DATA32,U_Sca3CH22,vme0.Sca3.data[21],U.Sca[2].CH[21]);
SIGNAL_MAPPING(DATA32,U_Sca3CH23,vme0.Sca3.data[22],U.Sca[2].CH[22]);
SIGNAL_MAPPING(DATA32,U_Sca3CH24,vme0.Sca3.data[23],U.Sca[2].CH[23]);
SIGNAL_MAPPING(DATA32,U_Sca3CH25,vme0.Sca3.data[24],U.Sca[2].CH[24]);
SIGNAL_MAPPING(DATA32,U_Sca3CH26,vme0.Sca3.data[25],U.Sca[2].CH[25]);
SIGNAL_MAPPING(DATA32,U_Sca3CH27,vme0.Sca3.data[26],U.Sca[2].CH[26]);
SIGNAL_MAPPING(DATA32,U_Sca3CH28,vme0.Sca3.data[27],U.Sca[2].CH[27]);
SIGNAL_MAPPING(DATA32,U_Sca3CH29,vme0.Sca3.data[28],U.Sca[2].CH[28]);
SIGNAL_MAPPING(DATA32,U_Sca3CH3,vme0.Sca3.data[2],U.Sca[2].CH[2]);
SIGNAL_MAPPING(DATA32,U_Sca3CH30,vme0.Sca3.data[29],U.Sca[2].CH[29]);
SIGNAL_MAPPING(DATA32,U_Sca3CH31,vme0.Sca3.data[30],U.Sca[2].CH[30]);
SIGNAL_MAPPING(DATA32,U_Sca3CH32,vme0.Sca3.data[31],U.Sca[2].CH[31]);
SIGNAL_MAPPING(DATA32,U_Sca3CH4,vme0.Sca3.data[3],U.Sca[2].CH[3]);
SIGNAL_MAPPING(DATA32,U_Sca3CH5,vme0.Sca3.data[4],U.Sca[2].CH[4]);
SIGNAL_MAPPING(DATA32,U_Sca3CH6,vme0.Sca3.data[5],U.Sca[2].CH[5]);
SIGNAL_MAPPING(DATA32,U_Sca3CH7,vme0.Sca3.data[6],U.Sca[2].CH[6]);
SIGNAL_MAPPING(DATA32,U_Sca3CH8,vme0.Sca3.data[7],U.Sca[2].CH[7]);
SIGNAL_MAPPING(DATA32,U_Sca3CH9,vme0.Sca3.data[8],U.Sca[2].CH[8]);
SIGNAL_MAPPING(DATA32,U_Sca4CH1,vme0.Sca4.data[0],U.Sca[3].CH[0]);
SIGNAL_MAPPING(DATA32,U_Sca4CH10,vme0.Sca4.data[9],U.Sca[3].CH[9]);
SIGNAL_MAPPING(DATA32,U_Sca4CH11,vme0.Sca4.data[10],U.Sca[3].CH[10]);
SIGNAL_MAPPING(DATA32,U_Sca4CH12,vme0.Sca4.data[11],U.Sca[3].CH[11]);
SIGNAL_MAPPING(DATA32,U_Sca4CH13,vme0.Sca4.data[12],U.Sca[3].CH[12]);
SIGNAL_MAPPING(DATA32,U_Sca4CH14,vme0.Sca4.data[13],U.Sca[3].CH[13]);
SIGNAL_MAPPING(DATA32,U_Sca4CH15,vme0.Sca4.data[14],U.Sca[3].CH[14]);
SIGNAL_MAPPING(DATA32,U_Sca4CH16,vme0.Sca4.data[15],U.Sca[3].CH[15]);
SIGNAL_MAPPING(DATA32,U_Sca4CH17,vme0.Sca4.data[16],U.Sca[3].CH[16]);
SIGNAL_MAPPING(DATA32,U_Sca4CH18,vme0.Sca4.data[17],U.Sca[3].CH[17]);
SIGNAL_MAPPING(DATA32,U_Sca4CH19,vme0.Sca4.data[18],U.Sca[3].CH[18]);
SIGNAL_MAPPING(DATA32,U_Sca4CH2,vme0.Sca4.data[1],U.Sca[3].CH[1]);
SIGNAL_MAPPING(DATA32,U_Sca4CH20,vme0.Sca4.data[19],U.Sca[3].CH[19]);
SIGNAL_MAPPING(DATA32,U_Sca4CH21,vme0.Sca4.data[20],U.Sca[3].CH[20]);
SIGNAL_MAPPING(DATA32,U_Sca4CH22,vme0.Sca4.data[21],U.Sca[3].CH[21]);
SIGNAL_MAPPING(DATA32,U_Sca4CH23,vme0.Sca4.data[22],U.Sca[3].CH[22]);
SIGNAL_MAPPING(DATA32,U_Sca4CH24,vme0.Sca4.data[23],U.Sca[3].CH[23]);
SIGNAL_MAPPING(DATA32,U_Sca4CH25,vme0.Sca4.data[24],U.Sca[3].CH[24]);
SIGNAL_MAPPING(DATA32,U_Sca4CH26,vme0.Sca4.data[25],U.Sca[3].CH[25]);
SIGNAL_MAPPING(DATA32,U_Sca4CH27,vme0.Sca4.data[26],U.Sca[3].CH[26]);
SIGNAL_MAPPING(DATA32,U_Sca4CH28,vme0.Sca4.data[27],U.Sca[3].CH[27]);
SIGNAL_MAPPING(DATA32,U_Sca4CH29,vme0.Sca4.data[28],U.Sca[3].CH[28]);
SIGNAL_MAPPING(DATA32,U_Sca4CH3,vme0.Sca4.data[2],U.Sca[3].CH[2]);
SIGNAL_MAPPING(DATA32,U_Sca4CH30,vme0.Sca4.data[29],U.Sca[3].CH[29]);
SIGNAL_MAPPING(DATA32,U_Sca4CH31,vme0.Sca4.data[30],U.Sca[3].CH[30]);
SIGNAL_MAPPING(DATA32,U_Sca4CH32,vme0.Sca4.data[31],U.Sca[3].CH[31]);
SIGNAL_MAPPING(DATA32,U_Sca4CH4,vme0.Sca4.data[3],U.Sca[3].CH[3]);
SIGNAL_MAPPING(DATA32,U_Sca4CH5,vme0.Sca4.data[4],U.Sca[3].CH[4]);
SIGNAL_MAPPING(DATA32,U_Sca4CH6,vme0.Sca4.data[5],U.Sca[3].CH[5]);
SIGNAL_MAPPING(DATA32,U_Sca4CH7,vme0.Sca4.data[6],U.Sca[3].CH[6]);
SIGNAL_MAPPING(DATA32,U_Sca4CH8,vme0.Sca4.data[7],U.Sca[3].CH[7]);
SIGNAL_MAPPING(DATA32,U_Sca4CH9,vme0.Sca4.data[8],U.Sca[3].CH[8]);
SIGNAL_MAPPING(DATA32,U_TDC1CH10_1,vme0.TDC1.data[9],U.TDC[0].CH[9][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH11_1,vme0.TDC1.data[10],U.TDC[0].CH[10][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH12_1,vme0.TDC1.data[11],U.TDC[0].CH[11][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH13_1,vme0.TDC1.data[12],U.TDC[0].CH[12][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH14_1,vme0.TDC1.data[13],U.TDC[0].CH[13][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH15_1,vme0.TDC1.data[14],U.TDC[0].CH[14][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH16_1,vme0.TDC1.data[15],U.TDC[0].CH[15][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH17_1,vme0.TDC1.data[16],U.TDC[0].CH[16][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH18_1,vme0.TDC1.data[17],U.TDC[0].CH[17][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH19_1,vme0.TDC1.data[18],U.TDC[0].CH[18][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH1_1,vme0.TDC1.data[0],U.TDC[0].CH[0][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH20_1,vme0.TDC1.data[19],U.TDC[0].CH[19][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH21_1,vme0.TDC1.data[20],U.TDC[0].CH[20][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH22_1,vme0.TDC1.data[21],U.TDC[0].CH[21][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH23_1,vme0.TDC1.data[22],U.TDC[0].CH[22][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH24_1,vme0.TDC1.data[23],U.TDC[0].CH[23][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH25_1,vme0.TDC1.data[24],U.TDC[0].CH[24][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH26_1,vme0.TDC1.data[25],U.TDC[0].CH[25][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH27_1,vme0.TDC1.data[26],U.TDC[0].CH[26][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH28_1,vme0.TDC1.data[27],U.TDC[0].CH[27][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH29_1,vme0.TDC1.data[28],U.TDC[0].CH[28][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH2_1,vme0.TDC1.data[1],U.TDC[0].CH[1][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH30_1,vme0.TDC1.data[29],U.TDC[0].CH[29][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH31_1,vme0.TDC1.data[30],U.TDC[0].CH[30][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH32_1,vme0.TDC1.data[31],U.TDC[0].CH[31][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH3_1,vme0.TDC1.data[2],U.TDC[0].CH[2][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH4_1,vme0.TDC1.data[3],U.TDC[0].CH[3][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH5_1,vme0.TDC1.data[4],U.TDC[0].CH[4][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH6_1,vme0.TDC1.data[5],U.TDC[0].CH[5][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH7_1,vme0.TDC1.data[6],U.TDC[0].CH[6][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH8_1,vme0.TDC1.data[7],U.TDC[0].CH[7][0]);
SIGNAL_MAPPING(DATA32,U_TDC1CH9_1,vme0.TDC1.data[8],U.TDC[0].CH[8][0]);
SIGNAL_MAPPING(DATA32,U_tsCH1,vme0.timestamp.ts[0],U.tsCH[0]);
SIGNAL_MAPPING(DATA32,U_tsCH2,vme0.timestamp.ts[1],U.tsCH[1]);
SIGNAL_MAPPING(DATA32,U_tsCH3,vme0.timestamp.ts[2],U.tsCH[2]);
SIGNAL_MAPPING(DATA32,U_tsCH4,vme0.timestamp.ts[3],U.tsCH[3]);
SIGNAL_MAPPING(DATA32,U_tsCH5,vme0.timestamp.ts[4],U.tsCH[4]);
SIGNAL_MAPPING(DATA32,U_tsCH6,vme0.timestamp.ts[5],U.tsCH[5]);
SIGNAL_MAPPING(DATA32,U_tsCH7,vme0.timestamp.ts[6],U.tsCH[6]);
SIGNAL_MAPPING(DATA32,U_tsCH8,vme0.timestamp.ts[7],U.tsCH[7]);

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gen_fzd_jan_2010/reparse.uce" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gen_fzd_jan_2010/reparse.uce" },
  { 8, 12, "gen_fzd_jan_2010/reparse.uce" },
  { 144, 156, "gen_fzd_jan_2010/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/

