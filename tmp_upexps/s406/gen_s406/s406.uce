
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

CAMAC_LECROY_2277_1CH_HACK(channel,edge,high_byte)
{
  MEMBER(DATA16 data[16] NO_INDEX_LIST);
  UINT32 ch_data NOENCODE
  {
     0_15: value;
       16: edge = CHECK(edge);
    17_21: channel = CHECK(channel);
    24_31: high = CHECK(high_byte);
    ENCODE(data APPEND_LIST,(value=value));
  }
}

CAMAC_LECROY_4434(channels)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    UINT32 ch_data NOENCODE
    {
       0_23: value;
      24_31: 0;
      ENCODE(data[index],(value=value));
    }
  }
}

CAMAC_PHILLIPS_7164(channels,mark_channel_no)
{
  MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    if(mark_channel_no)
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        12_15: channel = CHECK(index);
        ENCODE(data[index],(value=value));
      }
    }
    else
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        ENCODE(data[index],(value=value));
      }
    }
  }
}

CAMAC_SILENA_4418(channels,mark_channel_no)
{
  MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    if(mark_channel_no)
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        12_14: channel = CHECK(index);
           15: overflow;
        ENCODE(data[index],(value=value,overflow=overflow));
      }
    }
    else
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
           15: overflow;
        ENCODE(data[index],(value=value,overflow=overflow));
      }
    }
  }
}

CROS3_REWRITE(ccb_id)
{
  MEMBER(WIRE_START_END data[32768] ZERO_SUPPRESS);
  UINT32 h1
  {
     0_15: data_size;
       16: threshold_curve;
       17: leading_edge;
       18: data;
    20_23: trigger_time;
    24_27: ccb_id = MATCH(ccb_id);
    28_31: event_counter;
  }
  if(h1.data)
  {
    UINT32 h2
    {
       0_01: read_out_mode;
          4: pulser_enabled;
       8_10: statistics;
         11: both_edges;
      12_19: slices;
      20_21: scale;
         31: odd_length16;
    }
    if(h1.leading_edge)
    {
      list(0<=index<static_cast<uint32>((h1.data_size - h2.odd_length16)))
      {
        UINT32 ch_data NOENCODE
        {
           0_07: start_slice1;
           8_15: wire1;
          16_23: start_slice2;
          24_31: wire2;
          ENCODE(data[(index * 2)],(wire=wire1,start=start_slice1,stop=0));
          ENCODE(data[((index * 2) + 1)],(wire=wire2,start=start_slice2,
                                          stop=0));
        }
      }
      if(h2.odd_length16)
      {
        UINT32 ch_data_odd NOENCODE
        {
           0_07: start_slice1;
           8_15: wire1;
          16_23: start_slice2 = CHECK(255);
          24_31: wire2 = CHECK(0);
          ENCODE(data[((h1.data_size - 1) * 2)],(wire=wire1,start=start_slice1,
                                                 stop=0));
        }
      }
    }
    else
    {
      list(0<=index<h1.data_size)
      {
        UINT32 ch_data NOENCODE
        {
           0_07: start_slice;
           8_15: wire;
          16_23: end_slice;
          ENCODE(data[index],(wire=wire,start=start_slice,stop=end_slice));
        }
      }
    }
  }
  else
  {
    if(h1.threshold_curve)
    {
      UINT32 trc_h2
      {
         0_01: read_out_mode;
            4: pulser_enabled;
         8_10: statistics;
           11: both_edges;
        12_19: threshold_start;
        20_23: threshold_step;
        24_28: boards;
      }
      list(0<=board<trc_h2.boards)
      {
        UINT32 trc_h3 NOENCODE
        {
           0_07: test_pulser_even;
           8_15: test_pulser_odd;
          16_23: threshold_steps;
          28_31: ad_id;
        }
        list(0<=index_thr<trc_h3.threshold_steps)
        {
          list(0<=index_wire2<8)
          {
            UINT32 ch_counts NOENCODE
            {
               0_11: counts1;
              12_15: wire1;
              16_27: counts2;
              28_31: wire2;
            }
          }
        }
      }
    }
    else
    {
      UINT32 dummy_h2 NOENCODE
      {
         0_31: 0;
      }
    }
  }
}

DUMMY_WORD()
{
  UINT32 dummy_word;
}

external EXT_CROS3(ccb_id)
;

external EXT_SST(sam,gtb,siderem,branch)
;

FASTBUS_LECROY_1875(geom,channels)
{
  MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  UINT32 ch_data NOENCODE
  {
     0_11: value;
    16_21: channel = RANGE(0,(channels - 1));
       23: range;
    24_26: n = CHECK(0);
    27_31: geom = MATCH(geom);
    ENCODE(data[channel],(value=value,range=range));
  }
}

FASTBUS_LECROY_1885(geom,channels)
{
  MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  UINT32 ch_data NOENCODE
  {
     0_11: value;
    16_22: channel = RANGE(0,(channels - 1));
       23: range;
    24_26: n = CHECK(0);
    27_31: geom = MATCH(geom);
    ENCODE(data[channel],(value=value,range=range));
  }
}

LAND_STD_VME()
{
  UINT32 failure
  {
        0: fail_general;
        1: fail_data_corrupt;
        2: fail_data_missing;
        3: fail_data_too_much;
        4: fail_event_counter_mismatch;
        5: fail_readout_error_driver;
        6: fail_unexpected_trigger;
        7: fail_firmware_mismatch;
       22: has_multi_trlo_ii_counter0;
       23: has_clock_counter_stamp;
       24: has_continous_event_counter;
       25: has_update_qdc_iped_value;
       26: spurious_start_before_tcal;
       27: has_no_zero_suppression;
       28: has_multi_adctdc_counter0;
       29: has_multi_scaler_counter0;
       30: has_multi_event;
       31: has_time_stamp;
  }
  if(failure.has_continous_event_counter)
  {
    UINT32 continous_event_counter;
  }
  if(failure.has_time_stamp)
  {
    UINT32 time_stamp;
  }
  if(failure.has_clock_counter_stamp)
  {
    UINT32 clock_counter_stamp;
  }
  if(failure.has_update_qdc_iped_value)
  {
    UINT32 iped;
  }
  if(failure.has_multi_event)
  {
    UINT32 multi_events;
  }
  if(failure.has_multi_trlo_ii_counter0)
  {
    UINT32 multi_trlo_ii_counter0;
  }
  if(failure.has_multi_scaler_counter0)
  {
    UINT32 multi_scaler_counter0;
  }
  if(failure.has_multi_adctdc_counter0)
  {
    UINT32 multi_adctdc_counter0;
  }
}

NTP64_TIME()
{
  UINT32 sec;
  UINT32 frac;
}

NTP_MESSAGE(id)
{
  UINT32 header
  {
     0_15: word_count;
       16: quick_burst;
    24_31: id = MATCH(id);
  }
  MARK_COUNT(start);
  UINT32 server_id;
  UINT32 sspp
  {
     0_07: precision;
     8_15: poll;
    16_19: stratum;
    24_26: mode;
    27_29: version = CHECK(3);
    30_31: leap;
  }
  UINT32 root_dly
  {
     0_15: frac;
    16_31: sec;
  }
  UINT32 root_disp
  {
     0_15: frac;
    16_31: sec;
  }
  UINT32 refid;
  reftime = NTP64_TIME();
  origtime = NTP64_TIME();
  rectime = NTP64_TIME();
  tmittime = NTP64_TIME();
  rxtime = NTP64_TIME();
  if(header.quick_burst)
  {
    orig2time = NTP64_TIME();
    rec2time = NTP64_TIME();
    tmit2time = NTP64_TIME();
    rx2time = NTP64_TIME();
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_count,start,end,0,4)
}

RANDOM_TCAL(id)
{
  UINT32 header
  {
     0_07: word_count;
     8_11: pulses;
    12_17: clock_bits;
       18: has_tstamp1;
       19: has_tstamp2;
    24_31: id = MATCH(id);
  }
  MARK_COUNT(start);
  if(header.has_tstamp1)
  {
    tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
  }
  if(header.has_tstamp2)
  {
    tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_count,start,end,0,4)
}

RANDOM_TCAL_TSTAMP_CLOCK()
{
  UINT32 soft_latches;
  UINT32 hard_latches;
  UINT32 clock_ticks;
  before = NTP64_TIME();
  after = NTP64_TIME();
}

SIDEREM_BLOCK(sam,gtb,siderem)
{
  MEMBER(DATA12 data[4][512] ZERO_SUPPRESS);
  UINT32 header
  {
     0_11: count;
    12_15: local_event_counter;
    16_19: local_trigger;
    20_23: siderem = MATCH(siderem);
    24_27: gtb = MATCH(gtb);
    28_31: sam = MATCH(sam);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
      12_13: adc_no;
      16_24: channel;
      28_31: 15;
      ENCODE(data[adc_no][channel],(value=value));
    }
  }
}

SOFT_SCALER32(channels)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    UINT32 ch_data NOENCODE
    {
       0_31: value;
      ENCODE(data[index],(value=value));
    }
  }
}

TACQUILA_DATA(sam,gtb)
{
  MEMBER(DATA12 tac[30][17] ZERO_SUPPRESS);
  MEMBER(DATA12 adc[30][17] ZERO_SUPPRESS);
  MEMBER(DATA12 clk[30][17] ZERO_SUPPRESS);
  UINT32 header
  {
     0_08: count;
     9_11: dummy1;
    12_15: trigger_tac = RANGE(0,1);
    16_19: trigger_sam = RANGE(1,2);
    20_23: lec;
    24_27: gtb = MATCH(gtb);
    28_31: sam = MATCH(sam);
  }
  list(0<=index<header.count)
  {
    if(( ! (index & 1)))
    {
      UINT32 ch_data NOENCODE
      {
         0_11: tac_value;
        12_17: clock_cycle;
        18_19: dummy2;
           20: trigger;
           21: 0;
        22_26: channel = RANGE(0,16);
        27_31: module = RANGE(1,30);
        ENCODE(tac[(module - 1)][channel],(value=tac_value));
        ENCODE(clk[(module - 1)][channel],(value=clock_cycle));
      }
      UINT32 ch_data2 NOENCODE
      {
         0_11: adc_value;
        12_19: dummy3;
           20: trigger;
           21: 1;
        22_26: channel = RANGE(0,16);
        27_31: module = RANGE(1,30);
        ENCODE(adc[(module - 1)][channel],(value=adc_value));
      }
    }
  }
}

TRLO_SAMPLER(id)
{
  MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  UINT32 header
  {
     0_09: count;
    24_31: id = MATCH(id);
  }
  list(0<=index<header.count)
  {
    UINT32 data NOENCODE
    {
       0_31: stamp;
      ENCODE(stamps APPEND_LIST,(value=stamp));
    }
  }
}

VME_CAEN_V1190(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   data=data);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1190_SHORT(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         data=data);
    norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  UINT32 ch_data NOENCODE
  {
     0_18: value;
    19_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  }
}

VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
{
  UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
}

VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(tdc_start);
  UINT32 header
  {
     0_11: bunch_id;
    12_23: event_id = CHECK(event_id);
    24_25: tdc = MATCH(tdc);
    27_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_18: value;
    19_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  }
  optional UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
  MARK_COUNT(tdc_end);
  UINT32 trailer
  {
     0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    12_23: event_id = CHECK(header.event_id);
    24_25: tdc = CHECK(tdc);
    27_31: 3;
  }
}

VME_CAEN_V1290(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   data=data);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1290_SHORT(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         data=data);
    norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  UINT32 ch_data NOENCODE
  {
     0_20: value;
    21_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  }
}

VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
{
  UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
}

VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(tdc_start);
  UINT32 header
  {
     0_11: bunch_id;
    12_23: event_id = CHECK(event_id);
    24_25: tdc = MATCH(tdc);
    27_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_20: value;
    21_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  }
  optional UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
  MARK_COUNT(tdc_end);
  UINT32 trailer
  {
     0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    12_23: event_id = CHECK(header.event_id);
    24_25: tdc = CHECK(tdc);
    27_31: 3;
  }
}

VME_CAEN_V775(geom,crate)
{
  MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     8_13: count;
    16_23: crate = MATCH(crate);
    24_26: 2;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
         12: overflow;
         13: underflow;
         14: valid;
      16_20: channel;
      24_26: 0;
      27_31: geom = CHECK(geom);
      ENCODE(data[channel],(value=value,overflow=overflow));
    }
  }
  UINT32 eob
  {
     0_23: event_number;
    24_26: 4;
    27_31: geom = CHECK(geom);
  }
}

VME_CAEN_V830(geom)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 header
  {
     0_15: event_number;
    16_17: ts;
    18_23: count;
       26: 1;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_25: value;
         26: 0;
      27_31: channel;
      ENCODE(data[channel],(value=value));
    }
  }
}

VME_MESYTEC_MADC32(geom)
{
  MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_14: adc_resol;
       15: out_form;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_12: value;
       14: outofrange;
    16_20: channel;
    21_29: 32;
    30_31: 0;
    ENCODE(data[channel],(value=value,overflow=outofrange));
  }
  optional UINT32 filler NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

VME_MESYTEC_MDPP16(geom)
{
  MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_09: word_number;
    10_12: adc_res;
    13_15: tdc_res;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_15: value;
    16_21: channel;
       22: overflow;
       23: pileup;
    24_27: 0;
    28_31: 1;
    ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  }
  several UINT32 fill_word NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

VME_VUPROM_V35()
{
  MEMBER(DATA12 data[192] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_08: word_number;
        9: raw_marker;
    10_15: 0;
    16_23: geom;
    24_31: 254;
  }
  list(0<=index<header.word_number)
  {
    UINT32 ch_data NOENCODE
    {
       0_09: value;
      10_15: 0;
      16_23: channel;
      24_31: geom;
      ENCODE(data[channel],(value=value));
    }
  }
}

SUBEVENT(CB_VME_LEFT)
{
  vme = LAND_STD_VME();
  select several
  {
    adc[0] = VME_MESYTEC_MADC32(geom=0);
    adc[1] = VME_MESYTEC_MADC32(geom=1);
    adc[2] = VME_MESYTEC_MADC32(geom=2);
    adc[3] = VME_MESYTEC_MADC32(geom=3);
    madc0_psp = VME_MESYTEC_MADC32(geom=4);
    tdc = VME_VUPROM_V35();
  }
}

SUBEVENT(CB_VME_RIGHT)
{
  vme = LAND_STD_VME();
  select several
  {
    adc[0] = VME_MESYTEC_MADC32(geom=0);
    adc[1] = VME_MESYTEC_MADC32(geom=1);
    adc[2] = VME_MESYTEC_MADC32(geom=2);
    adc[3] = VME_MESYTEC_MADC32(geom=3);
    tdc = VME_VUPROM_V35();
  }
}

SUBEVENT(CROS3_REWRITE_SUBEVENT)
{
  select several
  {
    norevisit ccb[0] = CROS3_REWRITE(ccb_id=1);
    norevisit ccb[1] = CROS3_REWRITE(ccb_id=2);
  }
}

SUBEVENT(CROS3_SUBEVENT)
{
  select several
  {
    external norevisit ccb[0] = EXT_CROS3(ccb_id=1);
    external norevisit ccb[1] = EXT_CROS3(ccb_id=2);
  }
}

SUBEVENT(DUMMY)
{
  select several
  {
    d = DUMMY_WORD();
  }
}

SUBEVENT(LAND_CAMAC_CONVERTER)
{
  UINT16 tpat;
  UINT16 tprev;
  UINT16 tnext;
  UINT16 tprev2;
  if(EXTERNAL has_data)
  {
    ;
  }
}

SUBEVENT(LAND_CAMAC_PILEUP)
{
  select several
  {
    tdc = CAMAC_LECROY_2277_1CH_HACK(channel=0,edge=1,high_byte=0);
    tcal = CAMAC_LECROY_2277_1CH_HACK(channel=1,edge=1,high_byte=0);
  }
}

SUBEVENT(LAND_CAMAC_SCALER)
{
  scaler0 = CAMAC_LECROY_4434(channels=32);
  scaler1 = CAMAC_LECROY_4434(channels=32);
  scaler2 = CAMAC_LECROY_4434(channels=32);
  scaler3 = SOFT_SCALER32(channels=16);
  if(EXTERNAL has_timestamp)
  {
    UINT32 timestamp;
    UINT32 endianess
    {
       0_31: 0x87654321;
    }
  }
}

SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
{
  UINT32 timestamp;
  UINT32 endianess
  {
     0_31: 0x87654321;
  }
}

SUBEVENT(LAND_CAMAC_TCAL_INFO)
{
  UINT32 info;
  select several
  {
    rtcal = RANDOM_TCAL(id=231);
    ntp = NTP_MESSAGE(id=239);
  }
}

SUBEVENT(MASTER_VME)
{
  vme = LAND_STD_VME();
  select several
  {
    sampler_pos = TRLO_SAMPLER(id=223);
    sampler_cb_sum = TRLO_SAMPLER(id=215);
  }
}

SUBEVENT(SIDEREM01_VME)
{
  select several
  {
    external sst[0] = EXT_SST(siderem=1,gtb=0,sam=5,branch=1);
    external sst[1] = EXT_SST(siderem=2,gtb=0,sam=5,branch=1);
    external sst[2] = EXT_SST(siderem=1,gtb=1,sam=5,branch=1);
    external sst[3] = EXT_SST(siderem=2,gtb=1,sam=5,branch=1);
    external sst[4] = EXT_SST(siderem=1,gtb=0,sam=6,branch=1);
    external sst[5] = EXT_SST(siderem=2,gtb=0,sam=6,branch=1);
    external sst[6] = EXT_SST(siderem=1,gtb=1,sam=6,branch=1);
    external sst[7] = EXT_SST(siderem=2,gtb=1,sam=6,branch=1);
  }
  optional UINT32 error_marker
  {
     0_31: 0x89abdcef;
  }
  optional UINT32 error_marker2
  {
     0_31: 0x89abcdef;
  }
}

SUBEVENT(TACQUILA_LAND_SUBEVENT)
{
  select several
  {
    data_sam5_gtb0 = TACQUILA_DATA(sam=5,gtb=0);
    data_sam6_gtb0 = TACQUILA_DATA(sam=6,gtb=0);
    data_sam6_gtb1 = TACQUILA_DATA(sam=6,gtb=1);
  }
}

SUBEVENT(TACQUILA_NEULAND_SUBEVENT)
{
  select several
  {
    data_sam7_gtb0 = TACQUILA_DATA(sam=7,gtb=0);
    data_sam7_gtb1 = TACQUILA_DATA(sam=7,gtb=1);
  }
}

SUBEVENT(VME_CRATE1)
{
  vme = LAND_STD_VME();
  select several
  {
    qdc792POS_ROLU = VME_CAEN_V775(geom=31,crate=1);
    tdc775POS_ROLU = VME_CAEN_V775(geom=31,crate=130);
    qdc792PIXEL = VME_CAEN_V775(geom=31,crate=3);
    scaler = VME_CAEN_V830(geom=0);
  }
}

SUBEVENT(VME_CRATE2)
{
  vme = LAND_STD_VME();
  select several
  {
    qdc792TFW1 = VME_CAEN_V775(geom=31,crate=1);
    qdc792TFW2 = VME_CAEN_V775(geom=31,crate=2);
    tdc775TFW1 = VME_CAEN_V775(geom=31,crate=131);
    tdc775TFW2 = VME_CAEN_V775(geom=31,crate=132);
    tdc775NTF = VME_CAEN_V775(geom=31,crate=6);
    qdc792NTF = VME_CAEN_V775(geom=31,crate=133);
    qdc792GFI1 = VME_CAEN_V775(geom=31,crate=7);
    qdc792GFI2 = VME_CAEN_V775(geom=31,crate=8);
    qdc792GFI3 = VME_CAEN_V775(geom=31,crate=9);
    qdc792MFITEST = VME_CAEN_V775(geom=31,crate=10);
    scaler = VME_CAEN_V830(geom=0);
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  cros3 = CROS3_SUBEVENT(type=85,subtype=0x2134);
  cros3_rewrite = CROS3_REWRITE_SUBEVENT(type=85,subtype=0x213e);
  sst = SIDEREM01_VME(type=82,subtype=0x2008,control=3);
  camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  acq = DUMMY(type=35,subtype=0xc1c);
  vme1 = VME_CRATE1(type=88,subtype=0x2260,control=5,subcrate=1);
  vme2 = VME_CRATE2(type=88,subtype=0x2260,control=5,subcrate=2);
  vme_cbr = CB_VME_RIGHT(type=88,subtype=0x2260,control=5,subcrate=3);
  vme_cbl = CB_VME_LEFT(type=88,subtype=0x2260,control=5,subcrate=4);
  vme_master = MASTER_VME(type=88,subtype=0x2260,subcrate=6);
  camac_tcal_info = LAND_CAMAC_TCAL_INFO(type=0x26ce,subtype=0xc7f);
  camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  pileup = LAND_CAMAC_PILEUP(type=34,subtype=0xdac,control=1);
  tacquila = TACQUILA_LAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=0);
  neuland = TACQUILA_NEULAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=1);
  ignore_unknown_subevent;
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(CXB001_1_T,vme2.tdc775TFW1.data[9],DATA12);
SIGNAL(CXB002_1_T,vme2.tdc775TFW1.data[10],DATA12);
SIGNAL(CXB003_1_T,vme2.tdc775TFW1.data[11],DATA12);
SIGNAL(CXB004_1_T,vme2.tdc775TFW1.data[12],DATA12);
SIGNAL(CXB005_1_T,vme2.tdc775TFW1.data[13],DATA12);
SIGNAL(CXB006_1_T,vme2.tdc775TFW1.data[14],DATA12);
SIGNAL(CXB007_1_E,vme_cbr.adc[1].data[4],DATA14_OVERFLOW);
SIGNAL(CXB007_1_T,vme_cbr.tdc.data[68],DATA12);
SIGNAL(DTF01_1_E,vme2.qdc792TFW1.data[17],DATA12);
SIGNAL(DTF01_1_T,vme2.tdc775TFW2.data[17],DATA12);
SIGNAL(DTF01_2_E,vme2.qdc792TFW2.data[17],DATA12);
SIGNAL(DTF01_2_T,vme2.tdc775TFW2.data[25],DATA12);
SIGNAL(DTF02_1_E,vme2.qdc792TFW1.data[18],DATA12);
SIGNAL(DTF02_1_T,vme2.tdc775TFW2.data[18],DATA12);
SIGNAL(DTF02_2_E,vme2.qdc792TFW2.data[18],DATA12);
SIGNAL(DTF02_2_T,vme2.tdc775TFW2.data[26],DATA12);
SIGNAL(DTF03_1_E,vme2.qdc792TFW1.data[19],DATA12);
SIGNAL(DTF03_1_T,vme2.tdc775TFW2.data[19],DATA12);
SIGNAL(DTF03_2_E,vme2.qdc792TFW2.data[19],DATA12);
SIGNAL(DTF03_2_T,vme2.tdc775TFW2.data[27],DATA12);
SIGNAL(DTF04_1_E,vme2.qdc792TFW1.data[20],DATA12);
SIGNAL(DTF04_1_T,vme2.tdc775TFW2.data[20],DATA12);
SIGNAL(DTF04_2_E,vme2.qdc792TFW2.data[20],DATA12);
SIGNAL(DTF04_2_T,vme2.tdc775TFW2.data[28],DATA12);
SIGNAL(DTF05_1_E,vme2.qdc792TFW1.data[21],DATA12);
SIGNAL(DTF05_1_T,vme2.tdc775TFW2.data[21],DATA12);
SIGNAL(DTF05_2_E,vme2.qdc792TFW2.data[21],DATA12);
SIGNAL(DTF05_2_T,vme2.tdc775TFW2.data[29],DATA12);
SIGNAL(DTF06_1_E,vme2.qdc792TFW1.data[22],DATA12);
SIGNAL(DTF06_1_T,vme2.tdc775TFW2.data[22],DATA12);
SIGNAL(DTF06_2_E,vme2.qdc792TFW2.data[22],DATA12);
SIGNAL(DTF06_2_T,vme2.tdc775TFW2.data[30],DATA12);
SIGNAL(DTF07_1_E,vme2.qdc792TFW1.data[16],DATA12);
SIGNAL(DTF07_1_T,vme2.tdc775TFW2.data[16],DATA12);
SIGNAL(DTF07_2_E,vme2.qdc792TFW1.data[23],DATA12);
SIGNAL(DTF07_2_T,vme2.tdc775TFW2.data[23],DATA12);
SIGNAL(DTF08_1_E,vme2.qdc792TFW2.data[16],DATA12);
SIGNAL(DTF08_1_T,vme2.tdc775TFW2.data[24],DATA12);
SIGNAL(DTF08_2_E,vme2.qdc792TFW2.data[23],DATA12);
SIGNAL(DTF08_2_T,vme2.tdc775TFW2.data[31],DATA12);
SIGNAL(GFI01_01_E,vme2.qdc792GFI1.data[0],DATA12);
SIGNAL(GFI01_02_E,vme2.qdc792GFI1.data[1],DATA12);
SIGNAL(GFI01_03_E,vme2.qdc792GFI1.data[2],DATA12);
SIGNAL(GFI01_04_E,vme2.qdc792GFI1.data[3],DATA12);
SIGNAL(GFI01_05_E,vme2.qdc792GFI1.data[4],DATA12);
SIGNAL(GFI01_06_E,vme2.qdc792GFI3.data[15],DATA12);
SIGNAL(GFI01_07_E,vme2.qdc792GFI1.data[6],DATA12);
SIGNAL(GFI01_08_E,vme2.qdc792GFI1.data[7],DATA12);
SIGNAL(GFI01_09_E,vme2.qdc792GFI1.data[8],DATA12);
SIGNAL(GFI01_10_E,vme2.qdc792GFI1.data[9],DATA12);
SIGNAL(GFI01_11_E,vme2.qdc792GFI1.data[10],DATA12);
SIGNAL(GFI01_12_E,vme2.qdc792GFI1.data[11],DATA12);
SIGNAL(GFI01_13_E,vme2.qdc792GFI1.data[12],DATA12);
SIGNAL(GFI01_14_E,vme2.qdc792GFI1.data[13],DATA12);
SIGNAL(GFI01_15_E,vme2.qdc792GFI1.data[14],DATA12);
SIGNAL(GFI01_16_E,vme2.qdc792GFI1.data[15],DATA12);
SIGNAL(GFI01_17_E,vme2.qdc792GFI3.data[4],DATA12);
SIGNAL(GFI01_18_E,vme2.qdc792GFI1.data[17],DATA12);
SIGNAL(GFI01_19_E,vme2.qdc792GFI1.data[18],DATA12);
SIGNAL(GFI01_20_E,vme2.qdc792GFI1.data[19],DATA12);
SIGNAL(GFI01_21_E,vme2.qdc792GFI1.data[20],DATA12);
SIGNAL(GFI01_22_E,vme2.qdc792GFI1.data[21],DATA12);
SIGNAL(GFI01_23_E,vme2.qdc792GFI1.data[22],DATA12);
SIGNAL(GFI01_24_E,vme2.qdc792GFI1.data[23],DATA12);
SIGNAL(GFI01_25_E,vme2.qdc792GFI1.data[24],DATA12);
SIGNAL(GFI01_26_E,vme2.qdc792GFI1.data[25],DATA12);
SIGNAL(GFI01_27_E,vme2.qdc792GFI1.data[26],DATA12);
SIGNAL(GFI01_28_E,vme2.qdc792GFI1.data[27],DATA12);
SIGNAL(GFI01_29_E,vme2.qdc792GFI1.data[28],DATA12);
SIGNAL(GFI01_30_E,vme2.qdc792GFI1.data[29],DATA12);
SIGNAL(GFI01_31_E,vme2.qdc792GFI1.data[30],DATA12);
SIGNAL(GFI01_32_E,vme2.qdc792GFI1.data[31],DATA12);
SIGNAL(GFI01_33_E,vme2.qdc792GFI3.data[0],DATA12);
SIGNAL(GFI01_34_E,vme2.qdc792GFI3.data[1],DATA12);
SIGNAL(GFI02_01_E,vme2.qdc792GFI2.data[5],DATA12);
SIGNAL(GFI02_02_E,vme2.qdc792GFI3.data[5],DATA12);
SIGNAL(GFI02_03_E,vme2.qdc792GFI2.data[2],DATA12);
SIGNAL(GFI02_04_E,vme2.qdc792GFI2.data[3],DATA12);
SIGNAL(GFI02_05_E,vme2.qdc792GFI2.data[4],DATA12);
SIGNAL(GFI02_06_E,vme2.qdc792GFI3.data[6],DATA12);
SIGNAL(GFI02_07_E,vme2.qdc792GFI3.data[7],DATA12);
SIGNAL(GFI02_08_E,vme2.qdc792GFI3.data[8],DATA12);
SIGNAL(GFI02_09_E,vme2.qdc792GFI3.data[9],DATA12);
SIGNAL(GFI02_10_E,vme2.qdc792GFI3.data[10],DATA12);
SIGNAL(GFI02_11_E,vme2.qdc792GFI3.data[12],DATA12);
SIGNAL(GFI02_12_E,vme2.qdc792GFI2.data[11],DATA12);
SIGNAL(GFI02_13_E,vme2.qdc792GFI2.data[12],DATA12);
SIGNAL(GFI02_14_E,vme2.qdc792GFI3.data[14],DATA12);
SIGNAL(GFI02_15_E,vme2.qdc792GFI2.data[14],DATA12);
SIGNAL(GFI02_16_E,vme2.qdc792GFI2.data[15],DATA12);
SIGNAL(GFI02_17_E,vme2.qdc792GFI2.data[16],DATA12);
SIGNAL(GFI02_18_E,vme2.qdc792GFI2.data[17],DATA12);
SIGNAL(GFI02_19_E,vme2.qdc792GFI2.data[18],DATA12);
SIGNAL(GFI02_20_E,vme2.qdc792GFI2.data[19],DATA12);
SIGNAL(GFI02_21_E,vme2.qdc792GFI2.data[20],DATA12);
SIGNAL(GFI02_22_E,vme2.qdc792GFI2.data[21],DATA12);
SIGNAL(GFI02_23_E,vme2.qdc792GFI2.data[22],DATA12);
SIGNAL(GFI02_24_E,vme2.qdc792GFI2.data[23],DATA12);
SIGNAL(GFI02_25_E,vme2.qdc792GFI2.data[24],DATA12);
SIGNAL(GFI02_26_E,vme2.qdc792GFI2.data[25],DATA12);
SIGNAL(GFI02_27_E,vme2.qdc792GFI2.data[26],DATA12);
SIGNAL(GFI02_28_E,vme2.qdc792GFI2.data[27],DATA12);
SIGNAL(GFI02_29_E,vme2.qdc792GFI2.data[28],DATA12);
SIGNAL(GFI02_30_E,vme2.qdc792GFI2.data[29],DATA12);
SIGNAL(GFI02_31_E,vme2.qdc792GFI2.data[30],DATA12);
SIGNAL(GFI02_32_E,vme2.qdc792GFI2.data[31],DATA12);
SIGNAL(GFI02_33_E,vme2.qdc792GFI3.data[2],DATA12);
SIGNAL(GFI02_34_E,vme2.qdc792GFI3.data[3],DATA12);
SIGNAL(NTF01_1_E,vme2.qdc792NTF.data[0],DATA12);
SIGNAL(NTF01_1_T,vme2.tdc775NTF.data[0],DATA12);
SIGNAL(NTF01_2_E,vme2.qdc792NTF.data[1],DATA12);
SIGNAL(NTF01_2_T,vme2.tdc775NTF.data[1],DATA12);
SIGNAL(NTF02_1_E,vme2.qdc792NTF.data[2],DATA12);
SIGNAL(NTF02_1_T,vme2.tdc775NTF.data[2],DATA12);
SIGNAL(NTF02_2_E,vme2.qdc792NTF.data[3],DATA12);
SIGNAL(NTF02_2_T,vme2.tdc775NTF.data[3],DATA12);
SIGNAL(NTF03_1_E,vme2.qdc792NTF.data[4],DATA12);
SIGNAL(NTF03_1_T,vme2.tdc775NTF.data[4],DATA12);
SIGNAL(NTF03_2_E,vme2.qdc792NTF.data[5],DATA12);
SIGNAL(NTF03_2_T,vme2.tdc775NTF.data[5],DATA12);
SIGNAL(NTF04_1_E,vme2.qdc792NTF.data[6],DATA12);
SIGNAL(NTF04_1_T,vme2.tdc775NTF.data[6],DATA12);
SIGNAL(NTF04_2_E,vme2.qdc792NTF.data[7],DATA12);
SIGNAL(NTF04_2_T,vme2.tdc775NTF.data[7],DATA12);
SIGNAL(NTF05_1_E,vme2.qdc792NTF.data[8],DATA12);
SIGNAL(NTF05_1_T,vme2.tdc775NTF.data[8],DATA12);
SIGNAL(NTF05_2_E,vme2.qdc792NTF.data[9],DATA12);
SIGNAL(NTF05_2_T,vme2.tdc775NTF.data[9],DATA12);
SIGNAL(NTF06_1_E,vme2.qdc792NTF.data[10],DATA12);
SIGNAL(NTF06_1_T,vme2.tdc775NTF.data[10],DATA12);
SIGNAL(NTF06_2_E,vme2.qdc792NTF.data[11],DATA12);
SIGNAL(NTF06_2_T,vme2.tdc775NTF.data[11],DATA12);
SIGNAL(NTF07_1_E,vme2.qdc792NTF.data[12],DATA12);
SIGNAL(NTF07_1_T,vme2.tdc775NTF.data[12],DATA12);
SIGNAL(NTF07_2_E,vme2.qdc792NTF.data[13],DATA12);
SIGNAL(NTF07_2_T,vme2.tdc775NTF.data[13],DATA12);
SIGNAL(NTF08_1_E,vme2.qdc792NTF.data[14],DATA12);
SIGNAL(NTF08_1_T,vme2.tdc775NTF.data[14],DATA12);
SIGNAL(NTF08_2_E,vme2.qdc792NTF.data[15],DATA12);
SIGNAL(NTF08_2_T,vme2.tdc775NTF.data[15],DATA12);
SIGNAL(NTF09_1_E,vme2.qdc792NTF.data[16],DATA12);
SIGNAL(NTF09_1_T,vme2.tdc775NTF.data[16],DATA12);
SIGNAL(NTF09_2_E,vme2.qdc792NTF.data[17],DATA12);
SIGNAL(NTF09_2_T,vme2.tdc775NTF.data[17],DATA12);
SIGNAL(NTF10_1_E,vme2.qdc792NTF.data[18],DATA12);
SIGNAL(NTF10_1_T,vme2.tdc775NTF.data[18],DATA12);
SIGNAL(NTF10_2_E,vme2.qdc792NTF.data[19],DATA12);
SIGNAL(NTF10_2_T,vme2.tdc775NTF.data[19],DATA12);
SIGNAL(NTF11_1_E,vme2.qdc792NTF.data[20],DATA12);
SIGNAL(NTF11_1_T,vme2.tdc775NTF.data[20],DATA12);
SIGNAL(NTF11_2_E,vme2.qdc792NTF.data[21],DATA12);
SIGNAL(NTF11_2_T,vme2.tdc775NTF.data[21],DATA12);
SIGNAL(NTF12_1_E,vme2.qdc792NTF.data[22],DATA12);
SIGNAL(NTF12_1_T,vme2.tdc775NTF.data[22],DATA12);
SIGNAL(NTF12_2_E,vme2.qdc792NTF.data[23],DATA12);
SIGNAL(NTF12_2_T,vme2.tdc775NTF.data[23],DATA12);
SIGNAL(NTF13_1_E,vme2.qdc792NTF.data[24],DATA12);
SIGNAL(NTF13_1_T,vme2.tdc775NTF.data[24],DATA12);
SIGNAL(NTF13_2_E,vme2.qdc792NTF.data[25],DATA12);
SIGNAL(NTF13_2_T,vme2.tdc775NTF.data[25],DATA12);
SIGNAL(NTF14_1_E,vme2.qdc792NTF.data[26],DATA12);
SIGNAL(NTF14_1_T,vme2.tdc775NTF.data[26],DATA12);
SIGNAL(NTF14_2_E,vme2.qdc792NTF.data[27],DATA12);
SIGNAL(NTF14_2_T,vme2.tdc775NTF.data[27],DATA12);
SIGNAL(NTF15_1_E,vme2.qdc792NTF.data[28],DATA12);
SIGNAL(NTF15_1_T,vme2.tdc775NTF.data[28],DATA12);
SIGNAL(NTF15_2_E,vme2.qdc792NTF.data[29],DATA12);
SIGNAL(NTF15_2_T,vme2.tdc775NTF.data[29],DATA12);
SIGNAL(NTF16_1_E,vme2.qdc792NTF.data[30],DATA12);
SIGNAL(NTF16_1_T,vme2.tdc775NTF.data[30],DATA12);
SIGNAL(NTF16_2_E,vme2.qdc792NTF.data[31],DATA12);
SIGNAL(NTF16_2_T,vme2.tdc775NTF.data[31],DATA12);
SIGNAL(PILEUP_1_T,pileup.tdc.data,DATA16);
SIGNAL(POS01_01_E,vme1.qdc792POS_ROLU.data[0],DATA12);
SIGNAL(POS01_01_T,vme1.tdc775POS_ROLU.data[0],DATA12);
SIGNAL(POS01_02_E,vme1.qdc792POS_ROLU.data[1],DATA12);
SIGNAL(POS01_02_T,vme1.tdc775POS_ROLU.data[1],DATA12);
SIGNAL(POS01_03_E,vme1.qdc792POS_ROLU.data[2],DATA12);
SIGNAL(POS01_03_T,vme1.tdc775POS_ROLU.data[2],DATA12);
SIGNAL(POS01_04_E,vme1.qdc792POS_ROLU.data[3],DATA12);
SIGNAL(POS01_04_T,vme1.tdc775POS_ROLU.data[3],DATA12);
SIGNAL(PSP01_01_E,vme_cbl.madc0_psp.data[0],DATA14_OVERFLOW);
SIGNAL(PSP01_02_E,vme_cbl.madc0_psp.data[1],DATA14_OVERFLOW);
SIGNAL(PSP01_03_E,vme_cbl.madc0_psp.data[2],DATA14_OVERFLOW);
SIGNAL(PSP01_04_E,vme_cbl.madc0_psp.data[3],DATA14_OVERFLOW);
SIGNAL(PSP01_05_E,vme_cbl.madc0_psp.data[12],DATA14_OVERFLOW);
SIGNAL(ROL01_01_E,vme1.qdc792POS_ROLU.data[4],DATA12);
SIGNAL(ROL01_02_E,vme1.qdc792POS_ROLU.data[5],DATA12);
SIGNAL(ROL01_03_E,vme1.qdc792POS_ROLU.data[6],DATA12);
SIGNAL(ROL01_04_E,vme1.qdc792POS_ROLU.data[7],DATA12);
SIGNAL(SCI02_01_E,vme1.qdc792POS_ROLU.data[9],DATA12);
SIGNAL(SCI02_01_T,vme1.tdc775POS_ROLU.data[14],DATA12);
SIGNAL(SCI02_02_E,vme1.qdc792POS_ROLU.data[8],DATA12);
SIGNAL(SCI02_02_T,vme1.tdc775POS_ROLU.data[12],DATA12);
SIGNAL(TCALMT_1_T,pileup.tcal.data,DATA16);
SIGNAL(XB001_1_E,vme_cbr.adc[2].data[18],DATA14_OVERFLOW);
SIGNAL(XB001_1_T,vme_cbr.tdc.data[50],DATA12);
SIGNAL(XB002_1_E,vme_cbr.adc[2].data[16],DATA14_OVERFLOW);
SIGNAL(XB002_1_T,vme_cbr.tdc.data[48],DATA12);
SIGNAL(XB003_1_E,vme_cbr.adc[2].data[4],DATA14_OVERFLOW);
SIGNAL(XB003_1_T,vme_cbr.tdc.data[36],DATA12);
SIGNAL(XB003_2_E,vme_cbr.adc[0].data[28],DATA14_OVERFLOW);
SIGNAL(XB003_2_T,vme_cbr.tdc.data[124],DATA12);
SIGNAL(XB004_1_E,vme_cbr.adc[2].data[5],DATA14_OVERFLOW);
SIGNAL(XB004_1_T,vme_cbr.tdc.data[37],DATA12);
SIGNAL(XB004_2_E,vme_cbr.adc[0].data[12],DATA14_OVERFLOW);
SIGNAL(XB004_2_T,vme_cbr.tdc.data[108],DATA12);
SIGNAL(XB005_1_E,vme_cbr.adc[2].data[17],DATA14_OVERFLOW);
SIGNAL(XB005_1_T,vme_cbr.tdc.data[49],DATA12);
SIGNAL(XB006_1_E,vme_cbr.adc[2].data[26],DATA14_OVERFLOW);
SIGNAL(XB006_1_T,vme_cbr.tdc.data[58],DATA12);
SIGNAL(XB007_1_E,vme_cbr.adc[2].data[27],DATA14_OVERFLOW);
SIGNAL(XB007_1_T,vme_cbr.tdc.data[59],DATA12);
SIGNAL(XB008_1_E,vme_cbr.adc[2].data[24],DATA14_OVERFLOW);
SIGNAL(XB008_1_T,vme_cbr.tdc.data[56],DATA12);
SIGNAL(XB009_1_E,vme_cbr.adc[2].data[14],DATA14_OVERFLOW);
SIGNAL(XB009_1_T,vme_cbr.tdc.data[46],DATA12);
SIGNAL(XB010_1_E,vme_cbr.adc[2].data[6],DATA14_OVERFLOW);
SIGNAL(XB010_1_T,vme_cbr.tdc.data[38],DATA12);
SIGNAL(XB010_2_E,vme_cbr.adc[0].data[20],DATA14_OVERFLOW);
SIGNAL(XB010_2_T,vme_cbr.tdc.data[116],DATA12);
SIGNAL(XB011_1_E,vme_cbr.adc[1].data[26],DATA14_OVERFLOW);
SIGNAL(XB011_1_T,vme_cbr.tdc.data[90],DATA12);
SIGNAL(XB011_2_E,vme_cbr.adc[0].data[31],DATA14_OVERFLOW);
SIGNAL(XB011_2_T,vme_cbr.tdc.data[127],DATA12);
SIGNAL(XB012_1_E,vme_cbr.adc[1].data[25],DATA14_OVERFLOW);
SIGNAL(XB012_1_T,vme_cbr.tdc.data[89],DATA12);
SIGNAL(XB012_2_E,vme_cbr.adc[0].data[8],DATA14_OVERFLOW);
SIGNAL(XB012_2_T,vme_cbr.tdc.data[104],DATA12);
SIGNAL(XB013_1_E,vme_cbr.adc[1].data[27],DATA14_OVERFLOW);
SIGNAL(XB013_1_T,vme_cbr.tdc.data[91],DATA12);
SIGNAL(XB013_2_E,vme_cbr.adc[0].data[15],DATA14_OVERFLOW);
SIGNAL(XB013_2_T,vme_cbr.tdc.data[111],DATA12);
SIGNAL(XB014_1_E,vme_cbr.adc[2].data[7],DATA14_OVERFLOW);
SIGNAL(XB014_1_T,vme_cbr.tdc.data[39],DATA12);
SIGNAL(XB014_2_E,vme_cbr.adc[0].data[9],DATA14_OVERFLOW);
SIGNAL(XB014_2_T,vme_cbr.tdc.data[105],DATA12);
SIGNAL(XB015_1_E,vme_cbr.adc[2].data[15],DATA14_OVERFLOW);
SIGNAL(XB015_1_T,vme_cbr.tdc.data[47],DATA12);
SIGNAL(XB016_1_E,vme_cbr.adc[2].data[25],DATA14_OVERFLOW);
SIGNAL(XB016_1_T,vme_cbr.tdc.data[57],DATA12);
SIGNAL(XB017_1_E,vme_cbr.adc[3].data[4],DATA14_OVERFLOW);
SIGNAL(XB017_1_T,vme_cbr.tdc.data[4],DATA12);
SIGNAL(XB018_1_E,vme_cbr.adc[3].data[6],DATA14_OVERFLOW);
SIGNAL(XB018_1_T,vme_cbr.tdc.data[6],DATA12);
SIGNAL(XB019_1_E,vme_cbr.adc[3].data[5],DATA14_OVERFLOW);
SIGNAL(XB019_1_T,vme_cbr.tdc.data[5],DATA12);
SIGNAL(XB020_1_E,vme_cbr.adc[3].data[2],DATA14_OVERFLOW);
SIGNAL(XB020_1_T,vme_cbr.tdc.data[2],DATA12);
SIGNAL(XB021_1_E,vme_cbr.adc[2].data[22],DATA14_OVERFLOW);
SIGNAL(XB021_1_T,vme_cbr.tdc.data[54],DATA12);
SIGNAL(XB022_1_E,vme_cbr.adc[2].data[8],DATA14_OVERFLOW);
SIGNAL(XB022_1_T,vme_cbr.tdc.data[40],DATA12);
SIGNAL(XB023_1_E,vme_cbr.adc[1].data[28],DATA14_OVERFLOW);
SIGNAL(XB023_1_T,vme_cbr.tdc.data[92],DATA12);
SIGNAL(XB023_2_E,vme_cbr.adc[0].data[29],DATA14_OVERFLOW);
SIGNAL(XB023_2_T,vme_cbr.tdc.data[125],DATA12);
SIGNAL(XB024_1_E,vme_cbr.adc[1].data[16],DATA14_OVERFLOW);
SIGNAL(XB024_1_T,vme_cbr.tdc.data[80],DATA12);
SIGNAL(XB024_2_E,vme_cbr.adc[0].data[16],DATA14_OVERFLOW);
SIGNAL(XB024_2_T,vme_cbr.tdc.data[112],DATA12);
SIGNAL(XB025_1_E,vme_cbr.adc[1].data[12],DATA14_OVERFLOW);
SIGNAL(XB025_1_T,vme_cbr.tdc.data[76],DATA12);
SIGNAL(XB025_2_E,vme_cbr.adc[0].data[26],DATA14_OVERFLOW);
SIGNAL(XB025_2_T,vme_cbr.tdc.data[122],DATA12);
SIGNAL(XB026_1_E,vme_cbr.adc[1].data[13],DATA14_OVERFLOW);
SIGNAL(XB026_1_T,vme_cbr.tdc.data[77],DATA12);
SIGNAL(XB026_2_E,vme_cbr.adc[0].data[5],DATA14_OVERFLOW);
SIGNAL(XB026_2_T,vme_cbr.tdc.data[101],DATA12);
SIGNAL(XB027_1_E,vme_cbr.adc[1].data[18],DATA14_OVERFLOW);
SIGNAL(XB027_1_T,vme_cbr.tdc.data[82],DATA12);
SIGNAL(XB027_2_E,vme_cbr.adc[0].data[0],DATA14_OVERFLOW);
SIGNAL(XB027_2_T,vme_cbr.tdc.data[96],DATA12);
SIGNAL(XB028_1_E,vme_cbr.adc[1].data[29],DATA14_OVERFLOW);
SIGNAL(XB028_1_T,vme_cbr.tdc.data[93],DATA12);
SIGNAL(XB028_2_E,vme_cbr.adc[0].data[3],DATA14_OVERFLOW);
SIGNAL(XB028_2_T,vme_cbr.tdc.data[99],DATA12);
SIGNAL(XB029_1_E,vme_cbr.adc[2].data[9],DATA14_OVERFLOW);
SIGNAL(XB029_1_T,vme_cbr.tdc.data[41],DATA12);
SIGNAL(XB030_1_E,vme_cbr.adc[2].data[23],DATA14_OVERFLOW);
SIGNAL(XB030_1_T,vme_cbr.tdc.data[55],DATA12);
SIGNAL(XB031_1_E,vme_cbr.adc[3].data[3],DATA14_OVERFLOW);
SIGNAL(XB031_1_T,vme_cbr.tdc.data[3],DATA12);
SIGNAL(XB032_1_E,vme_cbr.adc[3].data[12],DATA14_OVERFLOW);
SIGNAL(XB032_1_T,vme_cbr.tdc.data[12],DATA12);
SIGNAL(XB033_1_E,vme_cbr.adc[3].data[16],DATA14_OVERFLOW);
SIGNAL(XB033_1_T,vme_cbr.tdc.data[16],DATA12);
SIGNAL(XB034_1_E,vme_cbr.adc[3].data[17],DATA14_OVERFLOW);
SIGNAL(XB034_1_T,vme_cbr.tdc.data[17],DATA12);
SIGNAL(XB035_1_E,vme_cbr.adc[3].data[13],DATA14_OVERFLOW);
SIGNAL(XB035_1_T,vme_cbr.tdc.data[13],DATA12);
SIGNAL(XB036_1_E,vme_cbr.adc[3].data[8],DATA14_OVERFLOW);
SIGNAL(XB036_1_T,vme_cbr.tdc.data[8],DATA12);
SIGNAL(XB037_1_E,vme_cbr.adc[2].data[29],DATA14_OVERFLOW);
SIGNAL(XB037_1_T,vme_cbr.tdc.data[61],DATA12);
SIGNAL(XB038_1_E,vme_cbr.adc[2].data[12],DATA14_OVERFLOW);
SIGNAL(XB038_1_T,vme_cbr.tdc.data[44],DATA12);
SIGNAL(XB039_1_E,vme_cbr.adc[2].data[0],DATA14_OVERFLOW);
SIGNAL(XB039_1_T,vme_cbr.tdc.data[32],DATA12);
SIGNAL(XB039_2_E,vme_cbr.adc[0].data[27],DATA14_OVERFLOW);
SIGNAL(XB039_2_T,vme_cbr.tdc.data[123],DATA12);
SIGNAL(XB040_1_E,vme_cbr.adc[1].data[20],DATA14_OVERFLOW);
SIGNAL(XB040_1_T,vme_cbr.tdc.data[84],DATA12);
SIGNAL(XB040_2_E,vme_cbr.adc[0].data[23],DATA14_OVERFLOW);
SIGNAL(XB040_2_T,vme_cbr.tdc.data[119],DATA12);
SIGNAL(XB041_1_E,vme_cbr.adc[1].data[5],DATA14_OVERFLOW);
SIGNAL(XB041_1_T,vme_cbr.tdc.data[69],DATA12);
SIGNAL(XB041_2_E,vme_cbr.adc[0].data[22],DATA14_OVERFLOW);
SIGNAL(XB041_2_T,vme_cbr.tdc.data[118],DATA12);
SIGNAL(XB042_1_E,vme_cbr.adc[1].data[7],DATA14_OVERFLOW);
SIGNAL(XB042_1_T,vme_cbr.tdc.data[71],DATA12);
SIGNAL(XB042_2_E,vme_cbr.adc[0].data[11],DATA14_OVERFLOW);
SIGNAL(XB042_2_T,vme_cbr.tdc.data[107],DATA12);
SIGNAL(XB043_1_E,vme_cbr.adc[1].data[6],DATA14_OVERFLOW);
SIGNAL(XB043_1_T,vme_cbr.tdc.data[70],DATA12);
SIGNAL(XB043_2_E,vme_cbr.adc[0].data[7],DATA14_OVERFLOW);
SIGNAL(XB043_2_T,vme_cbr.tdc.data[103],DATA12);
SIGNAL(XB044_1_E,vme_cbr.adc[1].data[21],DATA14_OVERFLOW);
SIGNAL(XB044_1_T,vme_cbr.tdc.data[85],DATA12);
SIGNAL(XB044_2_E,vme_cbr.adc[0].data[6],DATA14_OVERFLOW);
SIGNAL(XB044_2_T,vme_cbr.tdc.data[102],DATA12);
SIGNAL(XB045_1_E,vme_cbr.adc[2].data[1],DATA14_OVERFLOW);
SIGNAL(XB045_1_T,vme_cbr.tdc.data[33],DATA12);
SIGNAL(XB045_2_E,vme_cbr.adc[0].data[10],DATA14_OVERFLOW);
SIGNAL(XB045_2_T,vme_cbr.tdc.data[106],DATA12);
SIGNAL(XB046_1_E,vme_cbr.adc[2].data[13],DATA14_OVERFLOW);
SIGNAL(XB046_1_T,vme_cbr.tdc.data[45],DATA12);
SIGNAL(XB047_1_E,vme_cbr.adc[2].data[30],DATA14_OVERFLOW);
SIGNAL(XB047_1_T,vme_cbr.tdc.data[62],DATA12);
SIGNAL(XB048_1_E,vme_cbr.adc[3].data[9],DATA14_OVERFLOW);
SIGNAL(XB048_1_T,vme_cbr.tdc.data[9],DATA12);
SIGNAL(XB049_1_E,vme_cbr.adc[3].data[25],DATA14_OVERFLOW);
SIGNAL(XB049_1_T,vme_cbr.tdc.data[25],DATA12);
SIGNAL(XB050_1_E,vme_cbr.adc[3].data[24],DATA14_OVERFLOW);
SIGNAL(XB050_1_T,vme_cbr.tdc.data[24],DATA12);
SIGNAL(XB051_1_E,vme_cbr.adc[3].data[26],DATA14_OVERFLOW);
SIGNAL(XB051_1_T,vme_cbr.tdc.data[26],DATA12);
SIGNAL(XB052_1_E,vme_cbr.adc[3].data[20],DATA14_OVERFLOW);
SIGNAL(XB052_1_T,vme_cbr.tdc.data[20],DATA12);
SIGNAL(XB053_1_E,vme_cbr.adc[3].data[14],DATA14_OVERFLOW);
SIGNAL(XB053_1_T,vme_cbr.tdc.data[14],DATA12);
SIGNAL(XB054_1_E,vme_cbr.adc[3].data[0],DATA14_OVERFLOW);
SIGNAL(XB054_1_T,vme_cbr.tdc.data[0],DATA12);
SIGNAL(XB055_1_E,vme_cbr.adc[2].data[20],DATA14_OVERFLOW);
SIGNAL(XB055_1_T,vme_cbr.tdc.data[52],DATA12);
SIGNAL(XB056_1_E,vme_cbr.adc[2].data[10],DATA14_OVERFLOW);
SIGNAL(XB056_1_T,vme_cbr.tdc.data[42],DATA12);
SIGNAL(XB057_1_E,vme_cbr.adc[1].data[30],DATA14_OVERFLOW);
SIGNAL(XB057_1_T,vme_cbr.tdc.data[94],DATA12);
SIGNAL(XB057_2_E,vme_cbr.adc[0].data[21],DATA14_OVERFLOW);
SIGNAL(XB057_2_T,vme_cbr.tdc.data[117],DATA12);
SIGNAL(XB058_1_E,vme_cbr.adc[1].data[14],DATA14_OVERFLOW);
SIGNAL(XB058_1_T,vme_cbr.tdc.data[78],DATA12);
SIGNAL(XB058_2_E,vme_cbr.adc[0].data[30],DATA14_OVERFLOW);
SIGNAL(XB058_2_T,vme_cbr.tdc.data[126],DATA12);
SIGNAL(XB059_1_E,vme_cbr.adc[1].data[8],DATA14_OVERFLOW);
SIGNAL(XB059_1_T,vme_cbr.tdc.data[72],DATA12);
SIGNAL(XB059_2_E,vme_cbr.adc[0].data[25],DATA14_OVERFLOW);
SIGNAL(XB059_2_T,vme_cbr.tdc.data[121],DATA12);
SIGNAL(XB060_1_E,vme_cbr.adc[1].data[1],DATA14_OVERFLOW);
SIGNAL(XB060_1_T,vme_cbr.tdc.data[65],DATA12);
SIGNAL(XB060_2_E,vme_cbr.adc[0].data[19],DATA14_OVERFLOW);
SIGNAL(XB060_2_T,vme_cbr.tdc.data[115],DATA12);
SIGNAL(XB061_1_E,vme_cbr.adc[1].data[0],DATA14_OVERFLOW);
SIGNAL(XB061_1_T,vme_cbr.tdc.data[64],DATA12);
SIGNAL(XB061_2_E,vme_cbr.adc[0].data[1],DATA14_OVERFLOW);
SIGNAL(XB061_2_T,vme_cbr.tdc.data[97],DATA12);
SIGNAL(XB062_1_E,vme_cbr.adc[1].data[2],DATA14_OVERFLOW);
SIGNAL(XB062_1_T,vme_cbr.tdc.data[66],DATA12);
SIGNAL(XB062_2_E,vme_cbr.adc[0].data[4],DATA14_OVERFLOW);
SIGNAL(XB062_2_T,vme_cbr.tdc.data[100],DATA12);
SIGNAL(XB063_1_E,vme_cbr.adc[1].data[9],DATA14_OVERFLOW);
SIGNAL(XB063_1_T,vme_cbr.tdc.data[73],DATA12);
SIGNAL(XB063_2_E,vme_cbr.adc[0].data[13],DATA14_OVERFLOW);
SIGNAL(XB063_2_T,vme_cbr.tdc.data[109],DATA12);
SIGNAL(XB064_1_E,vme_cbr.adc[1].data[15],DATA14_OVERFLOW);
SIGNAL(XB064_1_T,vme_cbr.tdc.data[79],DATA12);
SIGNAL(XB064_2_E,vme_cbr.adc[0].data[2],DATA14_OVERFLOW);
SIGNAL(XB064_2_T,vme_cbr.tdc.data[98],DATA12);
SIGNAL(XB065_1_E,vme_cbr.adc[1].data[31],DATA14_OVERFLOW);
SIGNAL(XB065_1_T,vme_cbr.tdc.data[95],DATA12);
SIGNAL(XB065_2_E,vme_cbr.adc[0].data[14],DATA14_OVERFLOW);
SIGNAL(XB065_2_T,vme_cbr.tdc.data[110],DATA12);
SIGNAL(XB066_1_E,vme_cbr.adc[2].data[11],DATA14_OVERFLOW);
SIGNAL(XB066_1_T,vme_cbr.tdc.data[43],DATA12);
SIGNAL(XB067_1_E,vme_cbr.adc[2].data[21],DATA14_OVERFLOW);
SIGNAL(XB067_1_T,vme_cbr.tdc.data[53],DATA12);
SIGNAL(XB068_1_E,vme_cbr.adc[3].data[1],DATA14_OVERFLOW);
SIGNAL(XB068_1_T,vme_cbr.tdc.data[1],DATA12);
SIGNAL(XB069_1_E,vme_cbr.adc[3].data[15],DATA14_OVERFLOW);
SIGNAL(XB069_1_T,vme_cbr.tdc.data[15],DATA12);
SIGNAL(XB070_1_E,vme_cbr.adc[3].data[21],DATA14_OVERFLOW);
SIGNAL(XB070_1_T,vme_cbr.tdc.data[21],DATA12);
SIGNAL(XB071_1_E,vme_cbr.adc[3].data[28],DATA14_OVERFLOW);
SIGNAL(XB071_1_T,vme_cbr.tdc.data[28],DATA12);
SIGNAL(XB072_1_E,vme_cbr.adc[3].data[30],DATA14_OVERFLOW);
SIGNAL(XB072_1_T,vme_cbr.tdc.data[30],DATA12);
SIGNAL(XB073_1_E,vme_cbr.adc[3].data[29],DATA14_OVERFLOW);
SIGNAL(XB073_1_T,vme_cbr.tdc.data[29],DATA12);
SIGNAL(XB074_1_E,vme_cbr.adc[3].data[27],DATA14_OVERFLOW);
SIGNAL(XB074_1_T,vme_cbr.tdc.data[27],DATA12);
SIGNAL(XB075_1_E,vme_cbr.adc[3].data[7],DATA14_OVERFLOW);
SIGNAL(XB075_1_T,vme_cbr.tdc.data[7],DATA12);
SIGNAL(XB076_1_E,vme_cbr.adc[2].data[28],DATA14_OVERFLOW);
SIGNAL(XB076_1_T,vme_cbr.tdc.data[60],DATA12);
SIGNAL(XB078_1_E,vme_cbr.adc[2].data[2],DATA14_OVERFLOW);
SIGNAL(XB078_1_T,vme_cbr.tdc.data[34],DATA12);
SIGNAL(XB078_2_E,vme_cbr.adc[0].data[18],DATA14_OVERFLOW);
SIGNAL(XB078_2_T,vme_cbr.tdc.data[114],DATA12);
SIGNAL(XB079_1_E,vme_cbr.adc[1].data[24],DATA14_OVERFLOW);
SIGNAL(XB079_1_T,vme_cbr.tdc.data[88],DATA12);
SIGNAL(XB079_2_E,vme_cbr.adc[0].data[24],DATA14_OVERFLOW);
SIGNAL(XB079_2_T,vme_cbr.tdc.data[120],DATA12);
SIGNAL(XB080_2_E,vme_cbr.adc[0].data[17],DATA14_OVERFLOW);
SIGNAL(XB080_2_T,vme_cbr.tdc.data[113],DATA12);
SIGNAL(XB083_1_E,vme_cbl.adc[0].data[26],DATA14_OVERFLOW);
SIGNAL(XB083_1_T,vme_cbl.tdc.data[106],DATA12);
SIGNAL(XB084_1_E,vme_cbl.adc[0].data[7],DATA14_OVERFLOW);
SIGNAL(XB084_1_T,vme_cbl.tdc.data[119],DATA12);
SIGNAL(XB085_1_E,vme_cbl.adc[1].data[28],DATA14_OVERFLOW);
SIGNAL(XB085_1_T,vme_cbl.tdc.data[76],DATA12);
SIGNAL(XB086_1_E,vme_cbl.adc[1].data[18],DATA14_OVERFLOW);
SIGNAL(XB086_1_T,vme_cbl.tdc.data[66],DATA12);
SIGNAL(XB087_1_E,vme_cbl.adc[1].data[2],DATA14_OVERFLOW);
SIGNAL(XB087_1_T,vme_cbl.tdc.data[82],DATA12);
SIGNAL(XB087_2_E,vme_cbl.adc[3].data[22],DATA14_OVERFLOW);
SIGNAL(XB087_2_T,vme_cbl.tdc.data[6],DATA12);
SIGNAL(XB088_1_E,vme_cbl.adc[2].data[24],DATA14_OVERFLOW);
SIGNAL(XB088_1_T,vme_cbl.tdc.data[40],DATA12);
SIGNAL(XB088_2_E,vme_cbl.adc[3].data[29],DATA14_OVERFLOW);
SIGNAL(XB088_2_T,vme_cbl.tdc.data[13],DATA12);
SIGNAL(XB089_1_E,vme_cbl.adc[2].data[4],DATA14_OVERFLOW);
SIGNAL(XB089_1_T,vme_cbl.tdc.data[52],DATA12);
SIGNAL(XB089_2_E,vme_cbl.adc[3].data[23],DATA14_OVERFLOW);
SIGNAL(XB089_2_T,vme_cbl.tdc.data[7],DATA12);
SIGNAL(XB090_1_E,vme_cbl.adc[2].data[1],DATA14_OVERFLOW);
SIGNAL(XB090_1_T,vme_cbl.tdc.data[49],DATA12);
SIGNAL(XB090_2_E,vme_cbl.adc[3].data[18],DATA14_OVERFLOW);
SIGNAL(XB090_2_T,vme_cbl.tdc.data[2],DATA12);
SIGNAL(XB091_1_E,vme_cbl.adc[2].data[0],DATA14_OVERFLOW);
SIGNAL(XB091_1_T,vme_cbl.tdc.data[48],DATA12);
SIGNAL(XB091_2_E,vme_cbl.adc[3].data[11],DATA14_OVERFLOW);
SIGNAL(XB091_2_T,vme_cbl.tdc.data[27],DATA12);
SIGNAL(XB092_1_E,vme_cbl.adc[2].data[2],DATA14_OVERFLOW);
SIGNAL(XB092_1_T,vme_cbl.tdc.data[50],DATA12);
SIGNAL(XB092_2_E,vme_cbl.adc[3].data[4],DATA14_OVERFLOW);
SIGNAL(XB092_2_T,vme_cbl.tdc.data[20],DATA12);
SIGNAL(XB093_1_E,vme_cbl.adc[2].data[8],DATA14_OVERFLOW);
SIGNAL(XB093_1_T,vme_cbl.tdc.data[56],DATA12);
SIGNAL(XB093_2_E,vme_cbl.adc[3].data[9],DATA14_OVERFLOW);
SIGNAL(XB093_2_T,vme_cbl.tdc.data[25],DATA12);
SIGNAL(XB094_1_E,vme_cbl.adc[2].data[14],DATA14_OVERFLOW);
SIGNAL(XB094_1_T,vme_cbl.tdc.data[62],DATA12);
SIGNAL(XB094_2_E,vme_cbl.adc[3].data[14],DATA14_OVERFLOW);
SIGNAL(XB094_2_T,vme_cbl.tdc.data[30],DATA12);
SIGNAL(XB095_1_E,vme_cbl.adc[2].data[30],DATA14_OVERFLOW);
SIGNAL(XB095_1_T,vme_cbl.tdc.data[46],DATA12);
SIGNAL(XB095_2_E,vme_cbl.adc[3].data[1],DATA14_OVERFLOW);
SIGNAL(XB095_2_T,vme_cbl.tdc.data[17],DATA12);
SIGNAL(XB096_1_E,vme_cbl.adc[1].data[10],DATA14_OVERFLOW);
SIGNAL(XB096_1_T,vme_cbl.tdc.data[90],DATA12);
SIGNAL(XB097_1_E,vme_cbl.adc[1].data[20],DATA14_OVERFLOW);
SIGNAL(XB097_1_T,vme_cbl.tdc.data[68],DATA12);
SIGNAL(XB098_1_E,vme_cbl.adc[0].data[0],DATA14_OVERFLOW);
SIGNAL(XB098_1_T,vme_cbl.tdc.data[112],DATA12);
SIGNAL(XB099_1_E,vme_cbl.adc[0].data[14],DATA14_OVERFLOW);
SIGNAL(XB099_1_T,vme_cbl.tdc.data[126],DATA12);
SIGNAL(XB100_1_E,vme_cbl.adc[0].data[20],DATA14_OVERFLOW);
SIGNAL(XB100_1_T,vme_cbl.tdc.data[100],DATA12);
SIGNAL(XB101_1_E,vme_cbl.adc[0].data[28],DATA14_OVERFLOW);
SIGNAL(XB101_1_T,vme_cbl.tdc.data[108],DATA12);
SIGNAL(XB102_1_E,vme_cbl.adc[0].data[30],DATA14_OVERFLOW);
SIGNAL(XB102_1_T,vme_cbl.tdc.data[110],DATA12);
SIGNAL(XB103_1_E,vme_cbl.adc[0].data[29],DATA14_OVERFLOW);
SIGNAL(XB103_1_T,vme_cbl.tdc.data[109],DATA12);
SIGNAL(XB104_1_E,vme_cbl.adc[0].data[21],DATA14_OVERFLOW);
SIGNAL(XB104_1_T,vme_cbl.tdc.data[101],DATA12);
SIGNAL(XB105_1_E,vme_cbl.adc[0].data[15],DATA14_OVERFLOW);
SIGNAL(XB105_1_T,vme_cbl.tdc.data[127],DATA12);
SIGNAL(XB106_1_E,vme_cbl.adc[0].data[1],DATA14_OVERFLOW);
SIGNAL(XB106_1_T,vme_cbl.tdc.data[113],DATA12);
SIGNAL(XB107_1_E,vme_cbl.adc[1].data[21],DATA14_OVERFLOW);
SIGNAL(XB107_1_T,vme_cbl.tdc.data[69],DATA12);
SIGNAL(XB108_1_E,vme_cbl.adc[1].data[11],DATA14_OVERFLOW);
SIGNAL(XB108_1_T,vme_cbl.tdc.data[91],DATA12);
SIGNAL(XB109_1_E,vme_cbl.adc[2].data[31],DATA14_OVERFLOW);
SIGNAL(XB109_1_T,vme_cbl.tdc.data[47],DATA12);
SIGNAL(XB109_2_E,vme_cbl.adc[3].data[25],DATA14_OVERFLOW);
SIGNAL(XB109_2_T,vme_cbl.tdc.data[9],DATA12);
SIGNAL(XB110_1_E,vme_cbl.adc[2].data[15],DATA14_OVERFLOW);
SIGNAL(XB110_1_T,vme_cbl.tdc.data[63],DATA12);
SIGNAL(XB110_2_E,vme_cbl.adc[3].data[19],DATA14_OVERFLOW);
SIGNAL(XB110_2_T,vme_cbl.tdc.data[3],DATA12);
SIGNAL(XB111_1_E,vme_cbl.adc[2].data[9],DATA14_OVERFLOW);
SIGNAL(XB111_1_T,vme_cbl.tdc.data[57],DATA12);
SIGNAL(XB111_2_E,vme_cbl.adc[3].data[28],DATA14_OVERFLOW);
SIGNAL(XB111_2_T,vme_cbl.tdc.data[12],DATA12);
SIGNAL(XB112_1_E,vme_cbl.adc[2].data[5],DATA14_OVERFLOW);
SIGNAL(XB112_1_T,vme_cbl.tdc.data[53],DATA12);
SIGNAL(XB112_2_E,vme_cbl.adc[3].data[20],DATA14_OVERFLOW);
SIGNAL(XB112_2_T,vme_cbl.tdc.data[4],DATA12);
SIGNAL(XB113_1_E,vme_cbl.adc[2].data[7],DATA14_OVERFLOW);
SIGNAL(XB113_1_T,vme_cbl.tdc.data[55],DATA12);
SIGNAL(XB113_2_E,vme_cbl.adc[3].data[3],DATA14_OVERFLOW);
SIGNAL(XB113_2_T,vme_cbl.tdc.data[19],DATA12);
SIGNAL(XB114_1_E,vme_cbl.adc[2].data[6],DATA14_OVERFLOW);
SIGNAL(XB114_1_T,vme_cbl.tdc.data[54],DATA12);
SIGNAL(XB114_2_E,vme_cbl.adc[3].data[13],DATA14_OVERFLOW);
SIGNAL(XB114_2_T,vme_cbl.tdc.data[29],DATA12);
SIGNAL(XB115_1_E,vme_cbl.adc[2].data[20],DATA14_OVERFLOW);
SIGNAL(XB115_1_T,vme_cbl.tdc.data[36],DATA12);
SIGNAL(XB115_2_E,vme_cbl.adc[3].data[12],DATA14_OVERFLOW);
SIGNAL(XB115_2_T,vme_cbl.tdc.data[28],DATA12);
SIGNAL(XB116_1_E,vme_cbl.adc[1].data[0],DATA14_OVERFLOW);
SIGNAL(XB116_1_T,vme_cbl.tdc.data[80],DATA12);
SIGNAL(XB116_2_E,vme_cbl.adc[3].data[7],DATA14_OVERFLOW);
SIGNAL(XB116_2_T,vme_cbl.tdc.data[23],DATA12);
SIGNAL(XB117_1_E,vme_cbl.adc[1].data[12],DATA14_OVERFLOW);
SIGNAL(XB117_1_T,vme_cbl.tdc.data[92],DATA12);
SIGNAL(XB118_1_E,vme_cbl.adc[1].data[29],DATA14_OVERFLOW);
SIGNAL(XB118_1_T,vme_cbl.tdc.data[77],DATA12);
SIGNAL(XB119_1_E,vme_cbl.adc[0].data[8],DATA14_OVERFLOW);
SIGNAL(XB119_1_T,vme_cbl.tdc.data[120],DATA12);
SIGNAL(XB120_1_E,vme_cbl.adc[0].data[25],DATA14_OVERFLOW);
SIGNAL(XB120_1_T,vme_cbl.tdc.data[105],DATA12);
SIGNAL(XB121_1_E,vme_cbl.adc[0].data[24],DATA14_OVERFLOW);
SIGNAL(XB121_1_T,vme_cbl.tdc.data[104],DATA12);
SIGNAL(XB122_1_E,vme_cbl.adc[0].data[27],DATA14_OVERFLOW);
SIGNAL(XB122_1_T,vme_cbl.tdc.data[107],DATA12);
SIGNAL(XB123_1_E,vme_cbl.adc[0].data[9],DATA14_OVERFLOW);
SIGNAL(XB123_1_T,vme_cbl.tdc.data[121],DATA12);
SIGNAL(XB124_1_E,vme_cbl.adc[1].data[30],DATA14_OVERFLOW);
SIGNAL(XB124_1_T,vme_cbl.tdc.data[78],DATA12);
SIGNAL(XB125_1_E,vme_cbl.adc[1].data[13],DATA14_OVERFLOW);
SIGNAL(XB125_1_T,vme_cbl.tdc.data[93],DATA12);
SIGNAL(XB126_1_E,vme_cbl.adc[1].data[1],DATA14_OVERFLOW);
SIGNAL(XB126_1_T,vme_cbl.tdc.data[81],DATA12);
SIGNAL(XB126_2_E,vme_cbl.adc[3].data[21],DATA14_OVERFLOW);
SIGNAL(XB126_2_T,vme_cbl.tdc.data[5],DATA12);
SIGNAL(XB127_1_E,vme_cbl.adc[2].data[21],DATA14_OVERFLOW);
SIGNAL(XB127_1_T,vme_cbl.tdc.data[37],DATA12);
SIGNAL(XB127_2_E,vme_cbl.adc[3].data[16],DATA14_OVERFLOW);
SIGNAL(XB127_2_T,vme_cbl.tdc.data[0],DATA12);
SIGNAL(XB128_1_E,vme_cbl.adc[2].data[16],DATA14_OVERFLOW);
SIGNAL(XB128_1_T,vme_cbl.tdc.data[32],DATA12);
SIGNAL(XB128_2_E,vme_cbl.adc[3].data[26],DATA14_OVERFLOW);
SIGNAL(XB128_2_T,vme_cbl.tdc.data[10],DATA12);
SIGNAL(XB129_1_E,vme_cbl.adc[2].data[12],DATA14_OVERFLOW);
SIGNAL(XB129_1_T,vme_cbl.tdc.data[60],DATA12);
SIGNAL(XB129_2_E,vme_cbl.adc[3].data[17],DATA14_OVERFLOW);
SIGNAL(XB129_2_T,vme_cbl.tdc.data[1],DATA12);
SIGNAL(XB130_1_E,vme_cbl.adc[2].data[13],DATA14_OVERFLOW);
SIGNAL(XB130_1_T,vme_cbl.tdc.data[61],DATA12);
SIGNAL(XB130_2_E,vme_cbl.adc[3].data[6],DATA14_OVERFLOW);
SIGNAL(XB130_2_T,vme_cbl.tdc.data[22],DATA12);
SIGNAL(XB131_1_E,vme_cbl.adc[2].data[17],DATA14_OVERFLOW);
SIGNAL(XB131_1_T,vme_cbl.tdc.data[33],DATA12);
SIGNAL(XB131_2_E,vme_cbl.adc[3].data[0],DATA14_OVERFLOW);
SIGNAL(XB131_2_T,vme_cbl.tdc.data[16],DATA12);
SIGNAL(XB132_1_E,vme_cbl.adc[2].data[28],DATA14_OVERFLOW);
SIGNAL(XB132_1_T,vme_cbl.tdc.data[44],DATA12);
SIGNAL(XB132_2_E,vme_cbl.adc[3].data[15],DATA14_OVERFLOW);
SIGNAL(XB132_2_T,vme_cbl.tdc.data[31],DATA12);
SIGNAL(XB133_1_E,vme_cbl.adc[1].data[8],DATA14_OVERFLOW);
SIGNAL(XB133_1_T,vme_cbl.tdc.data[88],DATA12);
SIGNAL(XB134_1_E,vme_cbl.adc[1].data[22],DATA14_OVERFLOW);
SIGNAL(XB134_1_T,vme_cbl.tdc.data[70],DATA12);
SIGNAL(XB135_1_E,vme_cbl.adc[0].data[2],DATA14_OVERFLOW);
SIGNAL(XB135_1_T,vme_cbl.tdc.data[114],DATA12);
SIGNAL(XB136_1_E,vme_cbl.adc[0].data[12],DATA14_OVERFLOW);
SIGNAL(XB136_1_T,vme_cbl.tdc.data[124],DATA12);
SIGNAL(XB137_1_E,vme_cbl.adc[0].data[16],DATA14_OVERFLOW);
SIGNAL(XB137_1_T,vme_cbl.tdc.data[96],DATA12);
SIGNAL(XB138_1_E,vme_cbl.adc[0].data[17],DATA14_OVERFLOW);
SIGNAL(XB138_1_T,vme_cbl.tdc.data[97],DATA12);
SIGNAL(XB139_1_E,vme_cbl.adc[0].data[13],DATA14_OVERFLOW);
SIGNAL(XB139_1_T,vme_cbl.tdc.data[125],DATA12);
SIGNAL(XB140_1_E,vme_cbl.adc[0].data[3],DATA14_OVERFLOW);
SIGNAL(XB140_1_T,vme_cbl.tdc.data[115],DATA12);
SIGNAL(XB141_1_E,vme_cbl.adc[1].data[23],DATA14_OVERFLOW);
SIGNAL(XB141_1_T,vme_cbl.tdc.data[71],DATA12);
SIGNAL(XB142_1_E,vme_cbl.adc[1].data[9],DATA14_OVERFLOW);
SIGNAL(XB142_1_T,vme_cbl.tdc.data[89],DATA12);
SIGNAL(XB143_1_E,vme_cbl.adc[2].data[29],DATA14_OVERFLOW);
SIGNAL(XB143_1_T,vme_cbl.tdc.data[45],DATA12);
SIGNAL(XB143_2_E,vme_cbl.adc[3].data[31],DATA14_OVERFLOW);
SIGNAL(XB143_2_T,vme_cbl.tdc.data[15],DATA12);
SIGNAL(XB144_1_E,vme_cbl.adc[2].data[26],DATA14_OVERFLOW);
SIGNAL(XB144_1_T,vme_cbl.tdc.data[42],DATA12);
SIGNAL(XB144_2_E,vme_cbl.adc[3].data[24],DATA14_OVERFLOW);
SIGNAL(XB144_2_T,vme_cbl.tdc.data[8],DATA12);
SIGNAL(XB145_1_E,vme_cbl.adc[2].data[25],DATA14_OVERFLOW);
SIGNAL(XB145_1_T,vme_cbl.tdc.data[41],DATA12);
SIGNAL(XB145_2_E,vme_cbl.adc[3].data[2],DATA14_OVERFLOW);
SIGNAL(XB145_2_T,vme_cbl.tdc.data[18],DATA12);
SIGNAL(XB146_1_E,vme_cbl.adc[2].data[27],DATA14_OVERFLOW);
SIGNAL(XB146_1_T,vme_cbl.tdc.data[43],DATA12);
SIGNAL(XB146_2_E,vme_cbl.adc[3].data[10],DATA14_OVERFLOW);
SIGNAL(XB146_2_T,vme_cbl.tdc.data[26],DATA12);
SIGNAL(XB147_1_E,vme_cbl.adc[1].data[6],DATA14_OVERFLOW);
SIGNAL(XB147_1_T,vme_cbl.tdc.data[86],DATA12);
SIGNAL(XB147_2_E,vme_cbl.adc[3].data[5],DATA14_OVERFLOW);
SIGNAL(XB147_2_T,vme_cbl.tdc.data[21],DATA12);
SIGNAL(XB148_1_E,vme_cbl.adc[1].data[14],DATA14_OVERFLOW);
SIGNAL(XB148_1_T,vme_cbl.tdc.data[94],DATA12);
SIGNAL(XB149_1_E,vme_cbl.adc[1].data[24],DATA14_OVERFLOW);
SIGNAL(XB149_1_T,vme_cbl.tdc.data[72],DATA12);
SIGNAL(XB150_1_E,vme_cbl.adc[0].data[4],DATA14_OVERFLOW);
SIGNAL(XB150_1_T,vme_cbl.tdc.data[116],DATA12);
SIGNAL(XB151_1_E,vme_cbl.adc[0].data[6],DATA14_OVERFLOW);
SIGNAL(XB151_1_T,vme_cbl.tdc.data[118],DATA12);
SIGNAL(XB152_1_E,vme_cbl.adc[0].data[5],DATA14_OVERFLOW);
SIGNAL(XB152_1_T,vme_cbl.tdc.data[117],DATA12);
SIGNAL(XB153_1_E,vme_cbl.adc[1].data[25],DATA14_OVERFLOW);
SIGNAL(XB153_1_T,vme_cbl.tdc.data[73],DATA12);
SIGNAL(XB154_1_E,vme_cbl.adc[1].data[15],DATA14_OVERFLOW);
SIGNAL(XB154_1_T,vme_cbl.tdc.data[95],DATA12);
SIGNAL(XB155_1_E,vme_cbl.adc[1].data[7],DATA14_OVERFLOW);
SIGNAL(XB155_1_T,vme_cbl.tdc.data[87],DATA12);
SIGNAL(XB155_2_E,vme_cbl.adc[3].data[27],DATA14_OVERFLOW);
SIGNAL(XB155_2_T,vme_cbl.tdc.data[11],DATA12);
SIGNAL(XB156_1_E,vme_cbl.adc[1].data[4],DATA14_OVERFLOW);
SIGNAL(XB156_1_T,vme_cbl.tdc.data[84],DATA12);
SIGNAL(XB156_2_E,vme_cbl.adc[3].data[30],DATA14_OVERFLOW);
SIGNAL(XB156_2_T,vme_cbl.tdc.data[14],DATA12);
SIGNAL(XB157_1_E,vme_cbl.adc[1].data[5],DATA14_OVERFLOW);
SIGNAL(XB157_1_T,vme_cbl.tdc.data[85],DATA12);
SIGNAL(XB157_2_E,vme_cbl.adc[3].data[8],DATA14_OVERFLOW);
SIGNAL(XB157_2_T,vme_cbl.tdc.data[24],DATA12);
SIGNAL(XB158_1_E,vme_cbl.adc[1].data[16],DATA14_OVERFLOW);
SIGNAL(XB158_1_T,vme_cbl.tdc.data[64],DATA12);
SIGNAL(XB159_1_E,vme_cbl.adc[1].data[26],DATA14_OVERFLOW);
SIGNAL(XB159_1_T,vme_cbl.tdc.data[74],DATA12);
SIGNAL(XB160_1_E,vme_cbl.adc[1].data[27],DATA14_OVERFLOW);
SIGNAL(XB160_1_T,vme_cbl.tdc.data[75],DATA12);
SIGNAL(XB161_1_E,vme_cbl.adc[1].data[17],DATA14_OVERFLOW);
SIGNAL(XB161_1_T,vme_cbl.tdc.data[65],DATA12);
SIGNAL(XB162_1_E,vme_cbl.adc[1].data[19],DATA14_OVERFLOW);
SIGNAL(XB162_1_T,vme_cbl.tdc.data[67],DATA12);
SIGNAL(XBTRIG01_1_T,vme1.tdc775POS_ROLU.data[16],DATA12);
SIGNAL(XBTRIG02_1_T,vme1.tdc775POS_ROLU.data[17],DATA12);
SIGNAL(XBTRIG03_1_T,vme1.tdc775POS_ROLU.data[18],DATA12);
SIGNAL(XBTRIG04_1_T,vme1.tdc775POS_ROLU.data[19],DATA12);
SIGNAL(XBTRIG05_1_T,vme1.tdc775POS_ROLU.data[20],DATA12);
SIGNAL(XBTRIG06_1_T,vme1.tdc775POS_ROLU.data[21],DATA12);
SIGNAL(XBTRIG07_1_T,vme1.tdc775POS_ROLU.data[22],DATA12);
SIGNAL(XBTRIG08_1_T,vme1.tdc775POS_ROLU.data[23],DATA12);
SIGNAL(XBTRIG09_1_T,vme1.tdc775POS_ROLU.data[24],DATA12);
SIGNAL(XBTRIG10_1_T,vme1.tdc775POS_ROLU.data[25],DATA12);
SIGNAL(XBTRIG11_1_T,vme1.tdc775POS_ROLU.data[26],DATA12);
SIGNAL(XBTRIG12_1_T,vme1.tdc775POS_ROLU.data[27],DATA12);
SIGNAL(XBTRIG13_1_T,vme1.tdc775POS_ROLU.data[28],DATA12);
SIGNAL(XBTRIG14_1_T,vme1.tdc775POS_ROLU.data[29],DATA12);
SIGNAL(XBTRIG15_1_T,vme1.tdc775POS_ROLU.data[30],DATA12);
SIGNAL(XBTRIG16_1_T,vme1.tdc775POS_ROLU.data[31],DATA12);
SIGNAL(SST8_1024_E,,DATA12);
SIGNAL(TCALE,,float);
SIGNAL(TCALT,,float);
SIGNAL(TNEXT,,float);
SIGNAL(TPREV,,float);
SIGNAL( ZERO_SUPPRESS:DTF1);
SIGNAL( ZERO_SUPPRESS:GFI1_1);
SIGNAL( ZERO_SUPPRESS:N1_1);
SIGNAL( ZERO_SUPPRESS:NTF1);
SIGNAL( NO_INDEX_LIST(16):PILEUP);
SIGNAL( ZERO_SUPPRESS:SST2_1024);
SIGNAL( NO_INDEX_LIST(16):TCALMT);
SIGNAL( ZERO_SUPPRESS:TFW1);
SIGNAL( ZERO_SUPPRESS:V1_1);
SIGNAL( ZERO_SUPPRESS:XB1);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: CAMAC_LECROY_2277_1CH_HACK
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_LECROY_2277_1CH_HACK.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_2277_1CH_HACK(channel,edge,high_byte)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_LECROY_2277_1CH_HACK
class CAMAC_LECROY_2277_1CH_HACK
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_LECROY_2277_1CH_HACK
class PACKER_CAMAC_LECROY_2277_1CH_HACK
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 data[16] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,16> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    //    16: edge = CHECK(edge);
    // 17_21: channel = CHECK(channel);
    // 24_31: high = CHECK(high_byte);
    // ENCODE(data APPEND_LIST,(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channel,uint32 edge,uint32 high_byte);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channel,uint32 edge,uint32 high_byte);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channel,uint32 edge,uint32 high_byte);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_LECROY_2277_1CH_HACK);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_LECROY_2277_1CH_HACK.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_2277_1CH_HACK(channel,edge,high_byte)
template<typename __data_src_t>
void CAMAC_LECROY_2277_1CH_HACK::__unpack(__data_src_t &__buffer,uint32 channel
                                                                ,uint32 edge
                                                                ,uint32 high_byte)
{
  // MEMBER(DATA16 data[16] NO_INDEX_LIST);
  // UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    //    16: edge = CHECK(edge);
    // 17_21: channel = CHECK(channel);
    // 24_31: high = CHECK(high_byte);
    // ENCODE(data APPEND_LIST,(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 16; // 0..15
      uint32 edge : 1; // 16
      uint32 channel : 5; // 17..21
      uint32 dummy_22_23 : 2;
      uint32 high : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 high : 8; // 24..31
      uint32 dummy_22_23 : 2;
      uint32 channel : 5; // 17..21
      uint32 edge : 1; // 16
      uint32 value : 16; // 0..15
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(1129,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(1124,ch_data.edge,edge);
  CHECK_BITS_EQUAL(1125,ch_data.channel,channel);
  CHECK_BITS_EQUAL(1126,ch_data.high,high_byte);
  CHECK_UNNAMED_BITS_ZERO(1129,ch_data.u32,0x00c00000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.append_item(1128);
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_2277_1CH_HACK::__unpack,uint32 channel
                                                                     ,uint32 edge
                                                                     ,uint32 high_byte);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_LECROY_2277_1CH_HACK.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_2277_1CH_HACK(channel,edge,high_byte)
template<typename __data_src_t>
bool CAMAC_LECROY_2277_1CH_HACK::__match(__data_src_t &__buffer,uint32 channel
                                                               ,uint32 edge
                                                               ,uint32 high_byte)
{
  // MEMBER(DATA16 data[16] NO_INDEX_LIST);
  // UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    //    16: edge = CHECK(edge);
    // 17_21: channel = CHECK(channel);
    // 24_31: high = CHECK(high_byte);
    // ENCODE(data APPEND_LIST,(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 16; // 0..15
      uint32 edge : 1; // 16
      uint32 channel : 5; // 17..21
      uint32 dummy_22_23 : 2;
      uint32 high : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 high : 8; // 24..31
      uint32 dummy_22_23 : 2;
      uint32 channel : 5; // 17..21
      uint32 edge : 1; // 16
      uint32 value : 16; // 0..15
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(1129,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(1124,ch_data.edge,edge);
  MATCH_BITS_EQUAL(1125,ch_data.channel,channel);
  MATCH_BITS_EQUAL(1126,ch_data.high,high_byte);
  MATCH_UNNAMED_BITS_ZERO(1129,ch_data.u32,0x00c00000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_LECROY_2277_1CH_HACK::__match,uint32 channel
                                                                    ,uint32 edge
                                                                    ,uint32 high_byte);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_LECROY_2277_1CH_HACK.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_2277_1CH_HACK(channel,edge,high_byte)
template<typename __data_dest_t>
void PACKER_CAMAC_LECROY_2277_1CH_HACK::__packer(__data_dest_t &__buffer,uint32 channel
                                                                        ,uint32 edge
                                                                        ,uint32 high_byte)
{
  // MEMBER(DATA16 data[16] NO_INDEX_LIST);
  // UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    //    16: edge = CHECK(edge);
    // 17_21: channel = CHECK(channel);
    // 24_31: high = CHECK(high_byte);
    // ENCODE(data APPEND_LIST,(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_2277_1CH_HACK::__packer,uint32 channel
                                                                     ,uint32 edge
                                                                     ,uint32 high_byte);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_LECROY_4434
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_LECROY_4434
class CAMAC_LECROY_4434
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_LECROY_4434
class PACKER_CAMAC_LECROY_4434
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA24,DATA24,32> data;
  // list(0<=index<channels)

    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_LECROY_4434);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_src_t>
void CAMAC_LECROY_4434::__unpack(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 24; // 0..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 value : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(28,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(25,ch_data.unnamed_24_31,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(27,index);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_4434::__unpack,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_src_t>
bool CAMAC_LECROY_4434::__match(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 24; // 0..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 value : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(28,uint32 ,ch_data,ch_data.u32);
    MATCH_BITS_EQUAL(25,ch_data.unnamed_24_31,0);
    return true;
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_LECROY_4434::__match,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_dest_t>
void PACKER_CAMAC_LECROY_4434::__packer(__data_dest_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_4434::__packer,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_PHILLIPS_7164
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_PHILLIPS_7164
class CAMAC_PHILLIPS_7164
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_PHILLIPS_7164
class PACKER_CAMAC_PHILLIPS_7164
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,16> data;
  // list(0<=index<channels)

    // if(mark_channel_no)

    // else

      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels,uint32 mark_channel_no);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_PHILLIPS_7164);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_src_t>
void CAMAC_PHILLIPS_7164::__unpack(__data_src_t &__buffer,uint32 channels
                                                         ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 4; // 12..15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 channel : 4; // 12..15
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(76,uint16 ,ch_data,ch_data.u16);
      CHECK_BITS_EQUAL(73,ch_data.channel,index);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(75,index);
        __item.value = ch_data.value;
      }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_15 : 4;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 dummy_12_15 : 4;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(83,uint16 ,ch_data,ch_data.u16);
      CHECK_UNNAMED_BITS_ZERO(83,ch_data.u16,0xf000);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(82,index);
        __item.value = ch_data.value;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_PHILLIPS_7164::__unpack,uint32 channels
                                                              ,uint32 mark_channel_no);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_src_t>
bool CAMAC_PHILLIPS_7164::__match(__data_src_t &__buffer,uint32 channels
                                                        ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 4; // 12..15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 channel : 4; // 12..15
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(76,uint16 ,ch_data,ch_data.u16);
      MATCH_BITS_EQUAL(73,ch_data.channel,index);
      return true;
      return false;
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_15 : 4;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 dummy_12_15 : 4;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(83,uint16 ,ch_data,ch_data.u16);
      MATCH_UNNAMED_BITS_ZERO(83,ch_data.u16,0xf000);
      return true;
      return false;
    }
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_PHILLIPS_7164::__match,uint32 channels
                                                             ,uint32 mark_channel_no);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_dest_t>
void PACKER_CAMAC_PHILLIPS_7164::__packer(__data_dest_t &__buffer,uint32 channels
                                                                 ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_PHILLIPS_7164::__packer,uint32 channels
                                                              ,uint32 mark_channel_no);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_SILENA_4418
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_SILENA_4418
class CAMAC_SILENA_4418
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_SILENA_4418
class PACKER_CAMAC_SILENA_4418
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,8> data;
  // list(0<=index<channels)

    // if(mark_channel_no)

    // else

      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels,uint32 mark_channel_no);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_SILENA_4418);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_src_t>
void CAMAC_SILENA_4418::__unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 3; // 12..14
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 channel : 3; // 12..14
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(48,uint16 ,ch_data,ch_data.u16);
      CHECK_BITS_EQUAL(44,ch_data.channel,index);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(47,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_14 : 3;
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 dummy_12_14 : 3;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(56,uint16 ,ch_data,ch_data.u16);
      CHECK_UNNAMED_BITS_ZERO(56,ch_data.u16,0x7000);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(55,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_SILENA_4418::__unpack,uint32 channels
                                                            ,uint32 mark_channel_no);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_src_t>
bool CAMAC_SILENA_4418::__match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 3; // 12..14
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 channel : 3; // 12..14
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(48,uint16 ,ch_data,ch_data.u16);
      MATCH_BITS_EQUAL(44,ch_data.channel,index);
      return true;
      return false;
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_14 : 3;
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 dummy_12_14 : 3;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(56,uint16 ,ch_data,ch_data.u16);
      MATCH_UNNAMED_BITS_ZERO(56,ch_data.u16,0x7000);
      return true;
      return false;
    }
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_SILENA_4418::__match,uint32 channels
                                                           ,uint32 mark_channel_no);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_dest_t>
void PACKER_CAMAC_SILENA_4418::__packer(__data_dest_t &__buffer,uint32 channels
                                                               ,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_SILENA_4418::__packer,uint32 channels
                                                            ,uint32 mark_channel_no);

/** END_PACKER ********************************************************/

//
// Generating code for: CROS3_REWRITE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CROS3_REWRITE.
 *
 * Do not edit - automatically generated.
 */

// CROS3_REWRITE(ccb_id)
#if !PACKER_CODE
# define DECLARED_UNPACK_CROS3_REWRITE
class CROS3_REWRITE
#else//PACKER_CODE
# define DECLARED_PACKER_CROS3_REWRITE
class PACKER_CROS3_REWRITE
#endif//PACKER_CODE

{
public:
  // MEMBER(WIRE_START_END data[32768] ZERO_SUPPRESS);
  raw_array_zero_suppress<WIRE_START_END,WIRE_START_END,32768> data;
  // UINT32 h1
  // {
    //  0_15: data_size;
    //    16: threshold_curve;
    //    17: leading_edge;
    //    18: data;
    // 20_23: trigger_time;
    // 24_27: ccb_id = MATCH(ccb_id);
    // 28_31: event_counter;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 data_size : 16; // 0..15
      uint32 threshold_curve : 1; // 16
      uint32 leading_edge : 1; // 17
      uint32 data : 1; // 18
      uint32 dummy_19 : 1;
      uint32 trigger_time : 4; // 20..23
      uint32 ccb_id : 4; // 24..27
      uint32 event_counter : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 event_counter : 4; // 28..31
      uint32 ccb_id : 4; // 24..27
      uint32 trigger_time : 4; // 20..23
      uint32 dummy_19 : 1;
      uint32 data : 1; // 18
      uint32 leading_edge : 1; // 17
      uint32 threshold_curve : 1; // 16
      uint32 data_size : 16; // 0..15
#endif
    };
    uint32  u32;
  } h1;
  // if(h1.data)

  // else

    // UINT32 h2
    // {
      //  0_01: read_out_mode;
      //     4: pulser_enabled;
      //  8_10: statistics;
      //    11: both_edges;
      // 12_19: slices;
      // 20_21: scale;
      //    31: odd_length16;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 read_out_mode : 2; // 0..1
        uint32 dummy_2_3 : 2;
        uint32 pulser_enabled : 1; // 4
        uint32 dummy_5_7 : 3;
        uint32 statistics : 3; // 8..10
        uint32 both_edges : 1; // 11
        uint32 slices : 8; // 12..19
        uint32 scale : 2; // 20..21
        uint32 dummy_22_30 : 9;
        uint32 odd_length16 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 odd_length16 : 1; // 31
        uint32 dummy_22_30 : 9;
        uint32 scale : 2; // 20..21
        uint32 slices : 8; // 12..19
        uint32 both_edges : 1; // 11
        uint32 statistics : 3; // 8..10
        uint32 dummy_5_7 : 3;
        uint32 pulser_enabled : 1; // 4
        uint32 dummy_2_3 : 2;
        uint32 read_out_mode : 2; // 0..1
#endif
      };
      uint32  u32;
    } h2;
    // if(h1.leading_edge)

    // else

      // list(0<=index<static_cast<uint32>((h1.data_size - h2.odd_length16)))

        // UINT32 ch_data NOENCODE
        // {
          //  0_07: start_slice1;
          //  8_15: wire1;
          // 16_23: start_slice2;
          // 24_31: wire2;
          // ENCODE(data[(index * 2)],(wire=wire1,start=start_slice1,stop=0));
          // ENCODE(data[((index * 2) + 1)],(wire=wire2,start=start_slice2,
                                          // stop=0));
        // }
      // if(h2.odd_length16)

        // UINT32 ch_data_odd NOENCODE
        // {
          //  0_07: start_slice1;
          //  8_15: wire1;
          // 16_23: start_slice2 = CHECK(255);
          // 24_31: wire2 = CHECK(0);
          // ENCODE(data[((h1.data_size - 1) * 2)],(wire=wire1,start=start_slice1,
                                                 // stop=0));
        // }
      // list(0<=index<h1.data_size)

        // UINT32 ch_data NOENCODE
        // {
          //  0_07: start_slice;
          //  8_15: wire;
          // 16_23: end_slice;
          // ENCODE(data[index],(wire=wire,start=start_slice,stop=end_slice));
        // }
    // if(h1.threshold_curve)

    // else

      // UINT32 trc_h2
      // {
        //  0_01: read_out_mode;
        //     4: pulser_enabled;
        //  8_10: statistics;
        //    11: both_edges;
        // 12_19: threshold_start;
        // 20_23: threshold_step;
        // 24_28: boards;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 read_out_mode : 2; // 0..1
          uint32 dummy_2_3 : 2;
          uint32 pulser_enabled : 1; // 4
          uint32 dummy_5_7 : 3;
          uint32 statistics : 3; // 8..10
          uint32 both_edges : 1; // 11
          uint32 threshold_start : 8; // 12..19
          uint32 threshold_step : 4; // 20..23
          uint32 boards : 5; // 24..28
          uint32 dummy_29_31 : 3;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 dummy_29_31 : 3;
          uint32 boards : 5; // 24..28
          uint32 threshold_step : 4; // 20..23
          uint32 threshold_start : 8; // 12..19
          uint32 both_edges : 1; // 11
          uint32 statistics : 3; // 8..10
          uint32 dummy_5_7 : 3;
          uint32 pulser_enabled : 1; // 4
          uint32 dummy_2_3 : 2;
          uint32 read_out_mode : 2; // 0..1
#endif
        };
        uint32  u32;
      } trc_h2;
      // list(0<=board<trc_h2.boards)

        // UINT32 trc_h3 NOENCODE
        // {
          //  0_07: test_pulser_even;
          //  8_15: test_pulser_odd;
          // 16_23: threshold_steps;
          // 28_31: ad_id;
        // }
        // list(0<=index_thr<trc_h3.threshold_steps)

          // list(0<=index_wire2<8)

            // UINT32 ch_counts NOENCODE
            // {
              //  0_11: counts1;
              // 12_15: wire1;
              // 16_27: counts2;
              // 28_31: wire2;
            // }
      // UINT32 dummy_h2 NOENCODE
      // {
        //  0_31: 0;
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 ccb_id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 ccb_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 ccb_id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CROS3_REWRITE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CROS3_REWRITE.
 *
 * Do not edit - automatically generated.
 */

// CROS3_REWRITE(ccb_id)
template<typename __data_src_t>
void CROS3_REWRITE::__unpack(__data_src_t &__buffer,uint32 ccb_id)
{
  // MEMBER(WIRE_START_END data[32768] ZERO_SUPPRESS);
  // UINT32 h1
  // {
    //  0_15: data_size;
    //    16: threshold_curve;
    //    17: leading_edge;
    //    18: data;
    // 20_23: trigger_time;
    // 24_27: ccb_id = MATCH(ccb_id);
    // 28_31: event_counter;
  // }
  READ_FROM_BUFFER_FULL(797,uint32 ,h1,h1.u32);
  CHECK_BITS_EQUAL(795,h1.ccb_id,ccb_id);
  CHECK_UNNAMED_BITS_ZERO(797,h1.u32,0x00080000);
  // if(h1.data)

  // else

  if (h1.data)
  {
    // UINT32 h2
    // {
      //  0_01: read_out_mode;
      //     4: pulser_enabled;
      //  8_10: statistics;
      //    11: both_edges;
      // 12_19: slices;
      // 20_21: scale;
      //    31: odd_length16;
    // }
    READ_FROM_BUFFER_FULL(812,uint32 ,h2,h2.u32);
    CHECK_UNNAMED_BITS_ZERO(812,h2.u32,0x7fc000ec);
    // if(h1.leading_edge)

    // else

    if (h1.leading_edge)
    {
      // list(0<=index<static_cast<uint32>((h1.data_size - h2.odd_length16)))

      for (uint32 index = 0; index < (uint32) (static_cast<uint32>((h1.data_size - h2.odd_length16))); ++index)
      {
        // UINT32 ch_data NOENCODE
        // {
          //  0_07: start_slice1;
          //  8_15: wire1;
          // 16_23: start_slice2;
          // 24_31: wire2;
          // ENCODE(data[(index * 2)],(wire=wire1,start=start_slice1,stop=0));
          // ENCODE(data[((index * 2) + 1)],(wire=wire2,start=start_slice2,
                                          // stop=0));
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 start_slice1 : 8; // 0..7
            uint32 wire1 : 8; // 8..15
            uint32 start_slice2 : 8; // 16..23
            uint32 wire2 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 wire2 : 8; // 24..31
            uint32 start_slice2 : 8; // 16..23
            uint32 wire1 : 8; // 8..15
            uint32 start_slice1 : 8; // 0..7
#endif
          };
          uint32  u32;
        } ch_data;
        READ_FROM_BUFFER_FULL(829,uint32 ,ch_data,ch_data.u32);
        {
          typedef __typeof__(*(&(data))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = data.insert_index(827,(index * 2));
          __item.wire = ch_data.wire1;
          __item.start = ch_data.start_slice1;
          __item.stop = 0;
        }
        {
          typedef __typeof__(*(&(data))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = data.insert_index(828,((index * 2) + 1));
          __item.wire = ch_data.wire2;
          __item.start = ch_data.start_slice2;
          __item.stop = 0;
        }
      }
      // if(h2.odd_length16)

      if (h2.odd_length16)
      {
        // UINT32 ch_data_odd NOENCODE
        // {
          //  0_07: start_slice1;
          //  8_15: wire1;
          // 16_23: start_slice2 = CHECK(255);
          // 24_31: wire2 = CHECK(0);
          // ENCODE(data[((h1.data_size - 1) * 2)],(wire=wire1,start=start_slice1,
                                                 // stop=0));
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 start_slice1 : 8; // 0..7
            uint32 wire1 : 8; // 8..15
            uint32 start_slice2 : 8; // 16..23
            uint32 wire2 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 wire2 : 8; // 24..31
            uint32 start_slice2 : 8; // 16..23
            uint32 wire1 : 8; // 8..15
            uint32 start_slice1 : 8; // 0..7
#endif
          };
          uint32  u32;
        } ch_data_odd;
        READ_FROM_BUFFER_FULL(844,uint32 ,ch_data_odd,ch_data_odd.u32);
        CHECK_BITS_EQUAL(840,ch_data_odd.start_slice2,255);
        CHECK_BITS_EQUAL(841,ch_data_odd.wire2,0);
        {
          typedef __typeof__(*(&(data))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = data.insert_index(843,((h1.data_size - 1) * 2));
          __item.wire = ch_data_odd.wire1;
          __item.start = ch_data_odd.start_slice1;
          __item.stop = 0;
        }
      }
    }

    else
    {
      // list(0<=index<h1.data_size)

      for (uint32 index = 0; index < (uint32) (h1.data_size); ++index)
      {
        // UINT32 ch_data NOENCODE
        // {
          //  0_07: start_slice;
          //  8_15: wire;
          // 16_23: end_slice;
          // ENCODE(data[index],(wire=wire,start=start_slice,stop=end_slice));
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 start_slice : 8; // 0..7
            uint32 wire : 8; // 8..15
            uint32 end_slice : 8; // 16..23
            uint32 dummy_24_31 : 8;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 dummy_24_31 : 8;
            uint32 end_slice : 8; // 16..23
            uint32 wire : 8; // 8..15
            uint32 start_slice : 8; // 0..7
#endif
          };
          uint32  u32;
        } ch_data;
        READ_FROM_BUFFER_FULL(859,uint32 ,ch_data,ch_data.u32);
        CHECK_UNNAMED_BITS_ZERO(859,ch_data.u32,0xff000000);
        {
          typedef __typeof__(*(&(data))) __array_t;
          typedef typename __array_t::item_t __item_t;
          __item_t &__item = data.insert_index(858,index);
          __item.wire = ch_data.wire;
          __item.start = ch_data.start_slice;
          __item.stop = ch_data.end_slice;
        }
      }
    }
  }

  else
  {
    // if(h1.threshold_curve)

    // else

    if (h1.threshold_curve)
    {
      // UINT32 trc_h2
      // {
        //  0_01: read_out_mode;
        //     4: pulser_enabled;
        //  8_10: statistics;
        //    11: both_edges;
        // 12_19: threshold_start;
        // 20_23: threshold_step;
        // 24_28: boards;
      // }
      READ_FROM_BUFFER_FULL(877,uint32 ,trc_h2,trc_h2.u32);
      CHECK_UNNAMED_BITS_ZERO(877,trc_h2.u32,0xe00000ec);
      // list(0<=board<trc_h2.boards)

      for (uint32 board = 0; board < (uint32) (trc_h2.boards); ++board)
      {
        // UINT32 trc_h3 NOENCODE
        // {
          //  0_07: test_pulser_even;
          //  8_15: test_pulser_odd;
          // 16_23: threshold_steps;
          // 28_31: ad_id;
        // }
        union
        {
          struct
          {
#if __BYTE_ORDER == __LITTLE_ENDIAN
            uint32 test_pulser_even : 8; // 0..7
            uint32 test_pulser_odd : 8; // 8..15
            uint32 threshold_steps : 8; // 16..23
            uint32 dummy_24_27 : 4;
            uint32 ad_id : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
            uint32 ad_id : 4; // 28..31
            uint32 dummy_24_27 : 4;
            uint32 threshold_steps : 8; // 16..23
            uint32 test_pulser_odd : 8; // 8..15
            uint32 test_pulser_even : 8; // 0..7
#endif
          };
          uint32  u32;
        } trc_h3;
        READ_FROM_BUFFER_FULL(889,uint32 ,trc_h3,trc_h3.u32);
        CHECK_UNNAMED_BITS_ZERO(889,trc_h3.u32,0x0f000000);
        // list(0<=index_thr<trc_h3.threshold_steps)

        for (uint32 index_thr = 0; index_thr < (uint32) (trc_h3.threshold_steps); ++index_thr)
        {
          // list(0<=index_wire2<8)

          for (uint32 index_wire2 = 0; index_wire2 < (uint32) (8); ++index_wire2)
          {
            // UINT32 ch_counts NOENCODE
            // {
              //  0_11: counts1;
              // 12_15: wire1;
              // 16_27: counts2;
              // 28_31: wire2;
            // }
            union
            {
              struct
              {
#if __BYTE_ORDER == __LITTLE_ENDIAN
                uint32 counts1 : 12; // 0..11
                uint32 wire1 : 4; // 12..15
                uint32 counts2 : 12; // 16..27
                uint32 wire2 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
                uint32 wire2 : 4; // 28..31
                uint32 counts2 : 12; // 16..27
                uint32 wire1 : 4; // 12..15
                uint32 counts1 : 12; // 0..11
#endif
              };
              uint32  u32;
            } ch_counts;
            READ_FROM_BUFFER_FULL(901,uint32 ,ch_counts,ch_counts.u32);
          }
        }
      }
    }

    else
    {
      // UINT32 dummy_h2 NOENCODE
      // {
        //  0_31: 0;
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 unnamed_0_31 : 32; // 0..31
#endif
        };
        uint32  u32;
      } dummy_h2;
      READ_FROM_BUFFER_FULL(911,uint32 ,dummy_h2,dummy_h2.u32);
      CHECK_BITS_EQUAL(910,dummy_h2.unnamed_0_31,0);
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CROS3_REWRITE::__unpack,uint32 ccb_id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CROS3_REWRITE.
 *
 * Do not edit - automatically generated.
 */

// CROS3_REWRITE(ccb_id)
template<typename __data_src_t>
bool CROS3_REWRITE::__match(__data_src_t &__buffer,uint32 ccb_id)
{
  // MEMBER(WIRE_START_END data[32768] ZERO_SUPPRESS);
  // UINT32 h1
  // {
    //  0_15: data_size;
    //    16: threshold_curve;
    //    17: leading_edge;
    //    18: data;
    // 20_23: trigger_time;
    // 24_27: ccb_id = MATCH(ccb_id);
    // 28_31: event_counter;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 data_size : 16; // 0..15
      uint32 threshold_curve : 1; // 16
      uint32 leading_edge : 1; // 17
      uint32 data : 1; // 18
      uint32 dummy_19 : 1;
      uint32 trigger_time : 4; // 20..23
      uint32 ccb_id : 4; // 24..27
      uint32 event_counter : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 event_counter : 4; // 28..31
      uint32 ccb_id : 4; // 24..27
      uint32 trigger_time : 4; // 20..23
      uint32 dummy_19 : 1;
      uint32 data : 1; // 18
      uint32 leading_edge : 1; // 17
      uint32 threshold_curve : 1; // 16
      uint32 data_size : 16; // 0..15
#endif
    };
    uint32  u32;
  } __h1;
  READ_FROM_BUFFER_FULL(797,uint32 ,h1,__h1.u32);
  MATCH_BITS_EQUAL(795,__h1.ccb_id,ccb_id);
  MATCH_UNNAMED_BITS_ZERO(797,__h1.u32,0x00080000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CROS3_REWRITE::__match,uint32 ccb_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CROS3_REWRITE.
 *
 * Do not edit - automatically generated.
 */

// CROS3_REWRITE(ccb_id)
template<typename __data_dest_t>
void PACKER_CROS3_REWRITE::__packer(__data_dest_t &__buffer,uint32 ccb_id)
{
  // MEMBER(WIRE_START_END data[32768] ZERO_SUPPRESS);
  // UINT32 h1
  // {
    //  0_15: data_size;
    //    16: threshold_curve;
    //    17: leading_edge;
    //    18: data;
    // 20_23: trigger_time;
    // 24_27: ccb_id = MATCH(ccb_id);
    // 28_31: event_counter;
  // }
  // if(h1.data)

  // else

  if (h1.data)
  {
    // UINT32 h2
    // {
      //  0_01: read_out_mode;
      //     4: pulser_enabled;
      //  8_10: statistics;
      //    11: both_edges;
      // 12_19: slices;
      // 20_21: scale;
      //    31: odd_length16;
    // }
    // if(h1.leading_edge)

    // else

    if (h1.leading_edge)
    {
      // list(0<=index<static_cast<uint32>((h1.data_size - h2.odd_length16)))

      {
        // UINT32 ch_data NOENCODE
        // {
          //  0_07: start_slice1;
          //  8_15: wire1;
          // 16_23: start_slice2;
          // 24_31: wire2;
          // ENCODE(data[(index * 2)],(wire=wire1,start=start_slice1,stop=0));
          // ENCODE(data[((index * 2) + 1)],(wire=wire2,start=start_slice2,
                                          // stop=0));
        // }
      }
      // if(h2.odd_length16)

      if (h2.odd_length16)
      {
        // UINT32 ch_data_odd NOENCODE
        // {
          //  0_07: start_slice1;
          //  8_15: wire1;
          // 16_23: start_slice2 = CHECK(255);
          // 24_31: wire2 = CHECK(0);
          // ENCODE(data[((h1.data_size - 1) * 2)],(wire=wire1,start=start_slice1,
                                                 // stop=0));
        // }
      }
    }

    else
    {
      // list(0<=index<h1.data_size)

      {
        // UINT32 ch_data NOENCODE
        // {
          //  0_07: start_slice;
          //  8_15: wire;
          // 16_23: end_slice;
          // ENCODE(data[index],(wire=wire,start=start_slice,stop=end_slice));
        // }
      }
    }
  }

  else
  {
    // if(h1.threshold_curve)

    // else

    if (h1.threshold_curve)
    {
      // UINT32 trc_h2
      // {
        //  0_01: read_out_mode;
        //     4: pulser_enabled;
        //  8_10: statistics;
        //    11: both_edges;
        // 12_19: threshold_start;
        // 20_23: threshold_step;
        // 24_28: boards;
      // }
      // list(0<=board<trc_h2.boards)

      {
        // UINT32 trc_h3 NOENCODE
        // {
          //  0_07: test_pulser_even;
          //  8_15: test_pulser_odd;
          // 16_23: threshold_steps;
          // 28_31: ad_id;
        // }
        // list(0<=index_thr<trc_h3.threshold_steps)

        {
          // list(0<=index_wire2<8)

          {
            // UINT32 ch_counts NOENCODE
            // {
              //  0_11: counts1;
              // 12_15: wire1;
              // 16_27: counts2;
              // 28_31: wire2;
            // }
          }
        }
      }
    }

    else
    {
      // UINT32 dummy_h2 NOENCODE
      // {
        //  0_31: 0;
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CROS3_REWRITE::__packer,uint32 ccb_id);

/** END_PACKER ********************************************************/

//
// Generating code for: DUMMY_WORD
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for DUMMY_WORD.
 *
 * Do not edit - automatically generated.
 */

// DUMMY_WORD()
#if !PACKER_CODE
# define DECLARED_UNPACK_DUMMY_WORD
class DUMMY_WORD
#else//PACKER_CODE
# define DECLARED_PACKER_DUMMY_WORD
class PACKER_DUMMY_WORD
#endif//PACKER_CODE

{
public:
  // UINT32 dummy_word;
  uint32  dummy_word;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(DUMMY_WORD);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for DUMMY_WORD.
 *
 * Do not edit - automatically generated.
 */

// DUMMY_WORD()
template<typename __data_src_t>
void DUMMY_WORD::__unpack(__data_src_t &__buffer)
{
  // UINT32 dummy_word;
  READ_FROM_BUFFER(1421,uint32 ,dummy_word);
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY_WORD::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for DUMMY_WORD.
 *
 * Do not edit - automatically generated.
 */

// DUMMY_WORD()
template<typename __data_src_t>
bool DUMMY_WORD::__match(__data_src_t &__buffer)
{
  // UINT32 dummy_word;
  uint32  __dummy_word;
  READ_FROM_BUFFER(1421,uint32 ,__dummy_word);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,DUMMY_WORD::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for DUMMY_WORD.
 *
 * Do not edit - automatically generated.
 */

// DUMMY_WORD()
template<typename __data_dest_t>
void PACKER_DUMMY_WORD::__packer(__data_dest_t &__buffer)
{
  // UINT32 dummy_word;
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY_WORD::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: EXT_CROS3
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_CROS3.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_CROS3.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_CROS3.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_CROS3.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: EXT_SST
//

// Structure is external.  Must be provided by the user


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EXT_SST.
 *
 * Do not edit - automatically generated.
 */


/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EXT_SST.
 *
 * Do not edit - automatically generated.
 */


/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for EXT_SST.
 *
 * Do not edit - automatically generated.
 */


/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EXT_SST.
 *
 * Do not edit - automatically generated.
 */


/** END_PACKER ********************************************************/

//
// Generating code for: FASTBUS_LECROY_1875
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_FASTBUS_LECROY_1875
class FASTBUS_LECROY_1875
#else//PACKER_CODE
# define DECLARED_PACKER_FASTBUS_LECROY_1875
class PACKER_FASTBUS_LECROY_1875
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_RANGE,DATA12_RANGE,64> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FASTBUS_LECROY_1875);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_src_t>
void FASTBUS_LECROY_1875::__unpack(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 6; // 16..21
      uint32 dummy_22 : 1;
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 dummy_22 : 1;
      uint32 channel : 6; // 16..21
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(106,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(99,ch_data.channel,(channels - 1));
  CHECK_BITS_EQUAL(102,ch_data.n,0);
  CHECK_BITS_EQUAL(103,ch_data.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(106,ch_data.u32,0x0040f000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(105,ch_data.channel);
    __item.value = ch_data.value;
    __item.range = ch_data.range;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1875::__unpack,uint32 geom
                                                              ,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_src_t>
bool FASTBUS_LECROY_1875::__match(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 6; // 16..21
      uint32 dummy_22 : 1;
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 dummy_22 : 1;
      uint32 channel : 6; // 16..21
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(106,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(99,ch_data.channel,(channels - 1));
  MATCH_BITS_EQUAL(102,ch_data.n,0);
  MATCH_BITS_EQUAL(103,ch_data.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(106,ch_data.u32,0x0040f000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FASTBUS_LECROY_1875::__match,uint32 geom
                                                             ,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_dest_t>
void PACKER_FASTBUS_LECROY_1875::__packer(__data_dest_t &__buffer,uint32 geom
                                                                 ,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1875::__packer,uint32 geom
                                                              ,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: FASTBUS_LECROY_1885
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_FASTBUS_LECROY_1885
class FASTBUS_LECROY_1885
#else//PACKER_CODE
# define DECLARED_PACKER_FASTBUS_LECROY_1885
class PACKER_FASTBUS_LECROY_1885
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_RANGE,DATA12_RANGE,96> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FASTBUS_LECROY_1885);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_src_t>
void FASTBUS_LECROY_1885::__unpack(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 7; // 16..22
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 channel : 7; // 16..22
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(123,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(117,ch_data.channel,(channels - 1));
  CHECK_BITS_EQUAL(119,ch_data.n,0);
  CHECK_BITS_EQUAL(120,ch_data.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(123,ch_data.u32,0x0000f000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(122,ch_data.channel);
    __item.value = ch_data.value;
    __item.range = ch_data.range;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1885::__unpack,uint32 geom
                                                              ,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_src_t>
bool FASTBUS_LECROY_1885::__match(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 7; // 16..22
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 channel : 7; // 16..22
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(123,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(117,ch_data.channel,(channels - 1));
  MATCH_BITS_EQUAL(119,ch_data.n,0);
  MATCH_BITS_EQUAL(120,ch_data.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(123,ch_data.u32,0x0000f000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FASTBUS_LECROY_1885::__match,uint32 geom
                                                             ,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_dest_t>
void PACKER_FASTBUS_LECROY_1885::__packer(__data_dest_t &__buffer,uint32 geom
                                                                 ,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1885::__packer,uint32 geom
                                                              ,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_STD_VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_STD_VME
class LAND_STD_VME
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_STD_VME
class PACKER_LAND_STD_VME
#endif//PACKER_CODE

{
public:
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 fail_general : 1; // 0
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 dummy_8_21 : 14;
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_event : 1; // 30
      uint32 has_time_stamp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 has_time_stamp : 1; // 31
      uint32 has_multi_event : 1; // 30
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_no_zero_suppression : 1; // 27
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 dummy_8_21 : 14;
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_general : 1; // 0
#endif
    };
    uint32  u32;
  } failure;
  // if(failure.has_continous_event_counter)

    // UINT32 continous_event_counter;
    uint32  continous_event_counter;
  // if(failure.has_time_stamp)

    // UINT32 time_stamp;
    uint32  time_stamp;
  // if(failure.has_clock_counter_stamp)

    // UINT32 clock_counter_stamp;
    uint32  clock_counter_stamp;
  // if(failure.has_update_qdc_iped_value)

    // UINT32 iped;
    uint32  iped;
  // if(failure.has_multi_event)

    // UINT32 multi_events;
    uint32  multi_events;
  // if(failure.has_multi_trlo_ii_counter0)

    // UINT32 multi_trlo_ii_counter0;
    uint32  multi_trlo_ii_counter0;
  // if(failure.has_multi_scaler_counter0)

    // UINT32 multi_scaler_counter0;
    uint32  multi_scaler_counter0;
  // if(failure.has_multi_adctdc_counter0)

    // UINT32 multi_adctdc_counter0;
    uint32  multi_adctdc_counter0;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_STD_VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_src_t>
void LAND_STD_VME::__unpack(__data_src_t &__buffer)
{
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  READ_FROM_BUFFER_FULL(1172,uint32 ,failure,failure.u32);
  CHECK_UNNAMED_BITS_ZERO(1172,failure.u32,0x003fff00);
  // if(failure.has_continous_event_counter)

  if (failure.has_continous_event_counter)
  {
    // UINT32 continous_event_counter;
    READ_FROM_BUFFER(1175,uint32 ,continous_event_counter);
  }
  // if(failure.has_time_stamp)

  if (failure.has_time_stamp)
  {
    // UINT32 time_stamp;
    READ_FROM_BUFFER(1179,uint32 ,time_stamp);
  }
  // if(failure.has_clock_counter_stamp)

  if (failure.has_clock_counter_stamp)
  {
    // UINT32 clock_counter_stamp;
    READ_FROM_BUFFER(1183,uint32 ,clock_counter_stamp);
  }
  // if(failure.has_update_qdc_iped_value)

  if (failure.has_update_qdc_iped_value)
  {
    // UINT32 iped;
    READ_FROM_BUFFER(1187,uint32 ,iped);
  }
  // if(failure.has_multi_event)

  if (failure.has_multi_event)
  {
    // UINT32 multi_events;
    READ_FROM_BUFFER(1191,uint32 ,multi_events);
  }
  // if(failure.has_multi_trlo_ii_counter0)

  if (failure.has_multi_trlo_ii_counter0)
  {
    // UINT32 multi_trlo_ii_counter0;
    READ_FROM_BUFFER(1195,uint32 ,multi_trlo_ii_counter0);
  }
  // if(failure.has_multi_scaler_counter0)

  if (failure.has_multi_scaler_counter0)
  {
    // UINT32 multi_scaler_counter0;
    READ_FROM_BUFFER(1199,uint32 ,multi_scaler_counter0);
  }
  // if(failure.has_multi_adctdc_counter0)

  if (failure.has_multi_adctdc_counter0)
  {
    // UINT32 multi_adctdc_counter0;
    READ_FROM_BUFFER(1203,uint32 ,multi_adctdc_counter0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_STD_VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_src_t>
bool LAND_STD_VME::__match(__data_src_t &__buffer)
{
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 fail_general : 1; // 0
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 dummy_8_21 : 14;
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_event : 1; // 30
      uint32 has_time_stamp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 has_time_stamp : 1; // 31
      uint32 has_multi_event : 1; // 30
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_no_zero_suppression : 1; // 27
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 dummy_8_21 : 14;
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_general : 1; // 0
#endif
    };
    uint32  u32;
  } __failure;
  READ_FROM_BUFFER_FULL(1172,uint32 ,failure,__failure.u32);
  MATCH_UNNAMED_BITS_ZERO(1172,__failure.u32,0x003fff00);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,LAND_STD_VME::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_dest_t>
void PACKER_LAND_STD_VME::__packer(__data_dest_t &__buffer)
{
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  // if(failure.has_continous_event_counter)

  if (failure.has_continous_event_counter)
  {
    // UINT32 continous_event_counter;
  }
  // if(failure.has_time_stamp)

  if (failure.has_time_stamp)
  {
    // UINT32 time_stamp;
  }
  // if(failure.has_clock_counter_stamp)

  if (failure.has_clock_counter_stamp)
  {
    // UINT32 clock_counter_stamp;
  }
  // if(failure.has_update_qdc_iped_value)

  if (failure.has_update_qdc_iped_value)
  {
    // UINT32 iped;
  }
  // if(failure.has_multi_event)

  if (failure.has_multi_event)
  {
    // UINT32 multi_events;
  }
  // if(failure.has_multi_trlo_ii_counter0)

  if (failure.has_multi_trlo_ii_counter0)
  {
    // UINT32 multi_trlo_ii_counter0;
  }
  // if(failure.has_multi_scaler_counter0)

  if (failure.has_multi_scaler_counter0)
  {
    // UINT32 multi_scaler_counter0;
  }
  // if(failure.has_multi_adctdc_counter0)

  if (failure.has_multi_adctdc_counter0)
  {
    // UINT32 multi_adctdc_counter0;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_STD_VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: NTP64_TIME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
#if !PACKER_CODE
# define DECLARED_UNPACK_NTP64_TIME
class NTP64_TIME
#else//PACKER_CODE
# define DECLARED_PACKER_NTP64_TIME
class PACKER_NTP64_TIME
#endif//PACKER_CODE

{
public:
  // UINT32 sec;
  uint32  sec;
  // UINT32 frac;
  uint32  frac;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(NTP64_TIME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
template<typename __data_src_t>
void NTP64_TIME::__unpack(__data_src_t &__buffer)
{
  // UINT32 sec;
  READ_FROM_BUFFER(952,uint32 ,sec);
  // UINT32 frac;
  READ_FROM_BUFFER(953,uint32 ,frac);
}
FORCE_IMPL_DATA_SRC_FCN(void,NTP64_TIME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
template<typename __data_src_t>
bool NTP64_TIME::__match(__data_src_t &__buffer)
{
  // UINT32 sec;
  uint32  __sec;
  READ_FROM_BUFFER(952,uint32 ,__sec);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,NTP64_TIME::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
template<typename __data_dest_t>
void PACKER_NTP64_TIME::__packer(__data_dest_t &__buffer)
{
  // UINT32 sec;
  // UINT32 frac;
}
FORCE_IMPL_DATA_SRC_FCN(void,NTP64_TIME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: NTP_MESSAGE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_NTP_MESSAGE
class NTP_MESSAGE
#else//PACKER_CODE
# define DECLARED_PACKER_NTP_MESSAGE
class PACKER_NTP_MESSAGE
#endif//PACKER_CODE

{
public:
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 16; // 0..15
      uint32 quick_burst : 1; // 16
      uint32 dummy_17_23 : 7;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_17_23 : 7;
      uint32 quick_burst : 1; // 16
      uint32 word_count : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // MARK_COUNT(start);
  // UINT32 server_id;
  uint32  server_id;
  // UINT32 sspp
  // {
    //  0_07: precision;
    //  8_15: poll;
    // 16_19: stratum;
    // 24_26: mode;
    // 27_29: version = CHECK(3);
    // 30_31: leap;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 precision : 8; // 0..7
      uint32 poll : 8; // 8..15
      uint32 stratum : 4; // 16..19
      uint32 dummy_20_23 : 4;
      uint32 mode : 3; // 24..26
      uint32 version : 3; // 27..29
      uint32 leap : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 leap : 2; // 30..31
      uint32 version : 3; // 27..29
      uint32 mode : 3; // 24..26
      uint32 dummy_20_23 : 4;
      uint32 stratum : 4; // 16..19
      uint32 poll : 8; // 8..15
      uint32 precision : 8; // 0..7
#endif
    };
    uint32  u32;
  } sspp;
  // UINT32 root_dly
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 frac : 16; // 0..15
      uint32 sec : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sec : 16; // 16..31
      uint32 frac : 16; // 0..15
#endif
    };
    uint32  u32;
  } root_dly;
  // UINT32 root_disp
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 frac : 16; // 0..15
      uint32 sec : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sec : 16; // 16..31
      uint32 frac : 16; // 0..15
#endif
    };
    uint32  u32;
  } root_disp;
  // UINT32 refid;
  uint32  refid;
  // reftime = NTP64_TIME();
  // origtime = NTP64_TIME();
  // rectime = NTP64_TIME();
  // tmittime = NTP64_TIME();
  // rxtime = NTP64_TIME();
  // if(header.quick_burst)

    // orig2time = NTP64_TIME();
    // rec2time = NTP64_TIME();
    // tmit2time = NTP64_TIME();
    // rx2time = NTP64_TIME();
    SINGLE(NTP64_TIME,orig2time);
    SINGLE(NTP64_TIME,tmit2time);
    SINGLE(NTP64_TIME,rec2time);
    SINGLE(NTP64_TIME,rx2time);
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_count,start,end,0,4)
  SINGLE(NTP64_TIME,reftime);
  SINGLE(NTP64_TIME,origtime);
  SINGLE(NTP64_TIME,rectime);
  SINGLE(NTP64_TIME,tmittime);
  SINGLE(NTP64_TIME,rxtime);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(NTP_MESSAGE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
template<typename __data_src_t>
void NTP_MESSAGE::__unpack(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(964,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(963,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(964,header.u32,0x00fe0000);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 server_id;
  READ_FROM_BUFFER(968,uint32 ,server_id);
  // UINT32 sspp
  // {
    //  0_07: precision;
    //  8_15: poll;
    // 16_19: stratum;
    // 24_26: mode;
    // 27_29: version = CHECK(3);
    // 30_31: leap;
  // }
  READ_FROM_BUFFER_FULL(980,uint32 ,sspp,sspp.u32);
  CHECK_BITS_EQUAL(978,sspp.version,3);
  CHECK_UNNAMED_BITS_ZERO(980,sspp.u32,0x00f00000);
  // UINT32 root_dly
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  READ_FROM_BUFFER_FULL(986,uint32 ,root_dly,root_dly.u32);
  // UINT32 root_disp
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  READ_FROM_BUFFER_FULL(991,uint32 ,root_disp,root_disp.u32);
  // UINT32 refid;
  READ_FROM_BUFFER(992,uint32 ,refid);
  // reftime = NTP64_TIME();
  UNPACK_DECL(994,NTP64_TIME,reftime);
  // origtime = NTP64_TIME();
  UNPACK_DECL(995,NTP64_TIME,origtime);
  // rectime = NTP64_TIME();
  UNPACK_DECL(996,NTP64_TIME,rectime);
  // tmittime = NTP64_TIME();
  UNPACK_DECL(997,NTP64_TIME,tmittime);
  // rxtime = NTP64_TIME();
  UNPACK_DECL(1000,NTP64_TIME,rxtime);
  // if(header.quick_burst)

  if (header.quick_burst)
  {
    // orig2time = NTP64_TIME();
    UNPACK_DECL(1004,NTP64_TIME,orig2time);
    // rec2time = NTP64_TIME();
    UNPACK_DECL(1005,NTP64_TIME,rec2time);
    // tmit2time = NTP64_TIME();
    UNPACK_DECL(1006,NTP64_TIME,tmit2time);
    // rx2time = NTP64_TIME();
    UNPACK_DECL(1007,NTP64_TIME,rx2time);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_count,start,end,0,4)
  CHECK_WORD_COUNT(1012,header.word_count,start,end,0,4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,NTP_MESSAGE::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
template<typename __data_src_t>
bool NTP_MESSAGE::__match(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 16; // 0..15
      uint32 quick_burst : 1; // 16
      uint32 dummy_17_23 : 7;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_17_23 : 7;
      uint32 quick_burst : 1; // 16
      uint32 word_count : 16; // 0..15
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(964,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(963,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(964,__header.u32,0x00fe0000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,NTP_MESSAGE::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
template<typename __data_dest_t>
void PACKER_NTP_MESSAGE::__packer(__data_dest_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 server_id;
  // UINT32 sspp
  // {
    //  0_07: precision;
    //  8_15: poll;
    // 16_19: stratum;
    // 24_26: mode;
    // 27_29: version = CHECK(3);
    // 30_31: leap;
  // }
  // UINT32 root_dly
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  // UINT32 root_disp
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  // UINT32 refid;
  // reftime = NTP64_TIME();
  PACK_DECL(994,NTP64_TIME,reftime);
  // origtime = NTP64_TIME();
  PACK_DECL(995,NTP64_TIME,origtime);
  // rectime = NTP64_TIME();
  PACK_DECL(996,NTP64_TIME,rectime);
  // tmittime = NTP64_TIME();
  PACK_DECL(997,NTP64_TIME,tmittime);
  // rxtime = NTP64_TIME();
  PACK_DECL(1000,NTP64_TIME,rxtime);
  // if(header.quick_burst)

  if (header.quick_burst)
  {
    // orig2time = NTP64_TIME();
    PACK_DECL(1004,NTP64_TIME,orig2time);
    // rec2time = NTP64_TIME();
    PACK_DECL(1005,NTP64_TIME,rec2time);
    // tmit2time = NTP64_TIME();
    PACK_DECL(1006,NTP64_TIME,tmit2time);
    // rx2time = NTP64_TIME();
    PACK_DECL(1007,NTP64_TIME,rx2time);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_count,start,end,0,4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,NTP_MESSAGE::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: RANDOM_TCAL
//
//
// Generating code for: RANDOM_TCAL_TSTAMP_CLOCK
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
#if !PACKER_CODE
# define DECLARED_UNPACK_RANDOM_TCAL_TSTAMP_CLOCK
class RANDOM_TCAL_TSTAMP_CLOCK
#else//PACKER_CODE
# define DECLARED_PACKER_RANDOM_TCAL_TSTAMP_CLOCK
class PACKER_RANDOM_TCAL_TSTAMP_CLOCK
#endif//PACKER_CODE

{
public:
  // UINT32 soft_latches;
  uint32  soft_latches;
  // UINT32 hard_latches;
  uint32  hard_latches;
  // UINT32 clock_ticks;
  uint32  clock_ticks;
  // before = NTP64_TIME();
  // after = NTP64_TIME();
  SINGLE(NTP64_TIME,before);
  SINGLE(NTP64_TIME,after);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(RANDOM_TCAL_TSTAMP_CLOCK);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
template<typename __data_src_t>
void RANDOM_TCAL_TSTAMP_CLOCK::__unpack(__data_src_t &__buffer)
{
  // UINT32 soft_latches;
  READ_FROM_BUFFER(1020,uint32 ,soft_latches);
  // UINT32 hard_latches;
  READ_FROM_BUFFER(1021,uint32 ,hard_latches);
  // UINT32 clock_ticks;
  READ_FROM_BUFFER(1022,uint32 ,clock_ticks);
  // before = NTP64_TIME();
  UNPACK_DECL(1023,NTP64_TIME,before);
  // after = NTP64_TIME();
  UNPACK_DECL(1024,NTP64_TIME,after);
}
FORCE_IMPL_DATA_SRC_FCN(void,RANDOM_TCAL_TSTAMP_CLOCK::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
template<typename __data_src_t>
bool RANDOM_TCAL_TSTAMP_CLOCK::__match(__data_src_t &__buffer)
{
  // UINT32 soft_latches;
  uint32  __soft_latches;
  READ_FROM_BUFFER(1020,uint32 ,__soft_latches);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,RANDOM_TCAL_TSTAMP_CLOCK::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
template<typename __data_dest_t>
void PACKER_RANDOM_TCAL_TSTAMP_CLOCK::__packer(__data_dest_t &__buffer)
{
  // UINT32 soft_latches;
  // UINT32 hard_latches;
  // UINT32 clock_ticks;
  // before = NTP64_TIME();
  PACK_DECL(1023,NTP64_TIME,before);
  // after = NTP64_TIME();
  PACK_DECL(1024,NTP64_TIME,after);
}
FORCE_IMPL_DATA_SRC_FCN(void,RANDOM_TCAL_TSTAMP_CLOCK::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_RANDOM_TCAL
class RANDOM_TCAL
#else//PACKER_CODE
# define DECLARED_PACKER_RANDOM_TCAL
class PACKER_RANDOM_TCAL
#endif//PACKER_CODE

{
public:
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 8; // 0..7
      uint32 pulses : 4; // 8..11
      uint32 clock_bits : 6; // 12..17
      uint32 has_tstamp1 : 1; // 18
      uint32 has_tstamp2 : 1; // 19
      uint32 dummy_20_23 : 4;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_20_23 : 4;
      uint32 has_tstamp2 : 1; // 19
      uint32 has_tstamp1 : 1; // 18
      uint32 clock_bits : 6; // 12..17
      uint32 pulses : 4; // 8..11
      uint32 word_count : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  // MARK_COUNT(start);
  // if(header.has_tstamp1)

    // tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
    SINGLE(RANDOM_TCAL_TSTAMP_CLOCK,tstamp1);
  // if(header.has_tstamp2)

    // tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
    SINGLE(RANDOM_TCAL_TSTAMP_CLOCK,tstamp2);
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_count,start,end,0,4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(RANDOM_TCAL);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
template<typename __data_src_t>
void RANDOM_TCAL::__unpack(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(1041,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(1040,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(1041,header.u32,0x00f00000);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // if(header.has_tstamp1)

  if (header.has_tstamp1)
  {
    // tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
    UNPACK_DECL(1047,RANDOM_TCAL_TSTAMP_CLOCK,tstamp1);
  }
  // if(header.has_tstamp2)

  if (header.has_tstamp2)
  {
    // tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
    UNPACK_DECL(1051,RANDOM_TCAL_TSTAMP_CLOCK,tstamp2);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_count,start,end,0,4)
  CHECK_WORD_COUNT(1056,header.word_count,start,end,0,4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,RANDOM_TCAL::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
template<typename __data_src_t>
bool RANDOM_TCAL::__match(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 8; // 0..7
      uint32 pulses : 4; // 8..11
      uint32 clock_bits : 6; // 12..17
      uint32 has_tstamp1 : 1; // 18
      uint32 has_tstamp2 : 1; // 19
      uint32 dummy_20_23 : 4;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_20_23 : 4;
      uint32 has_tstamp2 : 1; // 19
      uint32 has_tstamp1 : 1; // 18
      uint32 clock_bits : 6; // 12..17
      uint32 pulses : 4; // 8..11
      uint32 word_count : 8; // 0..7
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(1041,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(1040,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(1041,__header.u32,0x00f00000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,RANDOM_TCAL::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
template<typename __data_dest_t>
void PACKER_RANDOM_TCAL::__packer(__data_dest_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // if(header.has_tstamp1)

  if (header.has_tstamp1)
  {
    // tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
    PACK_DECL(1047,RANDOM_TCAL_TSTAMP_CLOCK,tstamp1);
  }
  // if(header.has_tstamp2)

  if (header.has_tstamp2)
  {
    // tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
    PACK_DECL(1051,RANDOM_TCAL_TSTAMP_CLOCK,tstamp2);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_count,start,end,0,4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,RANDOM_TCAL::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: SIDEREM_BLOCK
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SIDEREM_BLOCK.
 *
 * Do not edit - automatically generated.
 */

// SIDEREM_BLOCK(sam,gtb,siderem)
#if !PACKER_CODE
# define DECLARED_UNPACK_SIDEREM_BLOCK
class SIDEREM_BLOCK
#else//PACKER_CODE
# define DECLARED_PACKER_SIDEREM_BLOCK
class PACKER_SIDEREM_BLOCK
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 data[4][512] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,512> data[4];
  // UINT32 header
  // {
    //  0_11: count;
    // 12_15: local_event_counter;
    // 16_19: local_trigger;
    // 20_23: siderem = MATCH(siderem);
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 12; // 0..11
      uint32 local_event_counter : 4; // 12..15
      uint32 local_trigger : 4; // 16..19
      uint32 siderem : 4; // 20..23
      uint32 gtb : 4; // 24..27
      uint32 sam : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sam : 4; // 28..31
      uint32 gtb : 4; // 24..27
      uint32 siderem : 4; // 20..23
      uint32 local_trigger : 4; // 16..19
      uint32 local_event_counter : 4; // 12..15
      uint32 count : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      // 12_13: adc_no;
      // 16_24: channel;
      // 28_31: 15;
      // ENCODE(data[adc_no][channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sam,uint32 gtb,uint32 siderem);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sam,uint32 gtb,uint32 siderem);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sam,uint32 gtb,uint32 siderem);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SIDEREM_BLOCK);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SIDEREM_BLOCK.
 *
 * Do not edit - automatically generated.
 */

// SIDEREM_BLOCK(sam,gtb,siderem)
template<typename __data_src_t>
void SIDEREM_BLOCK::__unpack(__data_src_t &__buffer,uint32 sam,uint32 gtb
                                                   ,uint32 siderem)
{
  // MEMBER(DATA12 data[4][512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_11: count;
    // 12_15: local_event_counter;
    // 16_19: local_trigger;
    // 20_23: siderem = MATCH(siderem);
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  READ_FROM_BUFFER_FULL(725,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(722,header.siderem,siderem);
  CHECK_BITS_EQUAL(723,header.gtb,gtb);
  CHECK_BITS_EQUAL(724,header.sam,sam);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      // 12_13: adc_no;
      // 16_24: channel;
      // 28_31: 15;
      // ENCODE(data[adc_no][channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 adc_no : 2; // 12..13
        uint32 dummy_14_15 : 2;
        uint32 channel : 9; // 16..24
        uint32 dummy_25_27 : 3;
        uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_28_31 : 4; // 28..31
        uint32 dummy_25_27 : 3;
        uint32 channel : 9; // 16..24
        uint32 dummy_14_15 : 2;
        uint32 adc_no : 2; // 12..13
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(738,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(735,ch_data.unnamed_28_31,15);
    CHECK_UNNAMED_BITS_ZERO(738,ch_data.u32,0x0e00c000);
    {
      typedef __typeof__(*(&(data[ch_data.adc_no]))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data[ch_data.adc_no].insert_index(737,ch_data.channel);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,SIDEREM_BLOCK::__unpack,uint32 sam,uint32 gtb
                                                        ,uint32 siderem);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SIDEREM_BLOCK.
 *
 * Do not edit - automatically generated.
 */

// SIDEREM_BLOCK(sam,gtb,siderem)
template<typename __data_src_t>
bool SIDEREM_BLOCK::__match(__data_src_t &__buffer,uint32 sam,uint32 gtb
                                                  ,uint32 siderem)
{
  // MEMBER(DATA12 data[4][512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_11: count;
    // 12_15: local_event_counter;
    // 16_19: local_trigger;
    // 20_23: siderem = MATCH(siderem);
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 12; // 0..11
      uint32 local_event_counter : 4; // 12..15
      uint32 local_trigger : 4; // 16..19
      uint32 siderem : 4; // 20..23
      uint32 gtb : 4; // 24..27
      uint32 sam : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sam : 4; // 28..31
      uint32 gtb : 4; // 24..27
      uint32 siderem : 4; // 20..23
      uint32 local_trigger : 4; // 16..19
      uint32 local_event_counter : 4; // 12..15
      uint32 count : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(725,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(722,__header.siderem,siderem);
  MATCH_BITS_EQUAL(723,__header.gtb,gtb);
  MATCH_BITS_EQUAL(724,__header.sam,sam);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,SIDEREM_BLOCK::__match,uint32 sam,uint32 gtb
                                                       ,uint32 siderem);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SIDEREM_BLOCK.
 *
 * Do not edit - automatically generated.
 */

// SIDEREM_BLOCK(sam,gtb,siderem)
template<typename __data_dest_t>
void PACKER_SIDEREM_BLOCK::__packer(__data_dest_t &__buffer,uint32 sam,uint32 gtb
                                                           ,uint32 siderem)
{
  // MEMBER(DATA12 data[4][512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_11: count;
    // 12_15: local_event_counter;
    // 16_19: local_trigger;
    // 20_23: siderem = MATCH(siderem);
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      // 12_13: adc_no;
      // 16_24: channel;
      // 28_31: 15;
      // ENCODE(data[adc_no][channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,SIDEREM_BLOCK::__packer,uint32 sam,uint32 gtb
                                                        ,uint32 siderem);

/** END_PACKER ********************************************************/

//
// Generating code for: SOFT_SCALER32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_SOFT_SCALER32
class SOFT_SCALER32
#else//PACKER_CODE
# define DECLARED_PACKER_SOFT_SCALER32
class PACKER_SOFT_SCALER32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // list(0<=index<channels)

    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SOFT_SCALER32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
template<typename __data_src_t>
void SOFT_SCALER32::__unpack(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(1085,uint32 ,ch_data,ch_data.u32);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(1084,index);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,SOFT_SCALER32::__unpack,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
template<typename __data_src_t>
bool SOFT_SCALER32::__match(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(1085,uint32 ,ch_data,ch_data.u32);
    return true;
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,SOFT_SCALER32::__match,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
template<typename __data_dest_t>
void PACKER_SOFT_SCALER32::__packer(__data_dest_t &__buffer,uint32 channels)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,SOFT_SCALER32::__packer,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: TACQUILA_DATA
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TACQUILA_DATA.
 *
 * Do not edit - automatically generated.
 */

// TACQUILA_DATA(sam,gtb)
#if !PACKER_CODE
# define DECLARED_UNPACK_TACQUILA_DATA
class TACQUILA_DATA
#else//PACKER_CODE
# define DECLARED_PACKER_TACQUILA_DATA
class PACKER_TACQUILA_DATA
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 tac[30][17] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,17> tac[30];
  // MEMBER(DATA12 adc[30][17] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,17> adc[30];
  // MEMBER(DATA12 clk[30][17] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,17> clk[30];
  // UINT32 header
  // {
    //  0_08: count;
    //  9_11: dummy1;
    // 12_15: trigger_tac = RANGE(0,1);
    // 16_19: trigger_sam = RANGE(1,2);
    // 20_23: lec;
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 9; // 0..8
      uint32 dummy1 : 3; // 9..11
      uint32 trigger_tac : 4; // 12..15
      uint32 trigger_sam : 4; // 16..19
      uint32 lec : 4; // 20..23
      uint32 gtb : 4; // 24..27
      uint32 sam : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sam : 4; // 28..31
      uint32 gtb : 4; // 24..27
      uint32 lec : 4; // 20..23
      uint32 trigger_sam : 4; // 16..19
      uint32 trigger_tac : 4; // 12..15
      uint32 dummy1 : 3; // 9..11
      uint32 count : 9; // 0..8
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // if(( ! (index & 1)))

      // UINT32 ch_data NOENCODE
      // {
        //  0_11: tac_value;
        // 12_17: clock_cycle;
        // 18_19: dummy2;
        //    20: trigger;
        //    21: 0;
        // 22_26: channel = RANGE(0,16);
        // 27_31: module = RANGE(1,30);
        // ENCODE(tac[(module - 1)][channel],(value=tac_value));
        // ENCODE(clk[(module - 1)][channel],(value=clock_cycle));
      // }
      // UINT32 ch_data2 NOENCODE
      // {
        //  0_11: adc_value;
        // 12_19: dummy3;
        //    20: trigger;
        //    21: 1;
        // 22_26: channel = RANGE(0,16);
        // 27_31: module = RANGE(1,30);
        // ENCODE(adc[(module - 1)][channel],(value=adc_value));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sam,uint32 gtb);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sam,uint32 gtb);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sam,uint32 gtb);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TACQUILA_DATA);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TACQUILA_DATA.
 *
 * Do not edit - automatically generated.
 */

// TACQUILA_DATA(sam,gtb)
template<typename __data_src_t>
void TACQUILA_DATA::__unpack(__data_src_t &__buffer,uint32 sam,uint32 gtb)
{
  // MEMBER(DATA12 tac[30][17] ZERO_SUPPRESS);
  // MEMBER(DATA12 adc[30][17] ZERO_SUPPRESS);
  // MEMBER(DATA12 clk[30][17] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_08: count;
    //  9_11: dummy1;
    // 12_15: trigger_tac = RANGE(0,1);
    // 16_19: trigger_sam = RANGE(1,2);
    // 20_23: lec;
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  READ_FROM_BUFFER_FULL(1372,uint32 ,header,header.u32);
  CHECK_BITS_RANGE_MAX(1367,header.trigger_tac,1);
  CHECK_BITS_RANGE(1368,header.trigger_sam,1,2);
  CHECK_BITS_EQUAL(1370,header.gtb,gtb);
  CHECK_BITS_EQUAL(1371,header.sam,sam);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // if(( ! (index & 1)))

    if (( ! (index & 1)))
    {
      // UINT32 ch_data NOENCODE
      // {
        //  0_11: tac_value;
        // 12_17: clock_cycle;
        // 18_19: dummy2;
        //    20: trigger;
        //    21: 0;
        // 22_26: channel = RANGE(0,16);
        // 27_31: module = RANGE(1,30);
        // ENCODE(tac[(module - 1)][channel],(value=tac_value));
        // ENCODE(clk[(module - 1)][channel],(value=clock_cycle));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 tac_value : 12; // 0..11
          uint32 clock_cycle : 6; // 12..17
          uint32 dummy2 : 2; // 18..19
          uint32 trigger : 1; // 20
          uint32 unnamed_21_21 : 1; // 21
          uint32 channel : 5; // 22..26
          uint32 module : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 module : 5; // 27..31
          uint32 channel : 5; // 22..26
          uint32 unnamed_21_21 : 1; // 21
          uint32 trigger : 1; // 20
          uint32 dummy2 : 2; // 18..19
          uint32 clock_cycle : 6; // 12..17
          uint32 tac_value : 12; // 0..11
#endif
        };
        uint32  u32;
      } ch_data;
      READ_FROM_BUFFER_FULL(1390,uint32 ,ch_data,ch_data.u32);
      CHECK_BITS_EQUAL(1384,ch_data.unnamed_21_21,0);
      CHECK_BITS_RANGE_MAX(1385,ch_data.channel,16);
      CHECK_BITS_RANGE(1386,ch_data.module,1,30);
      {
        typedef __typeof__(*(&(tac[(ch_data.module - 1)]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = tac[(ch_data.module - 1)].insert_index(1388,ch_data.channel);
        __item.value = ch_data.tac_value;
      }
      {
        typedef __typeof__(*(&(clk[(ch_data.module - 1)]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = clk[(ch_data.module - 1)].insert_index(1389,ch_data.channel);
        __item.value = ch_data.clock_cycle;
      }
      // UINT32 ch_data2 NOENCODE
      // {
        //  0_11: adc_value;
        // 12_19: dummy3;
        //    20: trigger;
        //    21: 1;
        // 22_26: channel = RANGE(0,16);
        // 27_31: module = RANGE(1,30);
        // ENCODE(adc[(module - 1)][channel],(value=adc_value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 adc_value : 12; // 0..11
          uint32 dummy3 : 8; // 12..19
          uint32 trigger : 1; // 20
          uint32 unnamed_21_21 : 1; // 21
          uint32 channel : 5; // 22..26
          uint32 module : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 module : 5; // 27..31
          uint32 channel : 5; // 22..26
          uint32 unnamed_21_21 : 1; // 21
          uint32 trigger : 1; // 20
          uint32 dummy3 : 8; // 12..19
          uint32 adc_value : 12; // 0..11
#endif
        };
        uint32  u32;
      } ch_data2;
      READ_FROM_BUFFER_FULL(1401,uint32 ,ch_data2,ch_data2.u32);
      CHECK_BITS_EQUAL(1396,ch_data2.unnamed_21_21,1);
      CHECK_BITS_RANGE_MAX(1397,ch_data2.channel,16);
      CHECK_BITS_RANGE(1398,ch_data2.module,1,30);
      {
        typedef __typeof__(*(&(adc[(ch_data2.module - 1)]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = adc[(ch_data2.module - 1)].insert_index(1400,ch_data2.channel);
        __item.value = ch_data2.adc_value;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TACQUILA_DATA::__unpack,uint32 sam,uint32 gtb);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TACQUILA_DATA.
 *
 * Do not edit - automatically generated.
 */

// TACQUILA_DATA(sam,gtb)
template<typename __data_src_t>
bool TACQUILA_DATA::__match(__data_src_t &__buffer,uint32 sam,uint32 gtb)
{
  // MEMBER(DATA12 tac[30][17] ZERO_SUPPRESS);
  // MEMBER(DATA12 adc[30][17] ZERO_SUPPRESS);
  // MEMBER(DATA12 clk[30][17] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_08: count;
    //  9_11: dummy1;
    // 12_15: trigger_tac = RANGE(0,1);
    // 16_19: trigger_sam = RANGE(1,2);
    // 20_23: lec;
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 9; // 0..8
      uint32 dummy1 : 3; // 9..11
      uint32 trigger_tac : 4; // 12..15
      uint32 trigger_sam : 4; // 16..19
      uint32 lec : 4; // 20..23
      uint32 gtb : 4; // 24..27
      uint32 sam : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sam : 4; // 28..31
      uint32 gtb : 4; // 24..27
      uint32 lec : 4; // 20..23
      uint32 trigger_sam : 4; // 16..19
      uint32 trigger_tac : 4; // 12..15
      uint32 dummy1 : 3; // 9..11
      uint32 count : 9; // 0..8
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(1372,uint32 ,header,__header.u32);
  MATCH_BITS_RANGE_MAX(1367,__header.trigger_tac,1);
  MATCH_BITS_RANGE(1368,__header.trigger_sam,1,2);
  MATCH_BITS_EQUAL(1370,__header.gtb,gtb);
  MATCH_BITS_EQUAL(1371,__header.sam,sam);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TACQUILA_DATA::__match,uint32 sam,uint32 gtb);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TACQUILA_DATA.
 *
 * Do not edit - automatically generated.
 */

// TACQUILA_DATA(sam,gtb)
template<typename __data_dest_t>
void PACKER_TACQUILA_DATA::__packer(__data_dest_t &__buffer,uint32 sam,uint32 gtb)
{
  // MEMBER(DATA12 tac[30][17] ZERO_SUPPRESS);
  // MEMBER(DATA12 adc[30][17] ZERO_SUPPRESS);
  // MEMBER(DATA12 clk[30][17] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_08: count;
    //  9_11: dummy1;
    // 12_15: trigger_tac = RANGE(0,1);
    // 16_19: trigger_sam = RANGE(1,2);
    // 20_23: lec;
    // 24_27: gtb = MATCH(gtb);
    // 28_31: sam = MATCH(sam);
  // }
  // list(0<=index<header.count)

  {
    // if(( ! (index & 1)))

    if (( ! (index & 1)))
    {
      // UINT32 ch_data NOENCODE
      // {
        //  0_11: tac_value;
        // 12_17: clock_cycle;
        // 18_19: dummy2;
        //    20: trigger;
        //    21: 0;
        // 22_26: channel = RANGE(0,16);
        // 27_31: module = RANGE(1,30);
        // ENCODE(tac[(module - 1)][channel],(value=tac_value));
        // ENCODE(clk[(module - 1)][channel],(value=clock_cycle));
      // }
      // UINT32 ch_data2 NOENCODE
      // {
        //  0_11: adc_value;
        // 12_19: dummy3;
        //    20: trigger;
        //    21: 1;
        // 22_26: channel = RANGE(0,16);
        // 27_31: module = RANGE(1,30);
        // ENCODE(adc[(module - 1)][channel],(value=adc_value));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TACQUILA_DATA::__packer,uint32 sam,uint32 gtb);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLO_SAMPLER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLO_SAMPLER
class TRLO_SAMPLER
#else//PACKER_CODE
# define DECLARED_PACKER_TRLO_SAMPLER
class PACKER_TRLO_SAMPLER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,512> stamps;
  // UINT32 header
  // {
    //  0_09: count;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 10; // 0..9
      uint32 dummy_10_23 : 14;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_10_23 : 14;
      uint32 count : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 data NOENCODE
    // {
      //  0_31: stamp;
      // ENCODE(stamps APPEND_LIST,(value=stamp));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLO_SAMPLER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
template<typename __data_src_t>
void TRLO_SAMPLER::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  // UINT32 header
  // {
    //  0_09: count;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(1218,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(1217,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(1218,header.u32,0x00fffc00);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 data NOENCODE
    // {
      //  0_31: stamp;
      // ENCODE(stamps APPEND_LIST,(value=stamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 stamp : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 stamp : 32; // 0..31
#endif
      };
      uint32  u32;
    } data;
    READ_FROM_BUFFER_FULL(1229,uint32 ,data,data.u32);
    {
      typedef __typeof__(*(&(stamps))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = stamps.append_item(1228);
      __item.value = data.stamp;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO_SAMPLER::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
template<typename __data_src_t>
bool TRLO_SAMPLER::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  // UINT32 header
  // {
    //  0_09: count;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 10; // 0..9
      uint32 dummy_10_23 : 14;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_10_23 : 14;
      uint32 count : 10; // 0..9
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(1218,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(1217,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(1218,__header.u32,0x00fffc00);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLO_SAMPLER::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLO_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLO_SAMPLER(id)
template<typename __data_dest_t>
void PACKER_TRLO_SAMPLER::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 stamps[512] NO_INDEX_LIST);
  // UINT32 header
  // {
    //  0_09: count;
    // 24_31: id = MATCH(id);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 data NOENCODE
    // {
      //  0_31: stamp;
      // ENCODE(stamps APPEND_LIST,(value=stamp));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLO_SAMPLER::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190
//
//
// Generating code for: VME_CAEN_V1190_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SUBTDC
class VME_CAEN_V1190_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SUBTDC
class PACKER_VME_CAEN_V1190_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;
  // MARK_COUNT(tdc_end);
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1190_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id
                                                           ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._data;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  READ_FROM_BUFFER_FULL(427,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(423,header.event_id,event_id);
  CHECK_BITS_EQUAL(425,header.tdc,tdc);
  CHECK_BITS_EQUAL(426,header.unnamed_27_31,1);
  CHECK_UNNAMED_BITS_ZERO(427,header.u32,0x04000000);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_0;
  PEEK_FROM_BUFFER_FULL(454,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(439,ch_data.tdc,tdc,data_done_0);
  CHECK_JUMP_BITS_EQUAL(444,ch_data.unnamed_27_31,0,data_done_0);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(452,((ch_data.tdc << 5) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
  }
  data_done_0:;
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  if (__buffer.empty()) goto data_done_1;
  PEEK_FROM_BUFFER_FULL(462,uint32 ,error_flags,__error_flags.u32);
  CHECK_JUMP_BITS_EQUAL(460,__error_flags.tdc,tdc,data_done_1);
  CHECK_JUMP_BITS_EQUAL(461,__error_flags.unnamed_27_31,4,data_done_1);
  CHECK_JUMP_UNNAMED_BITS_ZERO(462,__error_flags.u32,0x04ff8000,data_done_1);
  error_flags.u32 = __error_flags.u32;
  __buffer.advance(sizeof(__error_flags.u32));
  data_done_1:;
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  READ_FROM_BUFFER_FULL(473,uint32 ,trailer,trailer.u32);
  CHECK_WORD_COUNT(468,trailer.word_count,tdc_start,tdc_end,4,4);
  CHECK_BITS_EQUAL(469,trailer.event_id,header.event_id);
  CHECK_BITS_EQUAL(471,trailer.tdc,tdc);
  CHECK_BITS_EQUAL(472,trailer.unnamed_27_31,3);
  CHECK_UNNAMED_BITS_ZERO(473,trailer.u32,0x04000000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SUBTDC::__unpack,uint32 tdc
                                                                ,uint32 event_id
                                                                ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1190_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(427,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(423,__header.event_id,event_id);
  MATCH_BITS_EQUAL(425,__header.tdc,tdc);
  MATCH_BITS_EQUAL(426,__header.unnamed_27_31,1);
  MATCH_UNNAMED_BITS_ZERO(427,__header.u32,0x04000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SUBTDC::__match,uint32 tdc
                                                               ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                   ,uint32 event_id
                                                                   ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SUBTDC::__packer,uint32 tdc
                                                                ,uint32 event_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190
class VME_CAEN_V1190
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190
class PACKER_VME_CAEN_V1190
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  SINGLE(VME_CAEN_V1190_SUBTDC,tdc[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_src_t>
void VME_CAEN_V1190::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(488,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(485,header.geom,geom);
  CHECK_BITS_EQUAL(487,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1190_SUBTDC tdc[0]: (s32) => (0xff000000,0x08000000)
    // optimized match 2: VME_CAEN_V1190_SUBTDC tdc[1]: (s32) => (0xff000000,0x09000000)
    // optimized match 3: VME_CAEN_V1190_SUBTDC tdc[2]: (s32) => (0xff000000,0x0a000000)
    // optimized match 4: VME_CAEN_V1190_SUBTDC tdc[3]: (s32) => (0xff000000,0x0b000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(496,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(492,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(492,VME_CAEN_V1190_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(493,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(493,VME_CAEN_V1190_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(494,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(494,VME_CAEN_V1190_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(495,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(495,VME_CAEN_V1190_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(502,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(501,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(514,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(508,trailer.geom,geom);
  CHECK_WORD_COUNT(509,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(513,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(514,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_src_t>
bool VME_CAEN_V1190::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(488,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(485,__header.geom,geom);
  MATCH_BITS_EQUAL(487,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  {
    PACK_DECL(492,VME_CAEN_V1190_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(493,VME_CAEN_V1190_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(494,VME_CAEN_V1190_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(495,VME_CAEN_V1190_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_SHORT
//
//
// Generating code for: VME_CAEN_V1190_SHORT_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT_SUBTDC
class VME_CAEN_V1190_SHORT_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT_SUBTDC
class PACKER_VME_CAEN_V1190_SHORT_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc
                                                                 ,uint32 event_id
                                                                 ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(551,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(536,ch_data.tdc,tdc);
  CHECK_BITS_EQUAL(541,ch_data.unnamed_27_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(549,((ch_data.tdc << 5) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC::__unpack,uint32 tdc
                                                                      ,uint32 event_id
                                                                      ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc
                                                                ,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(551,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(536,ch_data.tdc,tdc);
  MATCH_BITS_EQUAL(541,ch_data.unnamed_27_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT_SUBTDC::__match,uint32 tdc
                                                                     ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                         ,uint32 event_id
                                                                         ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC::__packer,uint32 tdc
                                                                      ,uint32 event_id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_SHORT_SUBTDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
class VME_CAEN_V1190_SHORT_SUBTDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
class PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT_SUBTDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__unpack(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  READ_FROM_BUFFER_FULL(562,uint32 ,error_flags,error_flags.u32);
  CHECK_BITS_EQUAL(560,error_flags.tdc,tdc);
  CHECK_BITS_EQUAL(561,error_flags.unnamed_27_31,4);
  CHECK_UNNAMED_BITS_ZERO(562,error_flags.u32,0x04ff8000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__unpack,uint32 tdc);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__match(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  READ_FROM_BUFFER_FULL(562,uint32 ,error_flags,__error_flags.u32);
  MATCH_BITS_EQUAL(560,__error_flags.tdc,tdc);
  MATCH_BITS_EQUAL(561,__error_flags.unnamed_27_31,4);
  MATCH_UNNAMED_BITS_ZERO(562,__error_flags.u32,0x04ff8000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__match,uint32 tdc);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__packer(__data_dest_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__packer,uint32 tdc);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT
class VME_CAEN_V1190_SHORT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT
class PACKER_VME_CAEN_V1190_SHORT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  SINGLE(VME_CAEN_V1190_SHORT_SUBTDC,tdc[4]);
  SINGLE(VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(577,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(574,header.geom,geom);
  CHECK_BITS_EQUAL(576,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  bitsone<4> __visited1;
  __visited1.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1190_SHORT_SUBTDC tdc[0]: (s32) => (0xfb000000,0x00000000)
    // optimized match 2: VME_CAEN_V1190_SHORT_SUBTDC tdc[1]: (s32) => (0xfb000000,0x01000000)
    // optimized match 3: VME_CAEN_V1190_SHORT_SUBTDC tdc[2]: (s32) => (0xfb000000,0x02000000)
    // optimized match 4: VME_CAEN_V1190_SHORT_SUBTDC tdc[3]: (s32) => (0xfb000000,0x03000000)
    // optimized match 5: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[0]: (s32) => (0xffff8000,0x20000000)
    // optimized match 6: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[1]: (s32) => (0xffff8000,0x21000000)
    // optimized match 7: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[2]: (s32) => (0xffff8000,0x22000000)
    // optimized match 8: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[3]: (s32) => (0xffff8000,0x23000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(590,uint32,__match_peek);
    // differ = 23000000 : 24 25 29
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003) | /* 29,29 */ ((__match_peek >> 27) & 0x00000004);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 6, 7, 8, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(581,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(581,VME_CAEN_V1190_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(582,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(582,VME_CAEN_V1190_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(583,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(583,VME_CAEN_V1190_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(584,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(584,VME_CAEN_V1190_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(586,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/0);
        UNPACK_CHECK_NO_REVISIT(586,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],__visited1,0);
        UNPACK_DECL(586,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(587,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/1);
        UNPACK_CHECK_NO_REVISIT(587,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],__visited1,1);
        UNPACK_DECL(587,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(588,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/2);
        UNPACK_CHECK_NO_REVISIT(588,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],__visited1,2);
        UNPACK_DECL(588,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(589,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/3);
        UNPACK_CHECK_NO_REVISIT(589,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],__visited1,3);
        UNPACK_DECL(589,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
        break;
    }
  }
  spurious_match_abort_loop_1:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(596,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(595,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(608,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(602,trailer.geom,geom);
  CHECK_WORD_COUNT(603,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(607,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(608,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(577,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(574,__header.geom,geom);
  MATCH_BITS_EQUAL(576,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  {
    PACK_DECL(581,VME_CAEN_V1190_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(582,VME_CAEN_V1190_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(583,VME_CAEN_V1190_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(584,VME_CAEN_V1190_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(586,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
    PACK_DECL(587,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
    PACK_DECL(588,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
    PACK_DECL(589,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290
//
//
// Generating code for: VME_CAEN_V1290_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SUBTDC
class VME_CAEN_V1290_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SUBTDC
class PACKER_VME_CAEN_V1290_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;
  // MARK_COUNT(tdc_end);
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1290_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id
                                                           ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._data;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  READ_FROM_BUFFER_FULL(222,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(218,header.event_id,event_id);
  CHECK_BITS_EQUAL(220,header.tdc,tdc);
  CHECK_BITS_EQUAL(221,header.unnamed_27_31,1);
  CHECK_UNNAMED_BITS_ZERO(222,header.u32,0x04000000);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_2;
  PEEK_FROM_BUFFER_FULL(249,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(229,ch_data.tdc,tdc,data_done_2);
  CHECK_JUMP_BITS_EQUAL(239,ch_data.unnamed_27_31,0,data_done_2);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(243,((ch_data.tdc << 3) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
  }
  data_done_2:;
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  if (__buffer.empty()) goto data_done_3;
  PEEK_FROM_BUFFER_FULL(257,uint32 ,error_flags,__error_flags.u32);
  CHECK_JUMP_BITS_EQUAL(255,__error_flags.tdc,tdc,data_done_3);
  CHECK_JUMP_BITS_EQUAL(256,__error_flags.unnamed_27_31,4,data_done_3);
  CHECK_JUMP_UNNAMED_BITS_ZERO(257,__error_flags.u32,0x04ff8000,data_done_3);
  error_flags.u32 = __error_flags.u32;
  __buffer.advance(sizeof(__error_flags.u32));
  data_done_3:;
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  READ_FROM_BUFFER_FULL(268,uint32 ,trailer,trailer.u32);
  CHECK_WORD_COUNT(263,trailer.word_count,tdc_start,tdc_end,4,4);
  CHECK_BITS_EQUAL(264,trailer.event_id,header.event_id);
  CHECK_BITS_EQUAL(266,trailer.tdc,tdc);
  CHECK_BITS_EQUAL(267,trailer.unnamed_27_31,3);
  CHECK_UNNAMED_BITS_ZERO(268,trailer.u32,0x04000000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SUBTDC::__unpack,uint32 tdc
                                                                ,uint32 event_id
                                                                ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1290_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(222,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(218,__header.event_id,event_id);
  MATCH_BITS_EQUAL(220,__header.tdc,tdc);
  MATCH_BITS_EQUAL(221,__header.unnamed_27_31,1);
  MATCH_UNNAMED_BITS_ZERO(222,__header.u32,0x04000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SUBTDC::__match,uint32 tdc
                                                               ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                   ,uint32 event_id
                                                                   ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SUBTDC::__packer,uint32 tdc
                                                                ,uint32 event_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290
class VME_CAEN_V1290
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290
class PACKER_VME_CAEN_V1290
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  SINGLE(VME_CAEN_V1290_SUBTDC,tdc[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_src_t>
void VME_CAEN_V1290::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(283,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(280,header.geom,geom);
  CHECK_BITS_EQUAL(282,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_SUBTDC tdc[0]: (s32) => (0xff000000,0x08000000)
    // optimized match 2: VME_CAEN_V1290_SUBTDC tdc[1]: (s32) => (0xff000000,0x09000000)
    // optimized match 3: VME_CAEN_V1290_SUBTDC tdc[2]: (s32) => (0xff000000,0x0a000000)
    // optimized match 4: VME_CAEN_V1290_SUBTDC tdc[3]: (s32) => (0xff000000,0x0b000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(291,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(287,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(287,VME_CAEN_V1290_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(288,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(288,VME_CAEN_V1290_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(289,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(289,VME_CAEN_V1290_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(290,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(290,VME_CAEN_V1290_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_2:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(297,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(296,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(309,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(303,trailer.geom,geom);
  CHECK_WORD_COUNT(304,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(308,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(309,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_src_t>
bool VME_CAEN_V1290::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(283,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(280,__header.geom,geom);
  MATCH_BITS_EQUAL(282,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  {
    PACK_DECL(287,VME_CAEN_V1290_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(288,VME_CAEN_V1290_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(289,VME_CAEN_V1290_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(290,VME_CAEN_V1290_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_SHORT
//
//
// Generating code for: VME_CAEN_V1290_SHORT_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT_SUBTDC
class VME_CAEN_V1290_SHORT_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT_SUBTDC
class PACKER_VME_CAEN_V1290_SHORT_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc
                                                                 ,uint32 event_id
                                                                 ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(346,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(326,ch_data.tdc,tdc);
  CHECK_BITS_EQUAL(336,ch_data.unnamed_27_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(340,((ch_data.tdc << 3) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC::__unpack,uint32 tdc
                                                                      ,uint32 event_id
                                                                      ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc
                                                                ,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(346,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(326,ch_data.tdc,tdc);
  MATCH_BITS_EQUAL(336,ch_data.unnamed_27_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT_SUBTDC::__match,uint32 tdc
                                                                     ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                         ,uint32 event_id
                                                                         ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC::__packer,uint32 tdc
                                                                      ,uint32 event_id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_SHORT_SUBTDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
class VME_CAEN_V1290_SHORT_SUBTDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
class PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT_SUBTDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__unpack(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  READ_FROM_BUFFER_FULL(357,uint32 ,error_flags,error_flags.u32);
  CHECK_BITS_EQUAL(355,error_flags.tdc,tdc);
  CHECK_BITS_EQUAL(356,error_flags.unnamed_27_31,4);
  CHECK_UNNAMED_BITS_ZERO(357,error_flags.u32,0x04ff8000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__unpack,uint32 tdc);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__match(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  READ_FROM_BUFFER_FULL(357,uint32 ,error_flags,__error_flags.u32);
  MATCH_BITS_EQUAL(355,__error_flags.tdc,tdc);
  MATCH_BITS_EQUAL(356,__error_flags.unnamed_27_31,4);
  MATCH_UNNAMED_BITS_ZERO(357,__error_flags.u32,0x04ff8000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__match,uint32 tdc);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__packer(__data_dest_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__packer,uint32 tdc);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT
class VME_CAEN_V1290_SHORT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT
class PACKER_VME_CAEN_V1290_SHORT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  SINGLE(VME_CAEN_V1290_SHORT_SUBTDC,tdc[4]);
  SINGLE(VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(372,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(369,header.geom,geom);
  CHECK_BITS_EQUAL(371,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  bitsone<4> __visited2;
  __visited2.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_SHORT_SUBTDC tdc[0]: (s32) => (0xfb000000,0x00000000)
    // optimized match 2: VME_CAEN_V1290_SHORT_SUBTDC tdc[1]: (s32) => (0xfb000000,0x01000000)
    // optimized match 3: VME_CAEN_V1290_SHORT_SUBTDC tdc[2]: (s32) => (0xfb000000,0x02000000)
    // optimized match 4: VME_CAEN_V1290_SHORT_SUBTDC tdc[3]: (s32) => (0xfb000000,0x03000000)
    // optimized match 5: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[0]: (s32) => (0xffff8000,0x20000000)
    // optimized match 6: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[1]: (s32) => (0xffff8000,0x21000000)
    // optimized match 7: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[2]: (s32) => (0xffff8000,0x22000000)
    // optimized match 8: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[3]: (s32) => (0xffff8000,0x23000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(385,uint32,__match_peek);
    // differ = 23000000 : 24 25 29
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003) | /* 29,29 */ ((__match_peek >> 27) & 0x00000004);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 6, 7, 8, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(376,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(376,VME_CAEN_V1290_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(377,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(377,VME_CAEN_V1290_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(378,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(378,VME_CAEN_V1290_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(379,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(379,VME_CAEN_V1290_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(381,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/0);
        UNPACK_CHECK_NO_REVISIT(381,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],__visited2,0);
        UNPACK_DECL(381,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(382,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/1);
        UNPACK_CHECK_NO_REVISIT(382,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],__visited2,1);
        UNPACK_DECL(382,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(383,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/2);
        UNPACK_CHECK_NO_REVISIT(383,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],__visited2,2);
        UNPACK_DECL(383,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(384,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/3);
        UNPACK_CHECK_NO_REVISIT(384,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],__visited2,3);
        UNPACK_DECL(384,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
        break;
    }
  }
  spurious_match_abort_loop_3:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(391,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(390,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(403,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(397,trailer.geom,geom);
  CHECK_WORD_COUNT(398,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(402,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(403,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(372,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(369,__header.geom,geom);
  MATCH_BITS_EQUAL(371,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  {
    PACK_DECL(376,VME_CAEN_V1290_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(377,VME_CAEN_V1290_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(378,VME_CAEN_V1290_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(379,VME_CAEN_V1290_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(381,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
    PACK_DECL(382,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
    PACK_DECL(383,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
    PACK_DECL(384,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V775
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V775
class VME_CAEN_V775
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V775
class PACKER_VME_CAEN_V775
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,32> data;
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 event_number : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 crate);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 crate);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 crate);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V775);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_src_t>
void VME_CAEN_V775::__unpack(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 dummy_0_7 : 8;
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 dummy_0_7 : 8;
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(141,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(138,header.crate,crate);
  CHECK_BITS_EQUAL(139,header.unnamed_24_26,2);
  CHECK_BITS_EQUAL(140,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(141,header.u32,0x0000c0ff);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 overflow : 1; // 12
        uint32 underflow : 1; // 13
        uint32 valid : 1; // 14
        uint32 dummy_15 : 1;
        uint32 channel : 5; // 16..20
        uint32 dummy_21_23 : 3;
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 dummy_21_23 : 3;
        uint32 channel : 5; // 16..20
        uint32 dummy_15 : 1;
        uint32 valid : 1; // 14
        uint32 underflow : 1; // 13
        uint32 overflow : 1; // 12
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(161,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(157,ch_data.unnamed_24_26,0);
    CHECK_BITS_EQUAL(158,ch_data.geom,geom);
    CHECK_UNNAMED_BITS_ZERO(161,ch_data.u32,0x00e08000);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(160,ch_data.channel);
      __item.value = ch_data.value;
      __item.overflow = ch_data.overflow;
    }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  READ_FROM_BUFFER_FULL(170,uint32 ,eob,eob.u32);
  CHECK_BITS_EQUAL(167,eob.unnamed_24_26,4);
  CHECK_BITS_EQUAL(168,eob.geom,geom);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V775::__unpack,uint32 geom,uint32 crate);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_src_t>
bool VME_CAEN_V775::__match(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 dummy_0_7 : 8;
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 dummy_0_7 : 8;
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(141,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(138,header.crate,crate);
  MATCH_BITS_EQUAL(139,header.unnamed_24_26,2);
  MATCH_BITS_EQUAL(140,header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(141,header.u32,0x0000c0ff);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V775::__match,uint32 geom,uint32 crate);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V775::__packer(__data_dest_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V775::__packer,uint32 geom,uint32 crate);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V830
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V830
class VME_CAEN_V830
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V830
class PACKER_VME_CAEN_V830
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 dummy_24_25 : 2;
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 dummy_24_25 : 2;
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V830);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
void VME_CAEN_V830::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  READ_FROM_BUFFER_FULL(189,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(187,header.unnamed_26_26,1);
  CHECK_BITS_EQUAL(188,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(189,header.u32,0x03000000);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 26; // 0..25
        uint32 unnamed_26_26 : 1; // 26
        uint32 channel : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel : 5; // 27..31
        uint32 unnamed_26_26 : 1; // 26
        uint32 value : 26; // 0..25
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(200,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(196,ch_data.unnamed_26_26,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(199,ch_data.channel);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
bool VME_CAEN_V830::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 dummy_24_25 : 2;
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 dummy_24_25 : 2;
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(189,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(187,__header.unnamed_26_26,1);
  MATCH_BITS_EQUAL(188,__header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(189,__header.u32,0x03000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V830::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V830::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MADC32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MADC32
class VME_MESYTEC_MADC32
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MADC32
class PACKER_VME_MESYTEC_MADC32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA14_OVERFLOW,DATA14_OVERFLOW,32> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MADC32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
void VME_MESYTEC_MADC32::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(628,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(625,header.geom,geom);
  CHECK_BITS_EQUAL(626,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(627,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 13; // 0..12
      uint32 dummy_13 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_15 : 1;
      uint32 channel : 5; // 16..20
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 channel : 5; // 16..20
      uint32 dummy_15 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_13 : 1;
      uint32 value : 13; // 0..12
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_4;
  PEEK_FROM_BUFFER_FULL(639,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(635,ch_data.unnamed_21_29,32,data_done_4);
  CHECK_JUMP_BITS_EQUAL(636,ch_data.unnamed_30_31,0,data_done_4);
  CHECK_JUMP_UNNAMED_BITS_ZERO(639,ch_data.u32,0x0000a000,data_done_4);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(638,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.outofrange;
  }
  }
  data_done_4:;
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  if (__buffer.empty()) goto data_done_5;
  PEEK_FROM_BUFFER_FULL(645,uint32 ,filler,filler.u32);
  CHECK_JUMP_BITS_EQUAL(644,filler.unnamed_0_31,0,data_done_5);
  __buffer.advance(sizeof(filler.u32));
  data_done_5:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(651,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(650,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(654,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MADC32::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(628,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(625,header.geom,geom);
  MATCH_BITS_EQUAL(626,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(627,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MADC32::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MADC32::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MDPP16
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MDPP16
class VME_MESYTEC_MDPP16
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MDPP16
class PACKER_VME_MESYTEC_MDPP16
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16_OVERFLOW,DATA16_OVERFLOW,34,100> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MDPP16);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_src_t>
void VME_MESYTEC_MDPP16::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 10; // 0..9
      uint32 adc_res : 3; // 10..12
      uint32 tdc_res : 3; // 13..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_res : 3; // 13..15
      uint32 adc_res : 3; // 10..12
      uint32 word_number : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(672,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(669,header.geom,geom);
  CHECK_BITS_EQUAL(670,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(671,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 16; // 0..15
      uint32 channel : 6; // 16..21
      uint32 overflow : 1; // 22
      uint32 pileup : 1; // 23
      uint32 unnamed_24_27 : 4; // 24..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 unnamed_24_27 : 4; // 24..27
      uint32 pileup : 1; // 23
      uint32 overflow : 1; // 22
      uint32 channel : 6; // 16..21
      uint32 value : 16; // 0..15
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_6;
  PEEK_FROM_BUFFER_FULL(684,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(680,ch_data.unnamed_24_27,0,data_done_6);
  CHECK_JUMP_BITS_EQUAL(681,ch_data.unnamed_28_31,1,data_done_6);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(683,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.overflow;
    __item.pileup = ch_data.pileup;
  }
  }
  data_done_6:;
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } fill_word;
  if (__buffer.empty()) goto data_done_7;
  PEEK_FROM_BUFFER_FULL(689,uint32 ,fill_word,fill_word.u32);
  CHECK_JUMP_BITS_EQUAL(688,fill_word.unnamed_0_31,0,data_done_7);
  __buffer.advance(sizeof(fill_word.u32));
  }
  data_done_7:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(695,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(694,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(698,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MDPP16::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MDPP16::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 10; // 0..9
      uint32 adc_res : 3; // 10..12
      uint32 tdc_res : 3; // 13..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_res : 3; // 13..15
      uint32 adc_res : 3; // 10..12
      uint32 word_number : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(672,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(669,header.geom,geom);
  MATCH_BITS_EQUAL(670,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(671,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MDPP16::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MDPP16::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MDPP16::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_VUPROM_V35
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_VUPROM_V35.
 *
 * Do not edit - automatically generated.
 */

// VME_VUPROM_V35()
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_VUPROM_V35
class VME_VUPROM_V35
#else//PACKER_CODE
# define DECLARED_PACKER_VME_VUPROM_V35
class PACKER_VME_VUPROM_V35
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 data[192] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,192> data;
  // UINT32 header NOENCODE
  // {
    //  0_08: word_number;
    //     9: raw_marker;
    // 10_15: 0;
    // 16_23: geom;
    // 24_31: 254;
  // }
  // list(0<=index<header.word_number)

    // UINT32 ch_data NOENCODE
    // {
      //  0_09: value;
      // 10_15: 0;
      // 16_23: channel;
      // 24_31: geom;
      // ENCODE(data[channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_VUPROM_V35);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_VUPROM_V35.
 *
 * Do not edit - automatically generated.
 */

// VME_VUPROM_V35()
template<typename __data_src_t>
void VME_VUPROM_V35::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA12 data[192] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_08: word_number;
    //     9: raw_marker;
    // 10_15: 0;
    // 16_23: geom;
    // 24_31: 254;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 9; // 0..8
      uint32 raw_marker : 1; // 9
      uint32 unnamed_10_15 : 6; // 10..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 geom : 8; // 16..23
      uint32 unnamed_10_15 : 6; // 10..15
      uint32 raw_marker : 1; // 9
      uint32 word_number : 9; // 0..8
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(1334,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(1331,header.unnamed_10_15,0);
  CHECK_BITS_EQUAL(1333,header.unnamed_24_31,254);
  // list(0<=index<header.word_number)

  for (uint32 index = 0; index < (uint32) (header.word_number); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_09: value;
      // 10_15: 0;
      // 16_23: channel;
      // 24_31: geom;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 10; // 0..9
        uint32 unnamed_10_15 : 6; // 10..15
        uint32 channel : 8; // 16..23
        uint32 geom : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 8; // 24..31
        uint32 channel : 8; // 16..23
        uint32 unnamed_10_15 : 6; // 10..15
        uint32 value : 10; // 0..9
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(1346,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(1341,ch_data.unnamed_10_15,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(1345,ch_data.channel);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_VUPROM_V35::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_VUPROM_V35.
 *
 * Do not edit - automatically generated.
 */

// VME_VUPROM_V35()
template<typename __data_src_t>
bool VME_VUPROM_V35::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA12 data[192] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_08: word_number;
    //     9: raw_marker;
    // 10_15: 0;
    // 16_23: geom;
    // 24_31: 254;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 9; // 0..8
      uint32 raw_marker : 1; // 9
      uint32 unnamed_10_15 : 6; // 10..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 geom : 8; // 16..23
      uint32 unnamed_10_15 : 6; // 10..15
      uint32 raw_marker : 1; // 9
      uint32 word_number : 9; // 0..8
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(1334,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(1331,header.unnamed_10_15,0);
  MATCH_BITS_EQUAL(1333,header.unnamed_24_31,254);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VME_VUPROM_V35::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_VUPROM_V35.
 *
 * Do not edit - automatically generated.
 */

// VME_VUPROM_V35()
template<typename __data_dest_t>
void PACKER_VME_VUPROM_V35::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA12 data[192] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_08: word_number;
    //     9: raw_marker;
    // 10_15: 0;
    // 16_23: geom;
    // 24_31: 254;
  // }
  // list(0<=index<header.word_number)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_09: value;
      // 10_15: 0;
      // 16_23: channel;
      // 24_31: geom;
      // ENCODE(data[channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_VUPROM_V35::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: CB_VME_LEFT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CB_VME_LEFT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_LEFT)
#if !PACKER_CODE
# define DECLARED_UNPACK_CB_VME_LEFT
class CB_VME_LEFT
#else//PACKER_CODE
# define DECLARED_PACKER_CB_VME_LEFT
class PACKER_CB_VME_LEFT
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // vme = LAND_STD_VME();
  // select several

    // adc[0] = VME_MESYTEC_MADC32(geom=0);
    // adc[1] = VME_MESYTEC_MADC32(geom=1);
    // adc[2] = VME_MESYTEC_MADC32(geom=2);
    // adc[3] = VME_MESYTEC_MADC32(geom=3);
    // madc0_psp = VME_MESYTEC_MADC32(geom=4);
    // tdc = VME_VUPROM_V35();
  SINGLE(VME_VUPROM_V35,tdc);
  SINGLE(VME_MESYTEC_MADC32,adc[4]);
  SINGLE(VME_MESYTEC_MADC32,madc0_psp);
  SINGLE(LAND_STD_VME,vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CB_VME_LEFT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CB_VME_LEFT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_LEFT)
template<typename __data_src_t>
void CB_VME_LEFT::__unpack(__data_src_t &__buffer)
{
  // vme = LAND_STD_VME();
  UNPACK_DECL(1296,LAND_STD_VME,vme);
  // select several

    // adc[0] = VME_MESYTEC_MADC32(geom=0);
    // adc[1] = VME_MESYTEC_MADC32(geom=1);
    // adc[2] = VME_MESYTEC_MADC32(geom=2);
    // adc[3] = VME_MESYTEC_MADC32(geom=3);
    // madc0_psp = VME_MESYTEC_MADC32(geom=4);
    // tdc = VME_VUPROM_V35();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_MESYTEC_MADC32 adc[0]: (s32) => (0xffff0000,0x40000000)
    // optimized match 2: VME_MESYTEC_MADC32 adc[1]: (s32) => (0xffff0000,0x40010000)
    // optimized match 3: VME_MESYTEC_MADC32 adc[2]: (s32) => (0xffff0000,0x40020000)
    // optimized match 4: VME_MESYTEC_MADC32 adc[3]: (s32) => (0xffff0000,0x40030000)
    // optimized match 5: VME_MESYTEC_MADC32 madc0_psp: (s32) => (0xffff0000,0x40040000)
    // optimized match 6: VME_VUPROM_V35 tdc: (s32) => (0xff00fc00,0xfe000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1305,uint32,__match_peek);
    // differ = be070000 : 16 17 18 25 26 27 28 29 31
    // select on bit 17, partition: 1:4(d2) 0:3(d3)
    if (__match_peek & 0x00020000) {
      MATCH_DECL_QUICK(1301,__match_no,3,adc[2],__match_peek,0xffff0000,0x40020000);
      MATCH_DECL_QUICK(1302,__match_no,4,adc[3],__match_peek,0xffff0000,0x40030000);
      MATCH_DECL_QUICK(1304,__match_no,6,tdc,__match_peek,0xff00fc00,0xfe000000);
    } else {
      // select on bit 31, partition: 1:3(d1) 0:1(d3)
      if (__match_peek & 0x80000000) {
        UNPACK_DECL(1304,VME_VUPROM_V35,tdc);
        continue;
      } else {
        MATCH_DECL_QUICK(1299,__match_no,1,adc[0],__match_peek,0xffff0000,0x40000000);
        MATCH_DECL_QUICK(1300,__match_no,2,adc[1],__match_peek,0xffff0000,0x40010000);
        MATCH_DECL_QUICK(1303,__match_no,5,madc0_psp,__match_peek,0xffff0000,0x40040000);
      }
    }
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1299,VME_MESYTEC_MADC32,adc[0],/*geom*/0);
        break;
      case 2:
        UNPACK_DECL(1300,VME_MESYTEC_MADC32,adc[1],/*geom*/1);
        break;
      case 3:
        UNPACK_DECL(1301,VME_MESYTEC_MADC32,adc[2],/*geom*/2);
        break;
      case 4:
        UNPACK_DECL(1302,VME_MESYTEC_MADC32,adc[3],/*geom*/3);
        break;
      case 5:
        UNPACK_DECL(1303,VME_MESYTEC_MADC32,madc0_psp,/*geom*/4);
        break;
      case 6:
        UNPACK_DECL(1304,VME_VUPROM_V35,tdc);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CB_VME_LEFT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CB_VME_LEFT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_LEFT)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CB_VME_LEFT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_LEFT)
template<typename __data_dest_t>
void PACKER_CB_VME_LEFT::__packer(__data_dest_t &__buffer)
{
  // vme = LAND_STD_VME();
  PACK_DECL(1296,LAND_STD_VME,vme);
  // select several

    // adc[0] = VME_MESYTEC_MADC32(geom=0);
    // adc[1] = VME_MESYTEC_MADC32(geom=1);
    // adc[2] = VME_MESYTEC_MADC32(geom=2);
    // adc[3] = VME_MESYTEC_MADC32(geom=3);
    // madc0_psp = VME_MESYTEC_MADC32(geom=4);
    // tdc = VME_VUPROM_V35();
  {
    PACK_DECL(1299,VME_MESYTEC_MADC32,adc[0],/*geom*/0);
    PACK_DECL(1300,VME_MESYTEC_MADC32,adc[1],/*geom*/1);
    PACK_DECL(1301,VME_MESYTEC_MADC32,adc[2],/*geom*/2);
    PACK_DECL(1302,VME_MESYTEC_MADC32,adc[3],/*geom*/3);
    PACK_DECL(1303,VME_MESYTEC_MADC32,madc0_psp,/*geom*/4);
    PACK_DECL(1304,VME_VUPROM_V35,tdc);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CB_VME_LEFT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: CB_VME_RIGHT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CB_VME_RIGHT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_RIGHT)
#if !PACKER_CODE
# define DECLARED_UNPACK_CB_VME_RIGHT
class CB_VME_RIGHT
#else//PACKER_CODE
# define DECLARED_PACKER_CB_VME_RIGHT
class PACKER_CB_VME_RIGHT
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // vme = LAND_STD_VME();
  // select several

    // adc[0] = VME_MESYTEC_MADC32(geom=0);
    // adc[1] = VME_MESYTEC_MADC32(geom=1);
    // adc[2] = VME_MESYTEC_MADC32(geom=2);
    // adc[3] = VME_MESYTEC_MADC32(geom=3);
    // tdc = VME_VUPROM_V35();
  SINGLE(VME_VUPROM_V35,tdc);
  SINGLE(VME_MESYTEC_MADC32,adc[4]);
  SINGLE(LAND_STD_VME,vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CB_VME_RIGHT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CB_VME_RIGHT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_RIGHT)
template<typename __data_src_t>
void CB_VME_RIGHT::__unpack(__data_src_t &__buffer)
{
  // vme = LAND_STD_VME();
  UNPACK_DECL(1283,LAND_STD_VME,vme);
  // select several

    // adc[0] = VME_MESYTEC_MADC32(geom=0);
    // adc[1] = VME_MESYTEC_MADC32(geom=1);
    // adc[2] = VME_MESYTEC_MADC32(geom=2);
    // adc[3] = VME_MESYTEC_MADC32(geom=3);
    // tdc = VME_VUPROM_V35();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_MESYTEC_MADC32 adc[0]: (s32) => (0xffff0000,0x40000000)
    // optimized match 2: VME_MESYTEC_MADC32 adc[1]: (s32) => (0xffff0000,0x40010000)
    // optimized match 3: VME_MESYTEC_MADC32 adc[2]: (s32) => (0xffff0000,0x40020000)
    // optimized match 4: VME_MESYTEC_MADC32 adc[3]: (s32) => (0xffff0000,0x40030000)
    // optimized match 5: VME_VUPROM_V35 tdc: (s32) => (0xff00fc00,0xfe000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1291,uint32,__match_peek);
    // differ = be030000 : 16 17 25 26 27 28 29 31
    // select on bit 17, partition: 1:3(d2) 0:3(d2)
    if (__match_peek & 0x00020000) {
      MATCH_DECL_QUICK(1288,__match_no,3,adc[2],__match_peek,0xffff0000,0x40020000);
      MATCH_DECL_QUICK(1289,__match_no,4,adc[3],__match_peek,0xffff0000,0x40030000);
      MATCH_DECL_QUICK(1290,__match_no,5,tdc,__match_peek,0xff00fc00,0xfe000000);
    } else {
      MATCH_DECL_QUICK(1286,__match_no,1,adc[0],__match_peek,0xffff0000,0x40000000);
      MATCH_DECL_QUICK(1287,__match_no,2,adc[1],__match_peek,0xffff0000,0x40010000);
      MATCH_DECL_QUICK(1290,__match_no,5,tdc,__match_peek,0xff00fc00,0xfe000000);
    }
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1286,VME_MESYTEC_MADC32,adc[0],/*geom*/0);
        break;
      case 2:
        UNPACK_DECL(1287,VME_MESYTEC_MADC32,adc[1],/*geom*/1);
        break;
      case 3:
        UNPACK_DECL(1288,VME_MESYTEC_MADC32,adc[2],/*geom*/2);
        break;
      case 4:
        UNPACK_DECL(1289,VME_MESYTEC_MADC32,adc[3],/*geom*/3);
        break;
      case 5:
        UNPACK_DECL(1290,VME_VUPROM_V35,tdc);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CB_VME_RIGHT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CB_VME_RIGHT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_RIGHT)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CB_VME_RIGHT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CB_VME_RIGHT)
template<typename __data_dest_t>
void PACKER_CB_VME_RIGHT::__packer(__data_dest_t &__buffer)
{
  // vme = LAND_STD_VME();
  PACK_DECL(1283,LAND_STD_VME,vme);
  // select several

    // adc[0] = VME_MESYTEC_MADC32(geom=0);
    // adc[1] = VME_MESYTEC_MADC32(geom=1);
    // adc[2] = VME_MESYTEC_MADC32(geom=2);
    // adc[3] = VME_MESYTEC_MADC32(geom=3);
    // tdc = VME_VUPROM_V35();
  {
    PACK_DECL(1286,VME_MESYTEC_MADC32,adc[0],/*geom*/0);
    PACK_DECL(1287,VME_MESYTEC_MADC32,adc[1],/*geom*/1);
    PACK_DECL(1288,VME_MESYTEC_MADC32,adc[2],/*geom*/2);
    PACK_DECL(1289,VME_MESYTEC_MADC32,adc[3],/*geom*/3);
    PACK_DECL(1290,VME_VUPROM_V35,tdc);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CB_VME_RIGHT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: CROS3_REWRITE_SUBEVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CROS3_REWRITE_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_REWRITE_SUBEVENT)
#if !PACKER_CODE
# define DECLARED_UNPACK_CROS3_REWRITE_SUBEVENT
class CROS3_REWRITE_SUBEVENT
#else//PACKER_CODE
# define DECLARED_PACKER_CROS3_REWRITE_SUBEVENT
class PACKER_CROS3_REWRITE_SUBEVENT
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // norevisit ccb[0] = CROS3_REWRITE(ccb_id=1);
    // norevisit ccb[1] = CROS3_REWRITE(ccb_id=2);
  SINGLE(CROS3_REWRITE,ccb[2]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CROS3_REWRITE_SUBEVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CROS3_REWRITE_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_REWRITE_SUBEVENT)
template<typename __data_src_t>
void CROS3_REWRITE_SUBEVENT::__unpack(__data_src_t &__buffer)
{
  // select several

    // norevisit ccb[0] = CROS3_REWRITE(ccb_id=1);
    // norevisit ccb[1] = CROS3_REWRITE(ccb_id=2);
  bitsone<2> __visited3;
  __visited3.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: CROS3_REWRITE ccb[0]: (s32) => (0x0f080000,0x01000000)
    // optimized match 2: CROS3_REWRITE ccb[1]: (s32) => (0x0f080000,0x02000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(923,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 0, 1, 2, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_CHECK_NO_REVISIT(921,CROS3_REWRITE,ccb[0],__visited3,0);
        UNPACK_DECL(921,CROS3_REWRITE,ccb[0],/*ccb_id*/1);
        break;
      case 2:
        UNPACK_CHECK_NO_REVISIT(922,CROS3_REWRITE,ccb[1],__visited3,1);
        UNPACK_DECL(922,CROS3_REWRITE,ccb[1],/*ccb_id*/2);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CROS3_REWRITE_SUBEVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CROS3_REWRITE_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_REWRITE_SUBEVENT)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CROS3_REWRITE_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_REWRITE_SUBEVENT)
template<typename __data_dest_t>
void PACKER_CROS3_REWRITE_SUBEVENT::__packer(__data_dest_t &__buffer)
{
  // select several

    // norevisit ccb[0] = CROS3_REWRITE(ccb_id=1);
    // norevisit ccb[1] = CROS3_REWRITE(ccb_id=2);
  {
    PACK_DECL(921,CROS3_REWRITE,ccb[0],/*ccb_id*/1);
    PACK_DECL(922,CROS3_REWRITE,ccb[1],/*ccb_id*/2);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CROS3_REWRITE_SUBEVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: CROS3_SUBEVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CROS3_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_SUBEVENT)
#if !PACKER_CODE
# define DECLARED_UNPACK_CROS3_SUBEVENT
class CROS3_SUBEVENT
#else//PACKER_CODE
# define DECLARED_PACKER_CROS3_SUBEVENT
class PACKER_CROS3_SUBEVENT
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // external norevisit ccb[0] = EXT_CROS3(ccb_id=1);
    // external norevisit ccb[1] = EXT_CROS3(ccb_id=2);
  SINGLE(EXT_CROS3,ccb[2]);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CROS3_SUBEVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CROS3_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_SUBEVENT)
template<typename __data_src_t>
void CROS3_SUBEVENT::__unpack(__data_src_t &__buffer)
{
  // select several

    // external norevisit ccb[0] = EXT_CROS3(ccb_id=1);
    // external norevisit ccb[1] = EXT_CROS3(ccb_id=2);
  bitsone<2> __visited4;
  __visited4.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: EXT_CROS3 ccb[0]: could not get bits
    __buffer.peeking();
    MATCH_DECL(775,__match_no,1,EXT_CROS3,ccb[0],/*ccb_id*/1);
    MATCH_DECL(776,__match_no,2,EXT_CROS3,ccb[1],/*ccb_id*/2);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_CHECK_NO_REVISIT(775,EXT_CROS3,ccb[0],__visited4,0);
        UNPACK_DECL(775,EXT_CROS3,ccb[0],/*ccb_id*/1);
        break;
      case 2:
        UNPACK_CHECK_NO_REVISIT(776,EXT_CROS3,ccb[1],__visited4,1);
        UNPACK_DECL(776,EXT_CROS3,ccb[1],/*ccb_id*/2);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CROS3_SUBEVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CROS3_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_SUBEVENT)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CROS3_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(CROS3_SUBEVENT)
template<typename __data_dest_t>
void PACKER_CROS3_SUBEVENT::__packer(__data_dest_t &__buffer)
{
  // select several

    // external norevisit ccb[0] = EXT_CROS3(ccb_id=1);
    // external norevisit ccb[1] = EXT_CROS3(ccb_id=2);
  {
    PACK_DECL(775,EXT_CROS3,ccb[0],/*ccb_id*/1);
    PACK_DECL(776,EXT_CROS3,ccb[1],/*ccb_id*/2);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,CROS3_SUBEVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: DUMMY
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(DUMMY)
#if !PACKER_CODE
# define DECLARED_UNPACK_DUMMY
class DUMMY
#else//PACKER_CODE
# define DECLARED_PACKER_DUMMY
class PACKER_DUMMY
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // d = DUMMY_WORD();
  SINGLE(DUMMY_WORD,d);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(DUMMY);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(DUMMY)
template<typename __data_src_t>
void DUMMY::__unpack(__data_src_t &__buffer)
{
  // select several

    // d = DUMMY_WORD();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: DUMMY_WORD d: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1429,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1428,DUMMY_WORD,d);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(DUMMY)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for DUMMY.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(DUMMY)
template<typename __data_dest_t>
void PACKER_DUMMY::__packer(__data_dest_t &__buffer)
{
  // select several

    // d = DUMMY_WORD();
  {
    PACK_DECL(1428,DUMMY_WORD,d);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,DUMMY::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_CONVERTER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_CONVERTER
class LAND_CAMAC_CONVERTER
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_CONVERTER
class PACKER_LAND_CAMAC_CONVERTER
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT16 tpat;
  uint16  tpat;
  // UINT16 tprev;
  uint16  tprev;
  // UINT16 tnext;
  uint16  tnext;
  // UINT16 tprev2;
  uint16  tprev2;
  // if(EXTERNAL has_data)

#ifndef __PSDC__
  uint32 has_data() const;
#endif//!__PSDC__

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_CONVERTER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
template<typename __data_src_t>
void LAND_CAMAC_CONVERTER::__unpack(__data_src_t &__buffer)
{
  // UINT16 tpat;
  READ_FROM_BUFFER(931,uint16 ,tpat);
  // UINT16 tprev;
  READ_FROM_BUFFER(932,uint16 ,tprev);
  // UINT16 tnext;
  READ_FROM_BUFFER(933,uint16 ,tnext);
  // UINT16 tprev2;
  READ_FROM_BUFFER(934,uint16 ,tprev2);
  // if(EXTERNAL has_data)

  if (has_data())
  {
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_CONVERTER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_CONVERTER::__packer(__data_dest_t &__buffer)
{
  // UINT16 tpat;
  // UINT16 tprev;
  // UINT16 tnext;
  // UINT16 tprev2;
  // if(EXTERNAL has_data)

  if (has_data())
  {
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_CONVERTER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_PILEUP
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_PILEUP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_PILEUP)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_PILEUP
class LAND_CAMAC_PILEUP
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_PILEUP
class PACKER_LAND_CAMAC_PILEUP
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // tdc = CAMAC_LECROY_2277_1CH_HACK(channel=0,edge=1,high_byte=0);
    // tcal = CAMAC_LECROY_2277_1CH_HACK(channel=1,edge=1,high_byte=0);
  SINGLE(CAMAC_LECROY_2277_1CH_HACK,tdc);
  SINGLE(CAMAC_LECROY_2277_1CH_HACK,tcal);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_PILEUP);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_PILEUP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_PILEUP)
template<typename __data_src_t>
void LAND_CAMAC_PILEUP::__unpack(__data_src_t &__buffer)
{
  // select several

    // tdc = CAMAC_LECROY_2277_1CH_HACK(channel=0,edge=1,high_byte=0);
    // tcal = CAMAC_LECROY_2277_1CH_HACK(channel=1,edge=1,high_byte=0);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: CAMAC_LECROY_2277_1CH_HACK tdc: (s32) => (0xffff0000,0x00010000)
    // optimized match 2: CAMAC_LECROY_2277_1CH_HACK tcal: (s32) => (0xffff0000,0x00030000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1142,uint32,__match_peek);
    // differ = 00020000 : 17
    uint32 __match_index = 0 | /* 17,17 */ ((__match_peek >> 17) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1138,CAMAC_LECROY_2277_1CH_HACK,tdc,/*channel*/0,/*edge*/1,/*high_byte*/0);
        break;
      case 2:
        UNPACK_DECL(1140,CAMAC_LECROY_2277_1CH_HACK,tcal,/*channel*/1,/*edge*/1,/*high_byte*/0);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_PILEUP::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_PILEUP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_PILEUP)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_PILEUP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_PILEUP)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_PILEUP::__packer(__data_dest_t &__buffer)
{
  // select several

    // tdc = CAMAC_LECROY_2277_1CH_HACK(channel=0,edge=1,high_byte=0);
    // tcal = CAMAC_LECROY_2277_1CH_HACK(channel=1,edge=1,high_byte=0);
  {
    PACK_DECL(1138,CAMAC_LECROY_2277_1CH_HACK,tdc,/*channel*/0,/*edge*/1,/*high_byte*/0);
    PACK_DECL(1140,CAMAC_LECROY_2277_1CH_HACK,tcal,/*channel*/1,/*edge*/1,/*high_byte*/0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_PILEUP::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_SCALER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_SCALER
class LAND_CAMAC_SCALER
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_SCALER
class PACKER_LAND_CAMAC_SCALER
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // scaler0 = CAMAC_LECROY_4434(channels=32);
  // scaler1 = CAMAC_LECROY_4434(channels=32);
  // scaler2 = CAMAC_LECROY_4434(channels=32);
  // scaler3 = SOFT_SCALER32(channels=16);
  // if(EXTERNAL has_timestamp)

#ifndef __PSDC__
  uint32 has_timestamp() const;
#endif//!__PSDC__
    // UINT32 timestamp;
    uint32  timestamp;
    // UINT32 endianess
    // {
      //  0_31: 0x87654321;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } endianess;
  SINGLE(CAMAC_LECROY_4434,scaler0);
  SINGLE(CAMAC_LECROY_4434,scaler2);
  SINGLE(CAMAC_LECROY_4434,scaler1);
  SINGLE(SOFT_SCALER32,scaler3);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_SCALER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
template<typename __data_src_t>
void LAND_CAMAC_SCALER::__unpack(__data_src_t &__buffer)
{
  // scaler0 = CAMAC_LECROY_4434(channels=32);
  UNPACK_DECL(1091,CAMAC_LECROY_4434,scaler0,/*channels*/32);
  // scaler1 = CAMAC_LECROY_4434(channels=32);
  UNPACK_DECL(1092,CAMAC_LECROY_4434,scaler1,/*channels*/32);
  // scaler2 = CAMAC_LECROY_4434(channels=32);
  UNPACK_DECL(1093,CAMAC_LECROY_4434,scaler2,/*channels*/32);
  // scaler3 = SOFT_SCALER32(channels=16);
  UNPACK_DECL(1095,SOFT_SCALER32,scaler3,/*channels*/16);
  // if(EXTERNAL has_timestamp)

  if (has_timestamp())
  {
    // UINT32 timestamp;
    READ_FROM_BUFFER(1102,uint32 ,timestamp);
    // UINT32 endianess
    // {
      //  0_31: 0x87654321;
    // }
    READ_FROM_BUFFER_FULL(1103,uint32 ,endianess,endianess.u32);
    CHECK_BITS_EQUAL(1103,endianess.unnamed_0_31,0x87654321);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_SCALER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_SCALER::__packer(__data_dest_t &__buffer)
{
  // scaler0 = CAMAC_LECROY_4434(channels=32);
  PACK_DECL(1091,CAMAC_LECROY_4434,scaler0,/*channels*/32);
  // scaler1 = CAMAC_LECROY_4434(channels=32);
  PACK_DECL(1092,CAMAC_LECROY_4434,scaler1,/*channels*/32);
  // scaler2 = CAMAC_LECROY_4434(channels=32);
  PACK_DECL(1093,CAMAC_LECROY_4434,scaler2,/*channels*/32);
  // scaler3 = SOFT_SCALER32(channels=16);
  PACK_DECL(1095,SOFT_SCALER32,scaler3,/*channels*/16);
  // if(EXTERNAL has_timestamp)

  if (has_timestamp())
  {
    // UINT32 timestamp;
    // UINT32 endianess
    // {
      //  0_31: 0x87654321;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_SCALER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_START_STOP_STAMP
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_START_STOP_STAMP
class LAND_CAMAC_START_STOP_STAMP
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_START_STOP_STAMP
class PACKER_LAND_CAMAC_START_STOP_STAMP
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 timestamp;
  uint32  timestamp;
  // UINT32 endianess
  // {
    //  0_31: 0x87654321;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } endianess;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_START_STOP_STAMP);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
template<typename __data_src_t>
void LAND_CAMAC_START_STOP_STAMP::__unpack(__data_src_t &__buffer)
{
  // UINT32 timestamp;
  READ_FROM_BUFFER(1109,uint32 ,timestamp);
  // UINT32 endianess
  // {
    //  0_31: 0x87654321;
  // }
  READ_FROM_BUFFER_FULL(1110,uint32 ,endianess,endianess.u32);
  CHECK_BITS_EQUAL(1110,endianess.unnamed_0_31,0x87654321);
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_START_STOP_STAMP::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_START_STOP_STAMP::__packer(__data_dest_t &__buffer)
{
  // UINT32 timestamp;
  // UINT32 endianess
  // {
    //  0_31: 0x87654321;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_START_STOP_STAMP::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_TCAL_INFO
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_TCAL_INFO
class LAND_CAMAC_TCAL_INFO
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_TCAL_INFO
class PACKER_LAND_CAMAC_TCAL_INFO
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 info;
  uint32  info;
  // select several

    // rtcal = RANDOM_TCAL(id=231);
    // ntp = NTP_MESSAGE(id=239);
  SINGLE(RANDOM_TCAL,rtcal);
  SINGLE(NTP_MESSAGE,ntp);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_TCAL_INFO);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
template<typename __data_src_t>
void LAND_CAMAC_TCAL_INFO::__unpack(__data_src_t &__buffer)
{
  // UINT32 info;
  READ_FROM_BUFFER(1062,uint32 ,info);
  // select several

    // rtcal = RANDOM_TCAL(id=231);
    // ntp = NTP_MESSAGE(id=239);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: RANDOM_TCAL rtcal: (s32) => (0xfff00000,0xe7000000)
    // optimized match 2: NTP_MESSAGE ntp: (s32) => (0xfffe0000,0xef000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1068,uint32,__match_peek);
    // differ = 08000000 : 27
    uint32 __match_index = 0 | /* 27,27 */ ((__match_peek >> 27) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1066,RANDOM_TCAL,rtcal,/*id*/231);
        break;
      case 2:
        UNPACK_DECL(1067,NTP_MESSAGE,ntp,/*id*/239);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_TCAL_INFO::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_TCAL_INFO::__packer(__data_dest_t &__buffer)
{
  // UINT32 info;
  // select several

    // rtcal = RANDOM_TCAL(id=231);
    // ntp = NTP_MESSAGE(id=239);
  {
    PACK_DECL(1066,RANDOM_TCAL,rtcal,/*id*/231);
    PACK_DECL(1067,NTP_MESSAGE,ntp,/*id*/239);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_TCAL_INFO::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: MASTER_VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for MASTER_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(MASTER_VME)
#if !PACKER_CODE
# define DECLARED_UNPACK_MASTER_VME
class MASTER_VME
#else//PACKER_CODE
# define DECLARED_PACKER_MASTER_VME
class PACKER_MASTER_VME
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // vme = LAND_STD_VME();
  // select several

    // sampler_pos = TRLO_SAMPLER(id=223);
    // sampler_cb_sum = TRLO_SAMPLER(id=215);
  SINGLE(TRLO_SAMPLER,sampler_pos);
  SINGLE(TRLO_SAMPLER,sampler_cb_sum);
  SINGLE(LAND_STD_VME,vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(MASTER_VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for MASTER_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(MASTER_VME)
template<typename __data_src_t>
void MASTER_VME::__unpack(__data_src_t &__buffer)
{
  // vme = LAND_STD_VME();
  UNPACK_DECL(1235,LAND_STD_VME,vme);
  // select several

    // sampler_pos = TRLO_SAMPLER(id=223);
    // sampler_cb_sum = TRLO_SAMPLER(id=215);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRLO_SAMPLER sampler_pos: (s32) => (0xfffffc00,0xdf000000)
    // optimized match 2: TRLO_SAMPLER sampler_cb_sum: (s32) => (0xfffffc00,0xd7000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1241,uint32,__match_peek);
    // differ = 08000000 : 27
    uint32 __match_index = 0 | /* 27,27 */ ((__match_peek >> 27) & 0x00000001);
    static const sint8 __match_index_array[2] = { 2, 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1239,TRLO_SAMPLER,sampler_pos,/*id*/223);
        break;
      case 2:
        UNPACK_DECL(1240,TRLO_SAMPLER,sampler_cb_sum,/*id*/215);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,MASTER_VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for MASTER_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(MASTER_VME)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for MASTER_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(MASTER_VME)
template<typename __data_dest_t>
void PACKER_MASTER_VME::__packer(__data_dest_t &__buffer)
{
  // vme = LAND_STD_VME();
  PACK_DECL(1235,LAND_STD_VME,vme);
  // select several

    // sampler_pos = TRLO_SAMPLER(id=223);
    // sampler_cb_sum = TRLO_SAMPLER(id=215);
  {
    PACK_DECL(1239,TRLO_SAMPLER,sampler_pos,/*id*/223);
    PACK_DECL(1240,TRLO_SAMPLER,sampler_cb_sum,/*id*/215);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,MASTER_VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SIDEREM01_VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SIDEREM01_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SIDEREM01_VME)
#if !PACKER_CODE
# define DECLARED_UNPACK_SIDEREM01_VME
class SIDEREM01_VME
#else//PACKER_CODE
# define DECLARED_PACKER_SIDEREM01_VME
class PACKER_SIDEREM01_VME
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // external sst[0] = EXT_SST(siderem=1,gtb=0,sam=5,branch=1);
    // external sst[1] = EXT_SST(siderem=2,gtb=0,sam=5,branch=1);
    // external sst[2] = EXT_SST(siderem=1,gtb=1,sam=5,branch=1);
    // external sst[3] = EXT_SST(siderem=2,gtb=1,sam=5,branch=1);
    // external sst[4] = EXT_SST(siderem=1,gtb=0,sam=6,branch=1);
    // external sst[5] = EXT_SST(siderem=2,gtb=0,sam=6,branch=1);
    // external sst[6] = EXT_SST(siderem=1,gtb=1,sam=6,branch=1);
    // external sst[7] = EXT_SST(siderem=2,gtb=1,sam=6,branch=1);
  SINGLE(EXT_SST,sst[8]);
  // optional UINT32 error_marker
  // {
    //  0_31: 0x89abdcef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } error_marker;
  // optional UINT32 error_marker2
  // {
    //  0_31: 0x89abcdef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } error_marker2;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SIDEREM01_VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SIDEREM01_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SIDEREM01_VME)
template<typename __data_src_t>
void SIDEREM01_VME::__unpack(__data_src_t &__buffer)
{
  // select several

    // external sst[0] = EXT_SST(siderem=1,gtb=0,sam=5,branch=1);
    // external sst[1] = EXT_SST(siderem=2,gtb=0,sam=5,branch=1);
    // external sst[2] = EXT_SST(siderem=1,gtb=1,sam=5,branch=1);
    // external sst[3] = EXT_SST(siderem=2,gtb=1,sam=5,branch=1);
    // external sst[4] = EXT_SST(siderem=1,gtb=0,sam=6,branch=1);
    // external sst[5] = EXT_SST(siderem=2,gtb=0,sam=6,branch=1);
    // external sst[6] = EXT_SST(siderem=1,gtb=1,sam=6,branch=1);
    // external sst[7] = EXT_SST(siderem=2,gtb=1,sam=6,branch=1);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: EXT_SST sst[0]: could not get bits
    __buffer.peeking();
    MATCH_DECL(746,__match_no,1,EXT_SST,sst[0],/*sam*/5,/*gtb*/0,/*siderem*/1,/*branch*/1);
    MATCH_DECL(747,__match_no,2,EXT_SST,sst[1],/*sam*/5,/*gtb*/0,/*siderem*/2,/*branch*/1);
    MATCH_DECL(748,__match_no,3,EXT_SST,sst[2],/*sam*/5,/*gtb*/1,/*siderem*/1,/*branch*/1);
    MATCH_DECL(749,__match_no,4,EXT_SST,sst[3],/*sam*/5,/*gtb*/1,/*siderem*/2,/*branch*/1);
    MATCH_DECL(750,__match_no,5,EXT_SST,sst[4],/*sam*/6,/*gtb*/0,/*siderem*/1,/*branch*/1);
    MATCH_DECL(751,__match_no,6,EXT_SST,sst[5],/*sam*/6,/*gtb*/0,/*siderem*/2,/*branch*/1);
    MATCH_DECL(752,__match_no,7,EXT_SST,sst[6],/*sam*/6,/*gtb*/1,/*siderem*/1,/*branch*/1);
    MATCH_DECL(753,__match_no,8,EXT_SST,sst[7],/*sam*/6,/*gtb*/1,/*siderem*/2,/*branch*/1);
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(746,EXT_SST,sst[0],/*sam*/5,/*gtb*/0,/*siderem*/1,/*branch*/1);
        break;
      case 2:
        UNPACK_DECL(747,EXT_SST,sst[1],/*sam*/5,/*gtb*/0,/*siderem*/2,/*branch*/1);
        break;
      case 3:
        UNPACK_DECL(748,EXT_SST,sst[2],/*sam*/5,/*gtb*/1,/*siderem*/1,/*branch*/1);
        break;
      case 4:
        UNPACK_DECL(749,EXT_SST,sst[3],/*sam*/5,/*gtb*/1,/*siderem*/2,/*branch*/1);
        break;
      case 5:
        UNPACK_DECL(750,EXT_SST,sst[4],/*sam*/6,/*gtb*/0,/*siderem*/1,/*branch*/1);
        break;
      case 6:
        UNPACK_DECL(751,EXT_SST,sst[5],/*sam*/6,/*gtb*/0,/*siderem*/2,/*branch*/1);
        break;
      case 7:
        UNPACK_DECL(752,EXT_SST,sst[6],/*sam*/6,/*gtb*/1,/*siderem*/1,/*branch*/1);
        break;
      case 8:
        UNPACK_DECL(753,EXT_SST,sst[7],/*sam*/6,/*gtb*/1,/*siderem*/2,/*branch*/1);
        break;
    }
  }
  // optional UINT32 error_marker
  // {
    //  0_31: 0x89abdcef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } __error_marker;
  if (__buffer.empty()) goto data_done_8;
  PEEK_FROM_BUFFER_FULL(759,uint32 ,error_marker,__error_marker.u32);
  CHECK_JUMP_BITS_EQUAL(758,__error_marker.unnamed_0_31,0x89abdcef,data_done_8);
  error_marker.u32 = __error_marker.u32;
  __buffer.advance(sizeof(__error_marker.u32));
  data_done_8:;
  // optional UINT32 error_marker2
  // {
    //  0_31: 0x89abcdef;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } __error_marker2;
  if (__buffer.empty()) goto data_done_9;
  PEEK_FROM_BUFFER_FULL(764,uint32 ,error_marker2,__error_marker2.u32);
  CHECK_JUMP_BITS_EQUAL(763,__error_marker2.unnamed_0_31,0x89abcdef,data_done_9);
  error_marker2.u32 = __error_marker2.u32;
  __buffer.advance(sizeof(__error_marker2.u32));
  data_done_9:;
}
FORCE_IMPL_DATA_SRC_FCN(void,SIDEREM01_VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SIDEREM01_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SIDEREM01_VME)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SIDEREM01_VME.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(SIDEREM01_VME)
template<typename __data_dest_t>
void PACKER_SIDEREM01_VME::__packer(__data_dest_t &__buffer)
{
  // select several

    // external sst[0] = EXT_SST(siderem=1,gtb=0,sam=5,branch=1);
    // external sst[1] = EXT_SST(siderem=2,gtb=0,sam=5,branch=1);
    // external sst[2] = EXT_SST(siderem=1,gtb=1,sam=5,branch=1);
    // external sst[3] = EXT_SST(siderem=2,gtb=1,sam=5,branch=1);
    // external sst[4] = EXT_SST(siderem=1,gtb=0,sam=6,branch=1);
    // external sst[5] = EXT_SST(siderem=2,gtb=0,sam=6,branch=1);
    // external sst[6] = EXT_SST(siderem=1,gtb=1,sam=6,branch=1);
    // external sst[7] = EXT_SST(siderem=2,gtb=1,sam=6,branch=1);
  {
    PACK_DECL(746,EXT_SST,sst[0],/*sam*/5,/*gtb*/0,/*siderem*/1,/*branch*/1);
    PACK_DECL(747,EXT_SST,sst[1],/*sam*/5,/*gtb*/0,/*siderem*/2,/*branch*/1);
    PACK_DECL(748,EXT_SST,sst[2],/*sam*/5,/*gtb*/1,/*siderem*/1,/*branch*/1);
    PACK_DECL(749,EXT_SST,sst[3],/*sam*/5,/*gtb*/1,/*siderem*/2,/*branch*/1);
    PACK_DECL(750,EXT_SST,sst[4],/*sam*/6,/*gtb*/0,/*siderem*/1,/*branch*/1);
    PACK_DECL(751,EXT_SST,sst[5],/*sam*/6,/*gtb*/0,/*siderem*/2,/*branch*/1);
    PACK_DECL(752,EXT_SST,sst[6],/*sam*/6,/*gtb*/1,/*siderem*/1,/*branch*/1);
    PACK_DECL(753,EXT_SST,sst[7],/*sam*/6,/*gtb*/1,/*siderem*/2,/*branch*/1);
  }
  // optional UINT32 error_marker
  // {
    //  0_31: 0x89abdcef;
  // }
  // optional UINT32 error_marker2
  // {
    //  0_31: 0x89abcdef;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,SIDEREM01_VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TACQUILA_LAND_SUBEVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TACQUILA_LAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_LAND_SUBEVENT)
#if !PACKER_CODE
# define DECLARED_UNPACK_TACQUILA_LAND_SUBEVENT
class TACQUILA_LAND_SUBEVENT
#else//PACKER_CODE
# define DECLARED_PACKER_TACQUILA_LAND_SUBEVENT
class PACKER_TACQUILA_LAND_SUBEVENT
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // data_sam5_gtb0 = TACQUILA_DATA(sam=5,gtb=0);
    // data_sam6_gtb0 = TACQUILA_DATA(sam=6,gtb=0);
    // data_sam6_gtb1 = TACQUILA_DATA(sam=6,gtb=1);
  SINGLE(TACQUILA_DATA,data_sam5_gtb0);
  SINGLE(TACQUILA_DATA,data_sam6_gtb1);
  SINGLE(TACQUILA_DATA,data_sam6_gtb0);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TACQUILA_LAND_SUBEVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TACQUILA_LAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_LAND_SUBEVENT)
template<typename __data_src_t>
void TACQUILA_LAND_SUBEVENT::__unpack(__data_src_t &__buffer)
{
  // select several

    // data_sam5_gtb0 = TACQUILA_DATA(sam=5,gtb=0);
    // data_sam6_gtb0 = TACQUILA_DATA(sam=6,gtb=0);
    // data_sam6_gtb1 = TACQUILA_DATA(sam=6,gtb=1);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TACQUILA_DATA data_sam5_gtb0: (s32) => (0xff0ce000,0x50000000)
    // optimized match 2: TACQUILA_DATA data_sam6_gtb0: (s32) => (0xff0ce000,0x60000000)
    // optimized match 3: TACQUILA_DATA data_sam6_gtb1: (s32) => (0xff0ce000,0x61000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1414,uint32,__match_peek);
    // differ = 31000000 : 24 28 29
    uint32 __match_index = 0 | /* 24,24 */ ((__match_peek >> 24) & 0x00000001) | /* 28,29 */ ((__match_peek >> 27) & 0x00000006);
    static const sint8 __match_index_array[8] = { 0, 0, 1, 0, 2, 3, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1411,TACQUILA_DATA,data_sam5_gtb0,/*sam*/5,/*gtb*/0);
        break;
      case 2:
        UNPACK_DECL(1412,TACQUILA_DATA,data_sam6_gtb0,/*sam*/6,/*gtb*/0);
        break;
      case 3:
        UNPACK_DECL(1413,TACQUILA_DATA,data_sam6_gtb1,/*sam*/6,/*gtb*/1);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TACQUILA_LAND_SUBEVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TACQUILA_LAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_LAND_SUBEVENT)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TACQUILA_LAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_LAND_SUBEVENT)
template<typename __data_dest_t>
void PACKER_TACQUILA_LAND_SUBEVENT::__packer(__data_dest_t &__buffer)
{
  // select several

    // data_sam5_gtb0 = TACQUILA_DATA(sam=5,gtb=0);
    // data_sam6_gtb0 = TACQUILA_DATA(sam=6,gtb=0);
    // data_sam6_gtb1 = TACQUILA_DATA(sam=6,gtb=1);
  {
    PACK_DECL(1411,TACQUILA_DATA,data_sam5_gtb0,/*sam*/5,/*gtb*/0);
    PACK_DECL(1412,TACQUILA_DATA,data_sam6_gtb0,/*sam*/6,/*gtb*/0);
    PACK_DECL(1413,TACQUILA_DATA,data_sam6_gtb1,/*sam*/6,/*gtb*/1);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TACQUILA_LAND_SUBEVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TACQUILA_NEULAND_SUBEVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TACQUILA_NEULAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_NEULAND_SUBEVENT)
#if !PACKER_CODE
# define DECLARED_UNPACK_TACQUILA_NEULAND_SUBEVENT
class TACQUILA_NEULAND_SUBEVENT
#else//PACKER_CODE
# define DECLARED_PACKER_TACQUILA_NEULAND_SUBEVENT
class PACKER_TACQUILA_NEULAND_SUBEVENT
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // data_sam7_gtb0 = TACQUILA_DATA(sam=7,gtb=0);
    // data_sam7_gtb1 = TACQUILA_DATA(sam=7,gtb=1);
  SINGLE(TACQUILA_DATA,data_sam7_gtb0);
  SINGLE(TACQUILA_DATA,data_sam7_gtb1);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TACQUILA_NEULAND_SUBEVENT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TACQUILA_NEULAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_NEULAND_SUBEVENT)
template<typename __data_src_t>
void TACQUILA_NEULAND_SUBEVENT::__unpack(__data_src_t &__buffer)
{
  // select several

    // data_sam7_gtb0 = TACQUILA_DATA(sam=7,gtb=0);
    // data_sam7_gtb1 = TACQUILA_DATA(sam=7,gtb=1);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TACQUILA_DATA data_sam7_gtb0: (s32) => (0xff0ce000,0x70000000)
    // optimized match 2: TACQUILA_DATA data_sam7_gtb1: (s32) => (0xff0ce000,0x71000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1314,uint32,__match_peek);
    // differ = 01000000 : 24
    uint32 __match_index = 0 | /* 24,24 */ ((__match_peek >> 24) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1312,TACQUILA_DATA,data_sam7_gtb0,/*sam*/7,/*gtb*/0);
        break;
      case 2:
        UNPACK_DECL(1313,TACQUILA_DATA,data_sam7_gtb1,/*sam*/7,/*gtb*/1);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TACQUILA_NEULAND_SUBEVENT::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TACQUILA_NEULAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_NEULAND_SUBEVENT)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TACQUILA_NEULAND_SUBEVENT.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(TACQUILA_NEULAND_SUBEVENT)
template<typename __data_dest_t>
void PACKER_TACQUILA_NEULAND_SUBEVENT::__packer(__data_dest_t &__buffer)
{
  // select several

    // data_sam7_gtb0 = TACQUILA_DATA(sam=7,gtb=0);
    // data_sam7_gtb1 = TACQUILA_DATA(sam=7,gtb=1);
  {
    PACK_DECL(1312,TACQUILA_DATA,data_sam7_gtb0,/*sam*/7,/*gtb*/0);
    PACK_DECL(1313,TACQUILA_DATA,data_sam7_gtb1,/*sam*/7,/*gtb*/1);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,TACQUILA_NEULAND_SUBEVENT::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CRATE1
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CRATE1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE1)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CRATE1
class VME_CRATE1
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CRATE1
class PACKER_VME_CRATE1
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // vme = LAND_STD_VME();
  // select several

    // qdc792POS_ROLU = VME_CAEN_V775(geom=31,crate=1);
    // tdc775POS_ROLU = VME_CAEN_V775(geom=31,crate=130);
    // qdc792PIXEL = VME_CAEN_V775(geom=31,crate=3);
    // scaler = VME_CAEN_V830(geom=0);
  SINGLE(VME_CAEN_V775,qdc792POS_ROLU);
  SINGLE(VME_CAEN_V775,qdc792PIXEL);
  SINGLE(VME_CAEN_V775,tdc775POS_ROLU);
  SINGLE(VME_CAEN_V830,scaler);
  SINGLE(LAND_STD_VME,vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CRATE1);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CRATE1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE1)
template<typename __data_src_t>
void VME_CRATE1::__unpack(__data_src_t &__buffer)
{
  // vme = LAND_STD_VME();
  UNPACK_DECL(1246,LAND_STD_VME,vme);
  // select several

    // qdc792POS_ROLU = VME_CAEN_V775(geom=31,crate=1);
    // tdc775POS_ROLU = VME_CAEN_V775(geom=31,crate=130);
    // qdc792PIXEL = VME_CAEN_V775(geom=31,crate=3);
    // scaler = VME_CAEN_V830(geom=0);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V775 qdc792POS_ROLU: (s32) => (0xffffc0ff,0xfa010000)
    // optimized match 2: VME_CAEN_V775 tdc775POS_ROLU: (s32) => (0xffffc0ff,0xfa820000)
    // optimized match 3: VME_CAEN_V775 qdc792PIXEL: (s32) => (0xffffc0ff,0xfa030000)
    // optimized match 4: VME_CAEN_V830 scaler: (s32) => (0xff000000,0x04000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1255,uint32,__match_peek);
    // differ = fe830000 : 16 17 23 25 26 27 28 29 30 31
    // select on bit 31, partition: 1:1(d3) 0:3(d1)
    if (__match_peek & 0x80000000) {
      MATCH_DECL_QUICK(1250,__match_no,1,qdc792POS_ROLU,__match_peek,0xffffc0ff,0xfa010000);
      MATCH_DECL_QUICK(1251,__match_no,2,tdc775POS_ROLU,__match_peek,0xffffc0ff,0xfa820000);
      MATCH_DECL_QUICK(1252,__match_no,3,qdc792PIXEL,__match_peek,0xffffc0ff,0xfa030000);
    } else {
      UNPACK_DECL(1254,VME_CAEN_V830,scaler,/*geom*/0);
      continue;
    }
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1250,VME_CAEN_V775,qdc792POS_ROLU,/*geom*/31,/*crate*/1);
        break;
      case 2:
        UNPACK_DECL(1251,VME_CAEN_V775,tdc775POS_ROLU,/*geom*/31,/*crate*/130);
        break;
      case 3:
        UNPACK_DECL(1252,VME_CAEN_V775,qdc792PIXEL,/*geom*/31,/*crate*/3);
        break;
      case 4:
        UNPACK_DECL(1254,VME_CAEN_V830,scaler,/*geom*/0);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CRATE1::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CRATE1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE1)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CRATE1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE1)
template<typename __data_dest_t>
void PACKER_VME_CRATE1::__packer(__data_dest_t &__buffer)
{
  // vme = LAND_STD_VME();
  PACK_DECL(1246,LAND_STD_VME,vme);
  // select several

    // qdc792POS_ROLU = VME_CAEN_V775(geom=31,crate=1);
    // tdc775POS_ROLU = VME_CAEN_V775(geom=31,crate=130);
    // qdc792PIXEL = VME_CAEN_V775(geom=31,crate=3);
    // scaler = VME_CAEN_V830(geom=0);
  {
    PACK_DECL(1250,VME_CAEN_V775,qdc792POS_ROLU,/*geom*/31,/*crate*/1);
    PACK_DECL(1251,VME_CAEN_V775,tdc775POS_ROLU,/*geom*/31,/*crate*/130);
    PACK_DECL(1252,VME_CAEN_V775,qdc792PIXEL,/*geom*/31,/*crate*/3);
    PACK_DECL(1254,VME_CAEN_V830,scaler,/*geom*/0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CRATE1::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CRATE2
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CRATE2.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE2)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CRATE2
class VME_CRATE2
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CRATE2
class PACKER_VME_CRATE2
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // vme = LAND_STD_VME();
  // select several

    // qdc792TFW1 = VME_CAEN_V775(geom=31,crate=1);
    // qdc792TFW2 = VME_CAEN_V775(geom=31,crate=2);
    // tdc775TFW1 = VME_CAEN_V775(geom=31,crate=131);
    // tdc775TFW2 = VME_CAEN_V775(geom=31,crate=132);
    // tdc775NTF = VME_CAEN_V775(geom=31,crate=6);
    // qdc792NTF = VME_CAEN_V775(geom=31,crate=133);
    // qdc792GFI1 = VME_CAEN_V775(geom=31,crate=7);
    // qdc792GFI2 = VME_CAEN_V775(geom=31,crate=8);
    // qdc792GFI3 = VME_CAEN_V775(geom=31,crate=9);
    // qdc792MFITEST = VME_CAEN_V775(geom=31,crate=10);
    // scaler = VME_CAEN_V830(geom=0);
  SINGLE(VME_CAEN_V830,scaler);
  SINGLE(VME_CAEN_V775,qdc792TFW1);
  SINGLE(VME_CAEN_V775,tdc775TFW1);
  SINGLE(VME_CAEN_V775,qdc792TFW2);
  SINGLE(VME_CAEN_V775,tdc775TFW2);
  SINGLE(VME_CAEN_V775,tdc775NTF);
  SINGLE(VME_CAEN_V775,qdc792NTF);
  SINGLE(VME_CAEN_V775,qdc792GFI1);
  SINGLE(VME_CAEN_V775,qdc792GFI2);
  SINGLE(VME_CAEN_V775,qdc792GFI3);
  SINGLE(VME_CAEN_V775,qdc792MFITEST);
  SINGLE(LAND_STD_VME,vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CRATE2);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CRATE2.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE2)
template<typename __data_src_t>
void VME_CRATE2::__unpack(__data_src_t &__buffer)
{
  // vme = LAND_STD_VME();
  UNPACK_DECL(1260,LAND_STD_VME,vme);
  // select several

    // qdc792TFW1 = VME_CAEN_V775(geom=31,crate=1);
    // qdc792TFW2 = VME_CAEN_V775(geom=31,crate=2);
    // tdc775TFW1 = VME_CAEN_V775(geom=31,crate=131);
    // tdc775TFW2 = VME_CAEN_V775(geom=31,crate=132);
    // tdc775NTF = VME_CAEN_V775(geom=31,crate=6);
    // qdc792NTF = VME_CAEN_V775(geom=31,crate=133);
    // qdc792GFI1 = VME_CAEN_V775(geom=31,crate=7);
    // qdc792GFI2 = VME_CAEN_V775(geom=31,crate=8);
    // qdc792GFI3 = VME_CAEN_V775(geom=31,crate=9);
    // qdc792MFITEST = VME_CAEN_V775(geom=31,crate=10);
    // scaler = VME_CAEN_V830(geom=0);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V775 qdc792TFW1: (s32) => (0xffffc0ff,0xfa010000)
    // optimized match 2: VME_CAEN_V775 qdc792TFW2: (s32) => (0xffffc0ff,0xfa020000)
    // optimized match 3: VME_CAEN_V775 tdc775TFW1: (s32) => (0xffffc0ff,0xfa830000)
    // optimized match 4: VME_CAEN_V775 tdc775TFW2: (s32) => (0xffffc0ff,0xfa840000)
    // optimized match 5: VME_CAEN_V775 tdc775NTF: (s32) => (0xffffc0ff,0xfa060000)
    // optimized match 6: VME_CAEN_V775 qdc792NTF: (s32) => (0xffffc0ff,0xfa850000)
    // optimized match 7: VME_CAEN_V775 qdc792GFI1: (s32) => (0xffffc0ff,0xfa070000)
    // optimized match 8: VME_CAEN_V775 qdc792GFI2: (s32) => (0xffffc0ff,0xfa080000)
    // optimized match 9: VME_CAEN_V775 qdc792GFI3: (s32) => (0xffffc0ff,0xfa090000)
    // optimized match 10: VME_CAEN_V775 qdc792MFITEST: (s32) => (0xffffc0ff,0xfa0a0000)
    // optimized match 11: VME_CAEN_V830 scaler: (s32) => (0xff000000,0x04000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(1278,uint32,__match_peek);
    // differ = fe8f0000 : 16 17 18 19 23 25 26 27 28 29 30 31
    // select on bit 17, partition: 1:6(d5) 0:6(d5)
    if (__match_peek & 0x00020000) {
      // select on bit 18, partition: 1:4(d2) 0:3(d3)
      if (__match_peek & 0x00040000) {
        MATCH_DECL_QUICK(1268,__match_no,5,tdc775NTF,__match_peek,0xffffc0ff,0xfa060000);
        MATCH_DECL_QUICK(1271,__match_no,7,qdc792GFI1,__match_peek,0xffffc0ff,0xfa070000);
        MATCH_DECL_QUICK(1277,__match_no,11,scaler,__match_peek,0xff000000,0x04000000);
      } else {
        // select on bit 31, partition: 1:1(d3) 0:3(d1)
        if (__match_peek & 0x80000000) {
          MATCH_DECL_QUICK(1265,__match_no,2,qdc792TFW2,__match_peek,0xffffc0ff,0xfa020000);
          MATCH_DECL_QUICK(1266,__match_no,3,tdc775TFW1,__match_peek,0xffffc0ff,0xfa830000);
          MATCH_DECL_QUICK(1275,__match_no,10,qdc792MFITEST,__match_peek,0xffffc0ff,0xfa0a0000);
        } else {
          UNPACK_DECL(1277,VME_CAEN_V830,scaler,/*geom*/0);
          continue;
        }
      }
    } else {
      // select on bit 23, partition: 1:4(d2) 0:3(d3)
      if (__match_peek & 0x00800000) {
        MATCH_DECL_QUICK(1267,__match_no,4,tdc775TFW2,__match_peek,0xffffc0ff,0xfa840000);
        MATCH_DECL_QUICK(1269,__match_no,6,qdc792NTF,__match_peek,0xffffc0ff,0xfa850000);
        MATCH_DECL_QUICK(1277,__match_no,11,scaler,__match_peek,0xff000000,0x04000000);
      } else {
        // select on bit 31, partition: 1:1(d3) 0:3(d1)
        if (__match_peek & 0x80000000) {
          MATCH_DECL_QUICK(1264,__match_no,1,qdc792TFW1,__match_peek,0xffffc0ff,0xfa010000);
          MATCH_DECL_QUICK(1272,__match_no,8,qdc792GFI2,__match_peek,0xffffc0ff,0xfa080000);
          MATCH_DECL_QUICK(1273,__match_no,9,qdc792GFI3,__match_peek,0xffffc0ff,0xfa090000);
        } else {
          UNPACK_DECL(1277,VME_CAEN_V830,scaler,/*geom*/0);
          continue;
        }
      }
    }
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(1264,VME_CAEN_V775,qdc792TFW1,/*geom*/31,/*crate*/1);
        break;
      case 2:
        UNPACK_DECL(1265,VME_CAEN_V775,qdc792TFW2,/*geom*/31,/*crate*/2);
        break;
      case 3:
        UNPACK_DECL(1266,VME_CAEN_V775,tdc775TFW1,/*geom*/31,/*crate*/131);
        break;
      case 4:
        UNPACK_DECL(1267,VME_CAEN_V775,tdc775TFW2,/*geom*/31,/*crate*/132);
        break;
      case 5:
        UNPACK_DECL(1268,VME_CAEN_V775,tdc775NTF,/*geom*/31,/*crate*/6);
        break;
      case 6:
        UNPACK_DECL(1269,VME_CAEN_V775,qdc792NTF,/*geom*/31,/*crate*/133);
        break;
      case 7:
        UNPACK_DECL(1271,VME_CAEN_V775,qdc792GFI1,/*geom*/31,/*crate*/7);
        break;
      case 8:
        UNPACK_DECL(1272,VME_CAEN_V775,qdc792GFI2,/*geom*/31,/*crate*/8);
        break;
      case 9:
        UNPACK_DECL(1273,VME_CAEN_V775,qdc792GFI3,/*geom*/31,/*crate*/9);
        break;
      case 10:
        UNPACK_DECL(1275,VME_CAEN_V775,qdc792MFITEST,/*geom*/31,/*crate*/10);
        break;
      case 11:
        UNPACK_DECL(1277,VME_CAEN_V830,scaler,/*geom*/0);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CRATE2::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CRATE2.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE2)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CRATE2.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(VME_CRATE2)
template<typename __data_dest_t>
void PACKER_VME_CRATE2::__packer(__data_dest_t &__buffer)
{
  // vme = LAND_STD_VME();
  PACK_DECL(1260,LAND_STD_VME,vme);
  // select several

    // qdc792TFW1 = VME_CAEN_V775(geom=31,crate=1);
    // qdc792TFW2 = VME_CAEN_V775(geom=31,crate=2);
    // tdc775TFW1 = VME_CAEN_V775(geom=31,crate=131);
    // tdc775TFW2 = VME_CAEN_V775(geom=31,crate=132);
    // tdc775NTF = VME_CAEN_V775(geom=31,crate=6);
    // qdc792NTF = VME_CAEN_V775(geom=31,crate=133);
    // qdc792GFI1 = VME_CAEN_V775(geom=31,crate=7);
    // qdc792GFI2 = VME_CAEN_V775(geom=31,crate=8);
    // qdc792GFI3 = VME_CAEN_V775(geom=31,crate=9);
    // qdc792MFITEST = VME_CAEN_V775(geom=31,crate=10);
    // scaler = VME_CAEN_V830(geom=0);
  {
    PACK_DECL(1264,VME_CAEN_V775,qdc792TFW1,/*geom*/31,/*crate*/1);
    PACK_DECL(1265,VME_CAEN_V775,qdc792TFW2,/*geom*/31,/*crate*/2);
    PACK_DECL(1266,VME_CAEN_V775,tdc775TFW1,/*geom*/31,/*crate*/131);
    PACK_DECL(1267,VME_CAEN_V775,tdc775TFW2,/*geom*/31,/*crate*/132);
    PACK_DECL(1268,VME_CAEN_V775,tdc775NTF,/*geom*/31,/*crate*/6);
    PACK_DECL(1269,VME_CAEN_V775,qdc792NTF,/*geom*/31,/*crate*/133);
    PACK_DECL(1271,VME_CAEN_V775,qdc792GFI1,/*geom*/31,/*crate*/7);
    PACK_DECL(1272,VME_CAEN_V775,qdc792GFI2,/*geom*/31,/*crate*/8);
    PACK_DECL(1273,VME_CAEN_V775,qdc792GFI3,/*geom*/31,/*crate*/9);
    PACK_DECL(1275,VME_CAEN_V775,qdc792MFITEST,/*geom*/31,/*crate*/10);
    PACK_DECL(1277,VME_CAEN_V830,scaler,/*geom*/0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,VME_CRATE2::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // cros3 = CROS3_SUBEVENT(type=85,subtype=0x2134);
  // cros3_rewrite = CROS3_REWRITE_SUBEVENT(type=85,subtype=0x213e);
  // sst = SIDEREM01_VME(type=82,subtype=0x2008,control=3);
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // acq = DUMMY(type=35,subtype=0xc1c);
  // vme1 = VME_CRATE1(type=88,subtype=0x2260,control=5,subcrate=1);
  // vme2 = VME_CRATE2(type=88,subtype=0x2260,control=5,subcrate=2);
  // vme_cbr = CB_VME_RIGHT(type=88,subtype=0x2260,control=5,subcrate=3);
  // vme_cbl = CB_VME_LEFT(type=88,subtype=0x2260,control=5,subcrate=4);
  // vme_master = MASTER_VME(type=88,subtype=0x2260,subcrate=6);
  // camac_tcal_info = LAND_CAMAC_TCAL_INFO(type=0x26ce,subtype=0xc7f);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // pileup = LAND_CAMAC_PILEUP(type=34,subtype=0xdac,control=1);
  // tacquila = TACQUILA_LAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=0);
  // neuland = TACQUILA_NEULAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=1);
  // ignore_unknown_subevent;
SINGLE(LAND_CAMAC_PILEUP,pileup);
SINGLE(SIDEREM01_VME,sst);
SINGLE(CROS3_SUBEVENT,cros3);
SINGLE(CROS3_REWRITE_SUBEVENT,cros3_rewrite);
SINGLE(LAND_CAMAC_CONVERTER,camac);
SINGLE(DUMMY,acq);
SINGLE(VME_CRATE1,vme1);
SINGLE(VME_CRATE2,vme2);
SINGLE(CB_VME_RIGHT,vme_cbr);
SINGLE(CB_VME_LEFT,vme_cbl);
SINGLE(MASTER_VME,vme_master);
SINGLE(LAND_CAMAC_TCAL_INFO,camac_tcal_info);
SINGLE(LAND_CAMAC_SCALER,camac_scalers);
SINGLE(TACQUILA_LAND_SUBEVENT,tacquila);
SINGLE(TACQUILA_NEULAND_SUBEVENT,neuland);
public:
#ifndef __PSDC__
  bitsone<16> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return true; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // cros3 = CROS3_SUBEVENT(type=85,subtype=0x2134);
  // cros3_rewrite = CROS3_REWRITE_SUBEVENT(type=85,subtype=0x213e);
  // sst = SIDEREM01_VME(type=82,subtype=0x2008,control=3);
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // acq = DUMMY(type=35,subtype=0xc1c);
  // vme1 = VME_CRATE1(type=88,subtype=0x2260,control=5,subcrate=1);
  // vme2 = VME_CRATE2(type=88,subtype=0x2260,control=5,subcrate=2);
  // vme_cbr = CB_VME_RIGHT(type=88,subtype=0x2260,control=5,subcrate=3);
  // vme_cbl = CB_VME_LEFT(type=88,subtype=0x2260,control=5,subcrate=4);
  // vme_master = MASTER_VME(type=88,subtype=0x2260,subcrate=6);
  // camac_tcal_info = LAND_CAMAC_TCAL_INFO(type=0x26ce,subtype=0xc7f);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // pileup = LAND_CAMAC_PILEUP(type=34,subtype=0xdac,control=1);
  // tacquila = TACQUILA_LAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=0);
  // neuland = TACQUILA_NEULAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=1);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1435,__match_no,1,((VES10_1_type==85)&&(VES10_1_subtype==0x2134)),cros3);
  MATCH_SUBEVENT_DECL(1437,__match_no,2,((VES10_1_type==85)&&(VES10_1_subtype==0x213e)),cros3_rewrite);
  MATCH_SUBEVENT_DECL(1439,__match_no,3,((VES10_1_type==82)&&(VES10_1_subtype==0x2008)&&(VES10_1_control==3)),sst);
  MATCH_SUBEVENT_DECL(1440,__match_no,4,((VES10_1_type==34)&&(VES10_1_subtype==0xc80)),camac);
  MATCH_SUBEVENT_DECL(1441,__match_no,5,((VES10_1_type==35)&&(VES10_1_subtype==0xc1c)),acq);
  MATCH_SUBEVENT_DECL(1443,__match_no,6,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),vme1);
  MATCH_SUBEVENT_DECL(1444,__match_no,7,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==2)),vme2);
  MATCH_SUBEVENT_DECL(1446,__match_no,8,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==3)),vme_cbr);
  MATCH_SUBEVENT_DECL(1447,__match_no,9,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==4)),vme_cbl);
  MATCH_SUBEVENT_DECL(1449,__match_no,10,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_subcrate==6)),vme_master);
  MATCH_SUBEVENT_DECL(1451,__match_no,11,((VES10_1_type==0x26ce)&&(VES10_1_subtype==0xc7f)),camac_tcal_info);
  MATCH_SUBEVENT_DECL(1452,__match_no,12,((VES10_1_type==34)&&(VES10_1_subtype==0xc1c)),camac_scalers);
  MATCH_SUBEVENT_DECL(1453,__match_no,13,((VES10_1_type==34)&&(VES10_1_subtype==0xdac)&&(VES10_1_control==1)),pileup);
  MATCH_SUBEVENT_DECL(1455,__match_no,14,((VES10_1_type==94)&&(VES10_1_subtype==0x24b8)&&(VES10_1_subcrate==0)),tacquila);
  MATCH_SUBEVENT_DECL(1456,__match_no,15,((VES10_1_type==94)&&(VES10_1_subtype==0x24b8)&&(VES10_1_subcrate==1)),neuland);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1435,CROS3_SUBEVENT,cros3,0);
      UNPACK_SUBEVENT_DECL(1435,0,CROS3_SUBEVENT,cros3);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1437,CROS3_REWRITE_SUBEVENT,cros3_rewrite,1);
      UNPACK_SUBEVENT_DECL(1437,0,CROS3_REWRITE_SUBEVENT,cros3_rewrite);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1439,SIDEREM01_VME,sst,2);
      UNPACK_SUBEVENT_DECL(1439,0,SIDEREM01_VME,sst);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1440,LAND_CAMAC_CONVERTER,camac,3);
      UNPACK_SUBEVENT_DECL(1440,0,LAND_CAMAC_CONVERTER,camac);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1441,DUMMY,acq,4);
      UNPACK_SUBEVENT_DECL(1441,0,DUMMY,acq);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1443,VME_CRATE1,vme1,5);
      UNPACK_SUBEVENT_DECL(1443,0,VME_CRATE1,vme1);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1444,VME_CRATE2,vme2,6);
      UNPACK_SUBEVENT_DECL(1444,0,VME_CRATE2,vme2);
      break;
    case 8:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1446,CB_VME_RIGHT,vme_cbr,7);
      UNPACK_SUBEVENT_DECL(1446,0,CB_VME_RIGHT,vme_cbr);
      break;
    case 9:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1447,CB_VME_LEFT,vme_cbl,8);
      UNPACK_SUBEVENT_DECL(1447,0,CB_VME_LEFT,vme_cbl);
      break;
    case 10:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1449,MASTER_VME,vme_master,9);
      UNPACK_SUBEVENT_DECL(1449,0,MASTER_VME,vme_master);
      break;
    case 11:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1451,LAND_CAMAC_TCAL_INFO,camac_tcal_info,10);
      UNPACK_SUBEVENT_DECL(1451,0,LAND_CAMAC_TCAL_INFO,camac_tcal_info);
      break;
    case 12:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1452,LAND_CAMAC_SCALER,camac_scalers,11);
      UNPACK_SUBEVENT_DECL(1452,0,LAND_CAMAC_SCALER,camac_scalers);
      break;
    case 13:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1453,LAND_CAMAC_PILEUP,pileup,12);
      UNPACK_SUBEVENT_DECL(1453,0,LAND_CAMAC_PILEUP,pileup);
      break;
    case 14:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1455,TACQUILA_LAND_SUBEVENT,tacquila,13);
      UNPACK_SUBEVENT_DECL(1455,0,TACQUILA_LAND_SUBEVENT,tacquila);
      break;
    case 15:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1456,TACQUILA_NEULAND_SUBEVENT,neuland,14);
      UNPACK_SUBEVENT_DECL(1456,0,TACQUILA_NEULAND_SUBEVENT,neuland);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // cros3 = CROS3_SUBEVENT(type=85,subtype=0x2134);
  // cros3_rewrite = CROS3_REWRITE_SUBEVENT(type=85,subtype=0x213e);
  // sst = SIDEREM01_VME(type=82,subtype=0x2008,control=3);
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // acq = DUMMY(type=35,subtype=0xc1c);
  // vme1 = VME_CRATE1(type=88,subtype=0x2260,control=5,subcrate=1);
  // vme2 = VME_CRATE2(type=88,subtype=0x2260,control=5,subcrate=2);
  // vme_cbr = CB_VME_RIGHT(type=88,subtype=0x2260,control=5,subcrate=3);
  // vme_cbl = CB_VME_LEFT(type=88,subtype=0x2260,control=5,subcrate=4);
  // vme_master = MASTER_VME(type=88,subtype=0x2260,subcrate=6);
  // camac_tcal_info = LAND_CAMAC_TCAL_INFO(type=0x26ce,subtype=0xc7f);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // pileup = LAND_CAMAC_PILEUP(type=34,subtype=0xdac,control=1);
  // tacquila = TACQUILA_LAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=0);
  // neuland = TACQUILA_NEULAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=1);
  // ignore_unknown_subevent;
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // cros3 = CROS3_SUBEVENT(type=85,subtype=0x2134);
  // cros3_rewrite = CROS3_REWRITE_SUBEVENT(type=85,subtype=0x213e);
  // sst = SIDEREM01_VME(type=82,subtype=0x2008,control=3);
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // acq = DUMMY(type=35,subtype=0xc1c);
  // vme1 = VME_CRATE1(type=88,subtype=0x2260,control=5,subcrate=1);
  // vme2 = VME_CRATE2(type=88,subtype=0x2260,control=5,subcrate=2);
  // vme_cbr = CB_VME_RIGHT(type=88,subtype=0x2260,control=5,subcrate=3);
  // vme_cbl = CB_VME_LEFT(type=88,subtype=0x2260,control=5,subcrate=4);
  // vme_master = MASTER_VME(type=88,subtype=0x2260,subcrate=6);
  // camac_tcal_info = LAND_CAMAC_TCAL_INFO(type=0x26ce,subtype=0xc7f);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // pileup = LAND_CAMAC_PILEUP(type=34,subtype=0xdac,control=1);
  // tacquila = TACQUILA_LAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=0);
  // neuland = TACQUILA_NEULAND_SUBEVENT(type=94,subtype=0x24b8,subcrate=1);
  // ignore_unknown_subevent;
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(1435,__match_no,1,((VES10_1_type==85)&&(VES10_1_subtype==0x2134)),cros3);
  MATCH_SUBEVENT_DECL(1437,__match_no,2,((VES10_1_type==85)&&(VES10_1_subtype==0x213e)),cros3_rewrite);
  MATCH_SUBEVENT_DECL(1439,__match_no,3,((VES10_1_type==82)&&(VES10_1_subtype==0x2008)&&(VES10_1_control==3)),sst);
  MATCH_SUBEVENT_DECL(1440,__match_no,4,((VES10_1_type==34)&&(VES10_1_subtype==0xc80)),camac);
  MATCH_SUBEVENT_DECL(1441,__match_no,5,((VES10_1_type==35)&&(VES10_1_subtype==0xc1c)),acq);
  MATCH_SUBEVENT_DECL(1443,__match_no,6,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==1)),vme1);
  MATCH_SUBEVENT_DECL(1444,__match_no,7,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==2)),vme2);
  MATCH_SUBEVENT_DECL(1446,__match_no,8,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==3)),vme_cbr);
  MATCH_SUBEVENT_DECL(1447,__match_no,9,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==5)&&(VES10_1_subcrate==4)),vme_cbl);
  MATCH_SUBEVENT_DECL(1449,__match_no,10,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_subcrate==6)),vme_master);
  MATCH_SUBEVENT_DECL(1451,__match_no,11,((VES10_1_type==0x26ce)&&(VES10_1_subtype==0xc7f)),camac_tcal_info);
  MATCH_SUBEVENT_DECL(1452,__match_no,12,((VES10_1_type==34)&&(VES10_1_subtype==0xc1c)),camac_scalers);
  MATCH_SUBEVENT_DECL(1453,__match_no,13,((VES10_1_type==34)&&(VES10_1_subtype==0xdac)&&(VES10_1_control==1)),pileup);
  MATCH_SUBEVENT_DECL(1455,__match_no,14,((VES10_1_type==94)&&(VES10_1_subtype==0x24b8)&&(VES10_1_subcrate==0)),tacquila);
  MATCH_SUBEVENT_DECL(1456,__match_no,15,((VES10_1_type==94)&&(VES10_1_subtype==0x24b8)&&(VES10_1_subcrate==1)),neuland);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1435,CROS3_SUBEVENT,cros3,0);
      REVOKE_SUBEVENT_DECL(1435,0,CROS3_SUBEVENT,cros3);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1437,CROS3_REWRITE_SUBEVENT,cros3_rewrite,1);
      REVOKE_SUBEVENT_DECL(1437,0,CROS3_REWRITE_SUBEVENT,cros3_rewrite);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1439,SIDEREM01_VME,sst,2);
      REVOKE_SUBEVENT_DECL(1439,0,SIDEREM01_VME,sst);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1440,LAND_CAMAC_CONVERTER,camac,3);
      REVOKE_SUBEVENT_DECL(1440,0,LAND_CAMAC_CONVERTER,camac);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1441,DUMMY,acq,4);
      REVOKE_SUBEVENT_DECL(1441,0,DUMMY,acq);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1443,VME_CRATE1,vme1,5);
      REVOKE_SUBEVENT_DECL(1443,0,VME_CRATE1,vme1);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1444,VME_CRATE2,vme2,6);
      REVOKE_SUBEVENT_DECL(1444,0,VME_CRATE2,vme2);
      break;
    case 8:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1446,CB_VME_RIGHT,vme_cbr,7);
      REVOKE_SUBEVENT_DECL(1446,0,CB_VME_RIGHT,vme_cbr);
      break;
    case 9:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1447,CB_VME_LEFT,vme_cbl,8);
      REVOKE_SUBEVENT_DECL(1447,0,CB_VME_LEFT,vme_cbl);
      break;
    case 10:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1449,MASTER_VME,vme_master,9);
      REVOKE_SUBEVENT_DECL(1449,0,MASTER_VME,vme_master);
      break;
    case 11:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1451,LAND_CAMAC_TCAL_INFO,camac_tcal_info,10);
      REVOKE_SUBEVENT_DECL(1451,0,LAND_CAMAC_TCAL_INFO,camac_tcal_info);
      break;
    case 12:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1452,LAND_CAMAC_SCALER,camac_scalers,11);
      REVOKE_SUBEVENT_DECL(1452,0,LAND_CAMAC_SCALER,camac_scalers);
      break;
    case 13:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1453,LAND_CAMAC_PILEUP,pileup,12);
      REVOKE_SUBEVENT_DECL(1453,0,LAND_CAMAC_PILEUP,pileup);
      break;
    case 14:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1455,TACQUILA_LAND_SUBEVENT,tacquila,13);
      REVOKE_SUBEVENT_DECL(1455,0,TACQUILA_LAND_SUBEVENT,tacquila);
      break;
    case 15:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(1456,TACQUILA_NEULAND_SUBEVENT,neuland,14);
      REVOKE_SUBEVENT_DECL(1456,0,TACQUILA_NEULAND_SUBEVENT,neuland);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "cros3", "type=85:subtype=0x2134" },
{ "cros3_rewrite", "type=85:subtype=0x213e" },
{ "sst", "type=82:subtype=0x2008:control=3" },
{ "camac", "type=34:subtype=0xc80" },
{ "acq", "type=35:subtype=0xc1c" },
{ "vme1", "type=88:subtype=0x2260:control=5:subcrate=1" },
{ "vme2", "type=88:subtype=0x2260:control=5:subcrate=2" },
{ "vme_cbr", "type=88:subtype=0x2260:control=5:subcrate=3" },
{ "vme_cbl", "type=88:subtype=0x2260:control=5:subcrate=4" },
{ "vme_master", "type=88:subtype=0x2260:subcrate=6" },
{ "camac_tcal_info", "type=0x26ce:subtype=0xc7f" },
{ "camac_scalers", "type=34:subtype=0xc1c" },
{ "pileup", "type=34:subtype=0xdac:control=1" },
{ "tacquila", "type=94:subtype=0x24b8:subcrate=0" },
{ "neuland", "type=94:subtype=0x24b8:subcrate=1" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

//DUMPY: 16 1
//DUMPY: 2 0
class raw_event_NTF
{
public:
  DATA12 E;
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_NTF);
#endif//!__PSDC__
} ;

//DUMPY: 7 0
//DUMPY: 1 0
class raw_event_CXB
{
public:
  DATA12 T;
  DATA14_OVERFLOW E;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_CXB);
#endif//!__PSDC__
} ;

//DUMPY: 8 1
//DUMPY: 2 0
class raw_event_DTF
{
public:
  DATA12 E;
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_DTF);
#endif//!__PSDC__
} ;

//DUMPY: 2 0
//DUMPY: 34 1
class raw_event_GFI
{
public:
  DATA12 E;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_GFI);
#endif//!__PSDC__
} ;

//DUMPY: 1 0
//DUMPY: 4 0
class raw_event_POS
{
public:
  DATA12 E;
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_POS);
#endif//!__PSDC__
} ;

//DUMPY: 1 0
//DUMPY: 4 0
class raw_event_ROL
{
public:
  DATA12 E;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_ROL);
#endif//!__PSDC__
} ;

//DUMPY: 1 0
//DUMPY: 5 0
class raw_event_PSP
{
public:
  DATA14_OVERFLOW E;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_PSP);
#endif//!__PSDC__
} ;

//DUMPY: 2 0
//DUMPY: 2 0
class raw_event_SCI
{
public:
  DATA12 E;
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_SCI);
#endif//!__PSDC__
} ;

//DUMPY: 16 0
//DUMPY: 1 0
class raw_event_XBTRIG
{
public:
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_XBTRIG);
#endif//!__PSDC__
} ;

//DUMPY: 162 1
//DUMPY: 2 0
class raw_event_XB
{
public:
  DATA14_OVERFLOW E;
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_XB);
#endif//!__PSDC__
} ;

//DUMPY: 8 0
//DUMPY: 1024 1
class raw_event_SST
{
public:
  DATA12 E;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_SST);
#endif//!__PSDC__
} ;

//DUMPY: 16 2
class raw_event_PILEUP
{
public:
  DATA16 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_PILEUP);
#endif//!__PSDC__
} ;

//DUMPY: 16 2
class raw_event_TCALMT
{
public:
  DATA16 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TCALMT);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
//DUMPY: 16 1
//DUMPY: 2 0
  raw_array_zero_suppress_1<raw_event_NTF,raw_event_NTF[2],16,2>
  /* {
  public:
    DATA12 E;
    DATA12 T;
  } */ NTF;
//DUMPY: 7 0
//DUMPY: 1 0
  raw_event_CXB
  /* {
  public:
    DATA12 T;
    DATA14_OVERFLOW E;
  } */ CXB[7][1];
//DUMPY: 8 1
//DUMPY: 2 0
  raw_array_zero_suppress_1<raw_event_DTF,raw_event_DTF[2],8,2>
  /* {
  public:
    DATA12 E;
    DATA12 T;
  } */ DTF;
//DUMPY: 2 0
//DUMPY: 34 1
  raw_array_zero_suppress<raw_event_GFI,raw_event_GFI,34>
  /* {
  public:
    DATA12 E;
  } */ GFI[2];
//DUMPY: 1 0
//DUMPY: 4 0
  raw_event_POS
  /* {
  public:
    DATA12 E;
    DATA12 T;
  } */ POS[1][4];
//DUMPY: 1 0
//DUMPY: 4 0
  raw_event_ROL
  /* {
  public:
    DATA12 E;
  } */ ROL[1][4];
//DUMPY: 1 0
//DUMPY: 5 0
  raw_event_PSP
  /* {
  public:
    DATA14_OVERFLOW E;
  } */ PSP[1][5];
//DUMPY: 2 0
//DUMPY: 2 0
  raw_event_SCI
  /* {
  public:
    DATA12 E;
    DATA12 T;
  } */ SCI[2][2];
//DUMPY: 16 0
//DUMPY: 1 0
  raw_event_XBTRIG
  /* {
  public:
    DATA12 T;
  } */ XBTRIG[16][1];
//DUMPY: 162 1
//DUMPY: 2 0
  raw_array_zero_suppress_1<raw_event_XB,raw_event_XB[2],162,2>
  /* {
  public:
    DATA14_OVERFLOW E;
    DATA12 T;
  } */ XB;
//DUMPY: 8 0
//DUMPY: 1024 1
  raw_array_zero_suppress<raw_event_SST,raw_event_SST,1024>
  /* {
  public:
    DATA12 E;
  } */ SST[8];
//DUMPY: 16 2
  raw_list_ii_zero_suppress<raw_event_PILEUP,raw_event_PILEUP,16>
  /* {
  public:
    DATA16 T;
  } */ PILEUP;
//DUMPY: 16 2
  raw_list_ii_zero_suppress<raw_event_TCALMT,raw_event_TCALMT,16>
  /* {
  public:
    DATA16 T;
  } */ TCALMT;
  float TCALT;
  float TCALE;
  float TPREV;
  float TNEXT;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA12,CXB001_1_T,vme2.tdc775TFW1.data[9],CXB[0][0].T);
SIGNAL_MAPPING(DATA12,CXB002_1_T,vme2.tdc775TFW1.data[10],CXB[1][0].T);
SIGNAL_MAPPING(DATA12,CXB003_1_T,vme2.tdc775TFW1.data[11],CXB[2][0].T);
SIGNAL_MAPPING(DATA12,CXB004_1_T,vme2.tdc775TFW1.data[12],CXB[3][0].T);
SIGNAL_MAPPING(DATA12,CXB005_1_T,vme2.tdc775TFW1.data[13],CXB[4][0].T);
SIGNAL_MAPPING(DATA12,CXB006_1_T,vme2.tdc775TFW1.data[14],CXB[5][0].T);
SIGNAL_MAPPING(DATA14_OVERFLOW,CXB007_1_E,vme_cbr.adc[1].data[4],CXB[6][0].E);
SIGNAL_MAPPING(DATA12,CXB007_1_T,vme_cbr.tdc.data[68],CXB[6][0].T);
SIGNAL_MAPPING(DATA12,DTF01_1_E,vme2.qdc792TFW1.data[17],DTF[0][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,0)*/
SIGNAL_MAPPING(DATA12,DTF01_1_T,vme2.tdc775TFW2.data[17],DTF[0][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,0)*/
SIGNAL_MAPPING(DATA12,DTF01_2_E,vme2.qdc792TFW2.data[17],DTF[0][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,0)*/
SIGNAL_MAPPING(DATA12,DTF01_2_T,vme2.tdc775TFW2.data[25],DTF[0][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,0)*/
SIGNAL_MAPPING(DATA12,DTF02_1_E,vme2.qdc792TFW1.data[18],DTF[1][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,1)*/
SIGNAL_MAPPING(DATA12,DTF02_1_T,vme2.tdc775TFW2.data[18],DTF[1][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,1)*/
SIGNAL_MAPPING(DATA12,DTF02_2_E,vme2.qdc792TFW2.data[18],DTF[1][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,1)*/
SIGNAL_MAPPING(DATA12,DTF02_2_T,vme2.tdc775TFW2.data[26],DTF[1][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,1)*/
SIGNAL_MAPPING(DATA12,DTF03_1_E,vme2.qdc792TFW1.data[19],DTF[2][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,2)*/
SIGNAL_MAPPING(DATA12,DTF03_1_T,vme2.tdc775TFW2.data[19],DTF[2][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,2)*/
SIGNAL_MAPPING(DATA12,DTF03_2_E,vme2.qdc792TFW2.data[19],DTF[2][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,2)*/
SIGNAL_MAPPING(DATA12,DTF03_2_T,vme2.tdc775TFW2.data[27],DTF[2][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,2)*/
SIGNAL_MAPPING(DATA12,DTF04_1_E,vme2.qdc792TFW1.data[20],DTF[3][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,3)*/
SIGNAL_MAPPING(DATA12,DTF04_1_T,vme2.tdc775TFW2.data[20],DTF[3][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,3)*/
SIGNAL_MAPPING(DATA12,DTF04_2_E,vme2.qdc792TFW2.data[20],DTF[3][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,3)*/
SIGNAL_MAPPING(DATA12,DTF04_2_T,vme2.tdc775TFW2.data[28],DTF[3][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,3)*/
SIGNAL_MAPPING(DATA12,DTF05_1_E,vme2.qdc792TFW1.data[21],DTF[4][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,4)*/
SIGNAL_MAPPING(DATA12,DTF05_1_T,vme2.tdc775TFW2.data[21],DTF[4][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,4)*/
SIGNAL_MAPPING(DATA12,DTF05_2_E,vme2.qdc792TFW2.data[21],DTF[4][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,4)*/
SIGNAL_MAPPING(DATA12,DTF05_2_T,vme2.tdc775TFW2.data[29],DTF[4][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,4)*/
SIGNAL_MAPPING(DATA12,DTF06_1_E,vme2.qdc792TFW1.data[22],DTF[5][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,5)*/
SIGNAL_MAPPING(DATA12,DTF06_1_T,vme2.tdc775TFW2.data[22],DTF[5][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,5)*/
SIGNAL_MAPPING(DATA12,DTF06_2_E,vme2.qdc792TFW2.data[22],DTF[5][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,5)*/
SIGNAL_MAPPING(DATA12,DTF06_2_T,vme2.tdc775TFW2.data[30],DTF[5][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,5)*/
SIGNAL_MAPPING(DATA12,DTF07_1_E,vme2.qdc792TFW1.data[16],DTF[6][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,6)*/
SIGNAL_MAPPING(DATA12,DTF07_1_T,vme2.tdc775TFW2.data[16],DTF[6][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,6)*/
SIGNAL_MAPPING(DATA12,DTF07_2_E,vme2.qdc792TFW1.data[23],DTF[6][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,6)*/
SIGNAL_MAPPING(DATA12,DTF07_2_T,vme2.tdc775TFW2.data[23],DTF[6][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,6)*/
SIGNAL_MAPPING(DATA12,DTF08_1_E,vme2.qdc792TFW2.data[16],DTF[7][0].E);/*,ZERO_SUPPRESS_ITEM(DTF,7)*/
SIGNAL_MAPPING(DATA12,DTF08_1_T,vme2.tdc775TFW2.data[24],DTF[7][0].T);/*,ZERO_SUPPRESS_ITEM(DTF,7)*/
SIGNAL_MAPPING(DATA12,DTF08_2_E,vme2.qdc792TFW2.data[23],DTF[7][1].E);/*,ZERO_SUPPRESS_ITEM(DTF,7)*/
SIGNAL_MAPPING(DATA12,DTF08_2_T,vme2.tdc775TFW2.data[31],DTF[7][1].T);/*,ZERO_SUPPRESS_ITEM(DTF,7)*/
SIGNAL_MAPPING(DATA12,GFI01_01_E,vme2.qdc792GFI1.data[0],GFI[0][0].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],0)*/
SIGNAL_MAPPING(DATA12,GFI01_02_E,vme2.qdc792GFI1.data[1],GFI[0][1].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],1)*/
SIGNAL_MAPPING(DATA12,GFI01_03_E,vme2.qdc792GFI1.data[2],GFI[0][2].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],2)*/
SIGNAL_MAPPING(DATA12,GFI01_04_E,vme2.qdc792GFI1.data[3],GFI[0][3].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],3)*/
SIGNAL_MAPPING(DATA12,GFI01_05_E,vme2.qdc792GFI1.data[4],GFI[0][4].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],4)*/
SIGNAL_MAPPING(DATA12,GFI01_06_E,vme2.qdc792GFI3.data[15],GFI[0][5].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],5)*/
SIGNAL_MAPPING(DATA12,GFI01_07_E,vme2.qdc792GFI1.data[6],GFI[0][6].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],6)*/
SIGNAL_MAPPING(DATA12,GFI01_08_E,vme2.qdc792GFI1.data[7],GFI[0][7].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],7)*/
SIGNAL_MAPPING(DATA12,GFI01_09_E,vme2.qdc792GFI1.data[8],GFI[0][8].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],8)*/
SIGNAL_MAPPING(DATA12,GFI01_10_E,vme2.qdc792GFI1.data[9],GFI[0][9].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],9)*/
SIGNAL_MAPPING(DATA12,GFI01_11_E,vme2.qdc792GFI1.data[10],GFI[0][10].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],10)*/
SIGNAL_MAPPING(DATA12,GFI01_12_E,vme2.qdc792GFI1.data[11],GFI[0][11].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],11)*/
SIGNAL_MAPPING(DATA12,GFI01_13_E,vme2.qdc792GFI1.data[12],GFI[0][12].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],12)*/
SIGNAL_MAPPING(DATA12,GFI01_14_E,vme2.qdc792GFI1.data[13],GFI[0][13].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],13)*/
SIGNAL_MAPPING(DATA12,GFI01_15_E,vme2.qdc792GFI1.data[14],GFI[0][14].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],14)*/
SIGNAL_MAPPING(DATA12,GFI01_16_E,vme2.qdc792GFI1.data[15],GFI[0][15].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],15)*/
SIGNAL_MAPPING(DATA12,GFI01_17_E,vme2.qdc792GFI3.data[4],GFI[0][16].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],16)*/
SIGNAL_MAPPING(DATA12,GFI01_18_E,vme2.qdc792GFI1.data[17],GFI[0][17].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],17)*/
SIGNAL_MAPPING(DATA12,GFI01_19_E,vme2.qdc792GFI1.data[18],GFI[0][18].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],18)*/
SIGNAL_MAPPING(DATA12,GFI01_20_E,vme2.qdc792GFI1.data[19],GFI[0][19].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],19)*/
SIGNAL_MAPPING(DATA12,GFI01_21_E,vme2.qdc792GFI1.data[20],GFI[0][20].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],20)*/
SIGNAL_MAPPING(DATA12,GFI01_22_E,vme2.qdc792GFI1.data[21],GFI[0][21].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],21)*/
SIGNAL_MAPPING(DATA12,GFI01_23_E,vme2.qdc792GFI1.data[22],GFI[0][22].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],22)*/
SIGNAL_MAPPING(DATA12,GFI01_24_E,vme2.qdc792GFI1.data[23],GFI[0][23].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],23)*/
SIGNAL_MAPPING(DATA12,GFI01_25_E,vme2.qdc792GFI1.data[24],GFI[0][24].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],24)*/
SIGNAL_MAPPING(DATA12,GFI01_26_E,vme2.qdc792GFI1.data[25],GFI[0][25].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],25)*/
SIGNAL_MAPPING(DATA12,GFI01_27_E,vme2.qdc792GFI1.data[26],GFI[0][26].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],26)*/
SIGNAL_MAPPING(DATA12,GFI01_28_E,vme2.qdc792GFI1.data[27],GFI[0][27].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],27)*/
SIGNAL_MAPPING(DATA12,GFI01_29_E,vme2.qdc792GFI1.data[28],GFI[0][28].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],28)*/
SIGNAL_MAPPING(DATA12,GFI01_30_E,vme2.qdc792GFI1.data[29],GFI[0][29].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],29)*/
SIGNAL_MAPPING(DATA12,GFI01_31_E,vme2.qdc792GFI1.data[30],GFI[0][30].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],30)*/
SIGNAL_MAPPING(DATA12,GFI01_32_E,vme2.qdc792GFI1.data[31],GFI[0][31].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],31)*/
SIGNAL_MAPPING(DATA12,GFI01_33_E,vme2.qdc792GFI3.data[0],GFI[0][32].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],32)*/
SIGNAL_MAPPING(DATA12,GFI01_34_E,vme2.qdc792GFI3.data[1],GFI[0][33].E);/*,ZERO_SUPPRESS_ITEM(GFI[0],33)*/
SIGNAL_MAPPING(DATA12,GFI02_01_E,vme2.qdc792GFI2.data[5],GFI[1][0].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],0)*/
SIGNAL_MAPPING(DATA12,GFI02_02_E,vme2.qdc792GFI3.data[5],GFI[1][1].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],1)*/
SIGNAL_MAPPING(DATA12,GFI02_03_E,vme2.qdc792GFI2.data[2],GFI[1][2].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],2)*/
SIGNAL_MAPPING(DATA12,GFI02_04_E,vme2.qdc792GFI2.data[3],GFI[1][3].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],3)*/
SIGNAL_MAPPING(DATA12,GFI02_05_E,vme2.qdc792GFI2.data[4],GFI[1][4].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],4)*/
SIGNAL_MAPPING(DATA12,GFI02_06_E,vme2.qdc792GFI3.data[6],GFI[1][5].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],5)*/
SIGNAL_MAPPING(DATA12,GFI02_07_E,vme2.qdc792GFI3.data[7],GFI[1][6].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],6)*/
SIGNAL_MAPPING(DATA12,GFI02_08_E,vme2.qdc792GFI3.data[8],GFI[1][7].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],7)*/
SIGNAL_MAPPING(DATA12,GFI02_09_E,vme2.qdc792GFI3.data[9],GFI[1][8].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],8)*/
SIGNAL_MAPPING(DATA12,GFI02_10_E,vme2.qdc792GFI3.data[10],GFI[1][9].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],9)*/
SIGNAL_MAPPING(DATA12,GFI02_11_E,vme2.qdc792GFI3.data[12],GFI[1][10].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],10)*/
SIGNAL_MAPPING(DATA12,GFI02_12_E,vme2.qdc792GFI2.data[11],GFI[1][11].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],11)*/
SIGNAL_MAPPING(DATA12,GFI02_13_E,vme2.qdc792GFI2.data[12],GFI[1][12].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],12)*/
SIGNAL_MAPPING(DATA12,GFI02_14_E,vme2.qdc792GFI3.data[14],GFI[1][13].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],13)*/
SIGNAL_MAPPING(DATA12,GFI02_15_E,vme2.qdc792GFI2.data[14],GFI[1][14].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],14)*/
SIGNAL_MAPPING(DATA12,GFI02_16_E,vme2.qdc792GFI2.data[15],GFI[1][15].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],15)*/
SIGNAL_MAPPING(DATA12,GFI02_17_E,vme2.qdc792GFI2.data[16],GFI[1][16].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],16)*/
SIGNAL_MAPPING(DATA12,GFI02_18_E,vme2.qdc792GFI2.data[17],GFI[1][17].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],17)*/
SIGNAL_MAPPING(DATA12,GFI02_19_E,vme2.qdc792GFI2.data[18],GFI[1][18].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],18)*/
SIGNAL_MAPPING(DATA12,GFI02_20_E,vme2.qdc792GFI2.data[19],GFI[1][19].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],19)*/
SIGNAL_MAPPING(DATA12,GFI02_21_E,vme2.qdc792GFI2.data[20],GFI[1][20].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],20)*/
SIGNAL_MAPPING(DATA12,GFI02_22_E,vme2.qdc792GFI2.data[21],GFI[1][21].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],21)*/
SIGNAL_MAPPING(DATA12,GFI02_23_E,vme2.qdc792GFI2.data[22],GFI[1][22].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],22)*/
SIGNAL_MAPPING(DATA12,GFI02_24_E,vme2.qdc792GFI2.data[23],GFI[1][23].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],23)*/
SIGNAL_MAPPING(DATA12,GFI02_25_E,vme2.qdc792GFI2.data[24],GFI[1][24].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],24)*/
SIGNAL_MAPPING(DATA12,GFI02_26_E,vme2.qdc792GFI2.data[25],GFI[1][25].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],25)*/
SIGNAL_MAPPING(DATA12,GFI02_27_E,vme2.qdc792GFI2.data[26],GFI[1][26].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],26)*/
SIGNAL_MAPPING(DATA12,GFI02_28_E,vme2.qdc792GFI2.data[27],GFI[1][27].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],27)*/
SIGNAL_MAPPING(DATA12,GFI02_29_E,vme2.qdc792GFI2.data[28],GFI[1][28].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],28)*/
SIGNAL_MAPPING(DATA12,GFI02_30_E,vme2.qdc792GFI2.data[29],GFI[1][29].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],29)*/
SIGNAL_MAPPING(DATA12,GFI02_31_E,vme2.qdc792GFI2.data[30],GFI[1][30].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],30)*/
SIGNAL_MAPPING(DATA12,GFI02_32_E,vme2.qdc792GFI2.data[31],GFI[1][31].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],31)*/
SIGNAL_MAPPING(DATA12,GFI02_33_E,vme2.qdc792GFI3.data[2],GFI[1][32].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],32)*/
SIGNAL_MAPPING(DATA12,GFI02_34_E,vme2.qdc792GFI3.data[3],GFI[1][33].E);/*,ZERO_SUPPRESS_ITEM(GFI[1],33)*/
SIGNAL_MAPPING(DATA12,NTF01_1_E,vme2.qdc792NTF.data[0],NTF[0][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,0)*/
SIGNAL_MAPPING(DATA12,NTF01_1_T,vme2.tdc775NTF.data[0],NTF[0][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,0)*/
SIGNAL_MAPPING(DATA12,NTF01_2_E,vme2.qdc792NTF.data[1],NTF[0][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,0)*/
SIGNAL_MAPPING(DATA12,NTF01_2_T,vme2.tdc775NTF.data[1],NTF[0][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,0)*/
SIGNAL_MAPPING(DATA12,NTF02_1_E,vme2.qdc792NTF.data[2],NTF[1][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,1)*/
SIGNAL_MAPPING(DATA12,NTF02_1_T,vme2.tdc775NTF.data[2],NTF[1][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,1)*/
SIGNAL_MAPPING(DATA12,NTF02_2_E,vme2.qdc792NTF.data[3],NTF[1][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,1)*/
SIGNAL_MAPPING(DATA12,NTF02_2_T,vme2.tdc775NTF.data[3],NTF[1][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,1)*/
SIGNAL_MAPPING(DATA12,NTF03_1_E,vme2.qdc792NTF.data[4],NTF[2][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,2)*/
SIGNAL_MAPPING(DATA12,NTF03_1_T,vme2.tdc775NTF.data[4],NTF[2][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,2)*/
SIGNAL_MAPPING(DATA12,NTF03_2_E,vme2.qdc792NTF.data[5],NTF[2][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,2)*/
SIGNAL_MAPPING(DATA12,NTF03_2_T,vme2.tdc775NTF.data[5],NTF[2][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,2)*/
SIGNAL_MAPPING(DATA12,NTF04_1_E,vme2.qdc792NTF.data[6],NTF[3][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,3)*/
SIGNAL_MAPPING(DATA12,NTF04_1_T,vme2.tdc775NTF.data[6],NTF[3][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,3)*/
SIGNAL_MAPPING(DATA12,NTF04_2_E,vme2.qdc792NTF.data[7],NTF[3][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,3)*/
SIGNAL_MAPPING(DATA12,NTF04_2_T,vme2.tdc775NTF.data[7],NTF[3][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,3)*/
SIGNAL_MAPPING(DATA12,NTF05_1_E,vme2.qdc792NTF.data[8],NTF[4][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,4)*/
SIGNAL_MAPPING(DATA12,NTF05_1_T,vme2.tdc775NTF.data[8],NTF[4][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,4)*/
SIGNAL_MAPPING(DATA12,NTF05_2_E,vme2.qdc792NTF.data[9],NTF[4][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,4)*/
SIGNAL_MAPPING(DATA12,NTF05_2_T,vme2.tdc775NTF.data[9],NTF[4][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,4)*/
SIGNAL_MAPPING(DATA12,NTF06_1_E,vme2.qdc792NTF.data[10],NTF[5][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,5)*/
SIGNAL_MAPPING(DATA12,NTF06_1_T,vme2.tdc775NTF.data[10],NTF[5][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,5)*/
SIGNAL_MAPPING(DATA12,NTF06_2_E,vme2.qdc792NTF.data[11],NTF[5][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,5)*/
SIGNAL_MAPPING(DATA12,NTF06_2_T,vme2.tdc775NTF.data[11],NTF[5][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,5)*/
SIGNAL_MAPPING(DATA12,NTF07_1_E,vme2.qdc792NTF.data[12],NTF[6][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,6)*/
SIGNAL_MAPPING(DATA12,NTF07_1_T,vme2.tdc775NTF.data[12],NTF[6][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,6)*/
SIGNAL_MAPPING(DATA12,NTF07_2_E,vme2.qdc792NTF.data[13],NTF[6][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,6)*/
SIGNAL_MAPPING(DATA12,NTF07_2_T,vme2.tdc775NTF.data[13],NTF[6][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,6)*/
SIGNAL_MAPPING(DATA12,NTF08_1_E,vme2.qdc792NTF.data[14],NTF[7][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,7)*/
SIGNAL_MAPPING(DATA12,NTF08_1_T,vme2.tdc775NTF.data[14],NTF[7][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,7)*/
SIGNAL_MAPPING(DATA12,NTF08_2_E,vme2.qdc792NTF.data[15],NTF[7][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,7)*/
SIGNAL_MAPPING(DATA12,NTF08_2_T,vme2.tdc775NTF.data[15],NTF[7][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,7)*/
SIGNAL_MAPPING(DATA12,NTF09_1_E,vme2.qdc792NTF.data[16],NTF[8][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,8)*/
SIGNAL_MAPPING(DATA12,NTF09_1_T,vme2.tdc775NTF.data[16],NTF[8][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,8)*/
SIGNAL_MAPPING(DATA12,NTF09_2_E,vme2.qdc792NTF.data[17],NTF[8][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,8)*/
SIGNAL_MAPPING(DATA12,NTF09_2_T,vme2.tdc775NTF.data[17],NTF[8][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,8)*/
SIGNAL_MAPPING(DATA12,NTF10_1_E,vme2.qdc792NTF.data[18],NTF[9][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,9)*/
SIGNAL_MAPPING(DATA12,NTF10_1_T,vme2.tdc775NTF.data[18],NTF[9][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,9)*/
SIGNAL_MAPPING(DATA12,NTF10_2_E,vme2.qdc792NTF.data[19],NTF[9][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,9)*/
SIGNAL_MAPPING(DATA12,NTF10_2_T,vme2.tdc775NTF.data[19],NTF[9][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,9)*/
SIGNAL_MAPPING(DATA12,NTF11_1_E,vme2.qdc792NTF.data[20],NTF[10][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,10)*/
SIGNAL_MAPPING(DATA12,NTF11_1_T,vme2.tdc775NTF.data[20],NTF[10][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,10)*/
SIGNAL_MAPPING(DATA12,NTF11_2_E,vme2.qdc792NTF.data[21],NTF[10][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,10)*/
SIGNAL_MAPPING(DATA12,NTF11_2_T,vme2.tdc775NTF.data[21],NTF[10][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,10)*/
SIGNAL_MAPPING(DATA12,NTF12_1_E,vme2.qdc792NTF.data[22],NTF[11][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,11)*/
SIGNAL_MAPPING(DATA12,NTF12_1_T,vme2.tdc775NTF.data[22],NTF[11][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,11)*/
SIGNAL_MAPPING(DATA12,NTF12_2_E,vme2.qdc792NTF.data[23],NTF[11][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,11)*/
SIGNAL_MAPPING(DATA12,NTF12_2_T,vme2.tdc775NTF.data[23],NTF[11][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,11)*/
SIGNAL_MAPPING(DATA12,NTF13_1_E,vme2.qdc792NTF.data[24],NTF[12][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,12)*/
SIGNAL_MAPPING(DATA12,NTF13_1_T,vme2.tdc775NTF.data[24],NTF[12][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,12)*/
SIGNAL_MAPPING(DATA12,NTF13_2_E,vme2.qdc792NTF.data[25],NTF[12][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,12)*/
SIGNAL_MAPPING(DATA12,NTF13_2_T,vme2.tdc775NTF.data[25],NTF[12][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,12)*/
SIGNAL_MAPPING(DATA12,NTF14_1_E,vme2.qdc792NTF.data[26],NTF[13][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,13)*/
SIGNAL_MAPPING(DATA12,NTF14_1_T,vme2.tdc775NTF.data[26],NTF[13][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,13)*/
SIGNAL_MAPPING(DATA12,NTF14_2_E,vme2.qdc792NTF.data[27],NTF[13][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,13)*/
SIGNAL_MAPPING(DATA12,NTF14_2_T,vme2.tdc775NTF.data[27],NTF[13][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,13)*/
SIGNAL_MAPPING(DATA12,NTF15_1_E,vme2.qdc792NTF.data[28],NTF[14][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,14)*/
SIGNAL_MAPPING(DATA12,NTF15_1_T,vme2.tdc775NTF.data[28],NTF[14][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,14)*/
SIGNAL_MAPPING(DATA12,NTF15_2_E,vme2.qdc792NTF.data[29],NTF[14][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,14)*/
SIGNAL_MAPPING(DATA12,NTF15_2_T,vme2.tdc775NTF.data[29],NTF[14][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,14)*/
SIGNAL_MAPPING(DATA12,NTF16_1_E,vme2.qdc792NTF.data[30],NTF[15][0].E);/*,ZERO_SUPPRESS_ITEM(NTF,15)*/
SIGNAL_MAPPING(DATA12,NTF16_1_T,vme2.tdc775NTF.data[30],NTF[15][0].T);/*,ZERO_SUPPRESS_ITEM(NTF,15)*/
SIGNAL_MAPPING(DATA12,NTF16_2_E,vme2.qdc792NTF.data[31],NTF[15][1].E);/*,ZERO_SUPPRESS_ITEM(NTF,15)*/
SIGNAL_MAPPING(DATA12,NTF16_2_T,vme2.tdc775NTF.data[31],NTF[15][1].T);/*,ZERO_SUPPRESS_ITEM(NTF,15)*/
SIGNAL_MAPPING(DATA16,PILEUP_1_T,pileup.tdc.data,PILEUP[0].T);
SIGNAL_MAPPING(DATA12,POS01_01_E,vme1.qdc792POS_ROLU.data[0],POS[0][0].E);
SIGNAL_MAPPING(DATA12,POS01_01_T,vme1.tdc775POS_ROLU.data[0],POS[0][0].T);
SIGNAL_MAPPING(DATA12,POS01_02_E,vme1.qdc792POS_ROLU.data[1],POS[0][1].E);
SIGNAL_MAPPING(DATA12,POS01_02_T,vme1.tdc775POS_ROLU.data[1],POS[0][1].T);
SIGNAL_MAPPING(DATA12,POS01_03_E,vme1.qdc792POS_ROLU.data[2],POS[0][2].E);
SIGNAL_MAPPING(DATA12,POS01_03_T,vme1.tdc775POS_ROLU.data[2],POS[0][2].T);
SIGNAL_MAPPING(DATA12,POS01_04_E,vme1.qdc792POS_ROLU.data[3],POS[0][3].E);
SIGNAL_MAPPING(DATA12,POS01_04_T,vme1.tdc775POS_ROLU.data[3],POS[0][3].T);
SIGNAL_MAPPING(DATA14_OVERFLOW,PSP01_01_E,vme_cbl.madc0_psp.data[0],PSP[0][0].E);
SIGNAL_MAPPING(DATA14_OVERFLOW,PSP01_02_E,vme_cbl.madc0_psp.data[1],PSP[0][1].E);
SIGNAL_MAPPING(DATA14_OVERFLOW,PSP01_03_E,vme_cbl.madc0_psp.data[2],PSP[0][2].E);
SIGNAL_MAPPING(DATA14_OVERFLOW,PSP01_04_E,vme_cbl.madc0_psp.data[3],PSP[0][3].E);
SIGNAL_MAPPING(DATA14_OVERFLOW,PSP01_05_E,vme_cbl.madc0_psp.data[12],PSP[0][4].E);
SIGNAL_MAPPING(DATA12,ROL01_01_E,vme1.qdc792POS_ROLU.data[4],ROL[0][0].E);
SIGNAL_MAPPING(DATA12,ROL01_02_E,vme1.qdc792POS_ROLU.data[5],ROL[0][1].E);
SIGNAL_MAPPING(DATA12,ROL01_03_E,vme1.qdc792POS_ROLU.data[6],ROL[0][2].E);
SIGNAL_MAPPING(DATA12,ROL01_04_E,vme1.qdc792POS_ROLU.data[7],ROL[0][3].E);
SIGNAL_MAPPING(DATA12,SCI02_01_E,vme1.qdc792POS_ROLU.data[9],SCI[1][0].E);
SIGNAL_MAPPING(DATA12,SCI02_01_T,vme1.tdc775POS_ROLU.data[14],SCI[1][0].T);
SIGNAL_MAPPING(DATA12,SCI02_02_E,vme1.qdc792POS_ROLU.data[8],SCI[1][1].E);
SIGNAL_MAPPING(DATA12,SCI02_02_T,vme1.tdc775POS_ROLU.data[12],SCI[1][1].T);
SIGNAL_MAPPING(DATA16,TCALMT_1_T,pileup.tcal.data,TCALMT[0].T);
SIGNAL_MAPPING(DATA14_OVERFLOW,XB001_1_E,vme_cbr.adc[2].data[18],XB[0][0].E);/*,ZERO_SUPPRESS_ITEM(XB,0)*/
SIGNAL_MAPPING(DATA12,XB001_1_T,vme_cbr.tdc.data[50],XB[0][0].T);/*,ZERO_SUPPRESS_ITEM(XB,0)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB002_1_E,vme_cbr.adc[2].data[16],XB[1][0].E);/*,ZERO_SUPPRESS_ITEM(XB,1)*/
SIGNAL_MAPPING(DATA12,XB002_1_T,vme_cbr.tdc.data[48],XB[1][0].T);/*,ZERO_SUPPRESS_ITEM(XB,1)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB003_1_E,vme_cbr.adc[2].data[4],XB[2][0].E);/*,ZERO_SUPPRESS_ITEM(XB,2)*/
SIGNAL_MAPPING(DATA12,XB003_1_T,vme_cbr.tdc.data[36],XB[2][0].T);/*,ZERO_SUPPRESS_ITEM(XB,2)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB003_2_E,vme_cbr.adc[0].data[28],XB[2][1].E);/*,ZERO_SUPPRESS_ITEM(XB,2)*/
SIGNAL_MAPPING(DATA12,XB003_2_T,vme_cbr.tdc.data[124],XB[2][1].T);/*,ZERO_SUPPRESS_ITEM(XB,2)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB004_1_E,vme_cbr.adc[2].data[5],XB[3][0].E);/*,ZERO_SUPPRESS_ITEM(XB,3)*/
SIGNAL_MAPPING(DATA12,XB004_1_T,vme_cbr.tdc.data[37],XB[3][0].T);/*,ZERO_SUPPRESS_ITEM(XB,3)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB004_2_E,vme_cbr.adc[0].data[12],XB[3][1].E);/*,ZERO_SUPPRESS_ITEM(XB,3)*/
SIGNAL_MAPPING(DATA12,XB004_2_T,vme_cbr.tdc.data[108],XB[3][1].T);/*,ZERO_SUPPRESS_ITEM(XB,3)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB005_1_E,vme_cbr.adc[2].data[17],XB[4][0].E);/*,ZERO_SUPPRESS_ITEM(XB,4)*/
SIGNAL_MAPPING(DATA12,XB005_1_T,vme_cbr.tdc.data[49],XB[4][0].T);/*,ZERO_SUPPRESS_ITEM(XB,4)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB006_1_E,vme_cbr.adc[2].data[26],XB[5][0].E);/*,ZERO_SUPPRESS_ITEM(XB,5)*/
SIGNAL_MAPPING(DATA12,XB006_1_T,vme_cbr.tdc.data[58],XB[5][0].T);/*,ZERO_SUPPRESS_ITEM(XB,5)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB007_1_E,vme_cbr.adc[2].data[27],XB[6][0].E);/*,ZERO_SUPPRESS_ITEM(XB,6)*/
SIGNAL_MAPPING(DATA12,XB007_1_T,vme_cbr.tdc.data[59],XB[6][0].T);/*,ZERO_SUPPRESS_ITEM(XB,6)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB008_1_E,vme_cbr.adc[2].data[24],XB[7][0].E);/*,ZERO_SUPPRESS_ITEM(XB,7)*/
SIGNAL_MAPPING(DATA12,XB008_1_T,vme_cbr.tdc.data[56],XB[7][0].T);/*,ZERO_SUPPRESS_ITEM(XB,7)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB009_1_E,vme_cbr.adc[2].data[14],XB[8][0].E);/*,ZERO_SUPPRESS_ITEM(XB,8)*/
SIGNAL_MAPPING(DATA12,XB009_1_T,vme_cbr.tdc.data[46],XB[8][0].T);/*,ZERO_SUPPRESS_ITEM(XB,8)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB010_1_E,vme_cbr.adc[2].data[6],XB[9][0].E);/*,ZERO_SUPPRESS_ITEM(XB,9)*/
SIGNAL_MAPPING(DATA12,XB010_1_T,vme_cbr.tdc.data[38],XB[9][0].T);/*,ZERO_SUPPRESS_ITEM(XB,9)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB010_2_E,vme_cbr.adc[0].data[20],XB[9][1].E);/*,ZERO_SUPPRESS_ITEM(XB,9)*/
SIGNAL_MAPPING(DATA12,XB010_2_T,vme_cbr.tdc.data[116],XB[9][1].T);/*,ZERO_SUPPRESS_ITEM(XB,9)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB011_1_E,vme_cbr.adc[1].data[26],XB[10][0].E);/*,ZERO_SUPPRESS_ITEM(XB,10)*/
SIGNAL_MAPPING(DATA12,XB011_1_T,vme_cbr.tdc.data[90],XB[10][0].T);/*,ZERO_SUPPRESS_ITEM(XB,10)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB011_2_E,vme_cbr.adc[0].data[31],XB[10][1].E);/*,ZERO_SUPPRESS_ITEM(XB,10)*/
SIGNAL_MAPPING(DATA12,XB011_2_T,vme_cbr.tdc.data[127],XB[10][1].T);/*,ZERO_SUPPRESS_ITEM(XB,10)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB012_1_E,vme_cbr.adc[1].data[25],XB[11][0].E);/*,ZERO_SUPPRESS_ITEM(XB,11)*/
SIGNAL_MAPPING(DATA12,XB012_1_T,vme_cbr.tdc.data[89],XB[11][0].T);/*,ZERO_SUPPRESS_ITEM(XB,11)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB012_2_E,vme_cbr.adc[0].data[8],XB[11][1].E);/*,ZERO_SUPPRESS_ITEM(XB,11)*/
SIGNAL_MAPPING(DATA12,XB012_2_T,vme_cbr.tdc.data[104],XB[11][1].T);/*,ZERO_SUPPRESS_ITEM(XB,11)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB013_1_E,vme_cbr.adc[1].data[27],XB[12][0].E);/*,ZERO_SUPPRESS_ITEM(XB,12)*/
SIGNAL_MAPPING(DATA12,XB013_1_T,vme_cbr.tdc.data[91],XB[12][0].T);/*,ZERO_SUPPRESS_ITEM(XB,12)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB013_2_E,vme_cbr.adc[0].data[15],XB[12][1].E);/*,ZERO_SUPPRESS_ITEM(XB,12)*/
SIGNAL_MAPPING(DATA12,XB013_2_T,vme_cbr.tdc.data[111],XB[12][1].T);/*,ZERO_SUPPRESS_ITEM(XB,12)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB014_1_E,vme_cbr.adc[2].data[7],XB[13][0].E);/*,ZERO_SUPPRESS_ITEM(XB,13)*/
SIGNAL_MAPPING(DATA12,XB014_1_T,vme_cbr.tdc.data[39],XB[13][0].T);/*,ZERO_SUPPRESS_ITEM(XB,13)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB014_2_E,vme_cbr.adc[0].data[9],XB[13][1].E);/*,ZERO_SUPPRESS_ITEM(XB,13)*/
SIGNAL_MAPPING(DATA12,XB014_2_T,vme_cbr.tdc.data[105],XB[13][1].T);/*,ZERO_SUPPRESS_ITEM(XB,13)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB015_1_E,vme_cbr.adc[2].data[15],XB[14][0].E);/*,ZERO_SUPPRESS_ITEM(XB,14)*/
SIGNAL_MAPPING(DATA12,XB015_1_T,vme_cbr.tdc.data[47],XB[14][0].T);/*,ZERO_SUPPRESS_ITEM(XB,14)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB016_1_E,vme_cbr.adc[2].data[25],XB[15][0].E);/*,ZERO_SUPPRESS_ITEM(XB,15)*/
SIGNAL_MAPPING(DATA12,XB016_1_T,vme_cbr.tdc.data[57],XB[15][0].T);/*,ZERO_SUPPRESS_ITEM(XB,15)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB017_1_E,vme_cbr.adc[3].data[4],XB[16][0].E);/*,ZERO_SUPPRESS_ITEM(XB,16)*/
SIGNAL_MAPPING(DATA12,XB017_1_T,vme_cbr.tdc.data[4],XB[16][0].T);/*,ZERO_SUPPRESS_ITEM(XB,16)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB018_1_E,vme_cbr.adc[3].data[6],XB[17][0].E);/*,ZERO_SUPPRESS_ITEM(XB,17)*/
SIGNAL_MAPPING(DATA12,XB018_1_T,vme_cbr.tdc.data[6],XB[17][0].T);/*,ZERO_SUPPRESS_ITEM(XB,17)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB019_1_E,vme_cbr.adc[3].data[5],XB[18][0].E);/*,ZERO_SUPPRESS_ITEM(XB,18)*/
SIGNAL_MAPPING(DATA12,XB019_1_T,vme_cbr.tdc.data[5],XB[18][0].T);/*,ZERO_SUPPRESS_ITEM(XB,18)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB020_1_E,vme_cbr.adc[3].data[2],XB[19][0].E);/*,ZERO_SUPPRESS_ITEM(XB,19)*/
SIGNAL_MAPPING(DATA12,XB020_1_T,vme_cbr.tdc.data[2],XB[19][0].T);/*,ZERO_SUPPRESS_ITEM(XB,19)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB021_1_E,vme_cbr.adc[2].data[22],XB[20][0].E);/*,ZERO_SUPPRESS_ITEM(XB,20)*/
SIGNAL_MAPPING(DATA12,XB021_1_T,vme_cbr.tdc.data[54],XB[20][0].T);/*,ZERO_SUPPRESS_ITEM(XB,20)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB022_1_E,vme_cbr.adc[2].data[8],XB[21][0].E);/*,ZERO_SUPPRESS_ITEM(XB,21)*/
SIGNAL_MAPPING(DATA12,XB022_1_T,vme_cbr.tdc.data[40],XB[21][0].T);/*,ZERO_SUPPRESS_ITEM(XB,21)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB023_1_E,vme_cbr.adc[1].data[28],XB[22][0].E);/*,ZERO_SUPPRESS_ITEM(XB,22)*/
SIGNAL_MAPPING(DATA12,XB023_1_T,vme_cbr.tdc.data[92],XB[22][0].T);/*,ZERO_SUPPRESS_ITEM(XB,22)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB023_2_E,vme_cbr.adc[0].data[29],XB[22][1].E);/*,ZERO_SUPPRESS_ITEM(XB,22)*/
SIGNAL_MAPPING(DATA12,XB023_2_T,vme_cbr.tdc.data[125],XB[22][1].T);/*,ZERO_SUPPRESS_ITEM(XB,22)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB024_1_E,vme_cbr.adc[1].data[16],XB[23][0].E);/*,ZERO_SUPPRESS_ITEM(XB,23)*/
SIGNAL_MAPPING(DATA12,XB024_1_T,vme_cbr.tdc.data[80],XB[23][0].T);/*,ZERO_SUPPRESS_ITEM(XB,23)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB024_2_E,vme_cbr.adc[0].data[16],XB[23][1].E);/*,ZERO_SUPPRESS_ITEM(XB,23)*/
SIGNAL_MAPPING(DATA12,XB024_2_T,vme_cbr.tdc.data[112],XB[23][1].T);/*,ZERO_SUPPRESS_ITEM(XB,23)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB025_1_E,vme_cbr.adc[1].data[12],XB[24][0].E);/*,ZERO_SUPPRESS_ITEM(XB,24)*/
SIGNAL_MAPPING(DATA12,XB025_1_T,vme_cbr.tdc.data[76],XB[24][0].T);/*,ZERO_SUPPRESS_ITEM(XB,24)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB025_2_E,vme_cbr.adc[0].data[26],XB[24][1].E);/*,ZERO_SUPPRESS_ITEM(XB,24)*/
SIGNAL_MAPPING(DATA12,XB025_2_T,vme_cbr.tdc.data[122],XB[24][1].T);/*,ZERO_SUPPRESS_ITEM(XB,24)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB026_1_E,vme_cbr.adc[1].data[13],XB[25][0].E);/*,ZERO_SUPPRESS_ITEM(XB,25)*/
SIGNAL_MAPPING(DATA12,XB026_1_T,vme_cbr.tdc.data[77],XB[25][0].T);/*,ZERO_SUPPRESS_ITEM(XB,25)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB026_2_E,vme_cbr.adc[0].data[5],XB[25][1].E);/*,ZERO_SUPPRESS_ITEM(XB,25)*/
SIGNAL_MAPPING(DATA12,XB026_2_T,vme_cbr.tdc.data[101],XB[25][1].T);/*,ZERO_SUPPRESS_ITEM(XB,25)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB027_1_E,vme_cbr.adc[1].data[18],XB[26][0].E);/*,ZERO_SUPPRESS_ITEM(XB,26)*/
SIGNAL_MAPPING(DATA12,XB027_1_T,vme_cbr.tdc.data[82],XB[26][0].T);/*,ZERO_SUPPRESS_ITEM(XB,26)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB027_2_E,vme_cbr.adc[0].data[0],XB[26][1].E);/*,ZERO_SUPPRESS_ITEM(XB,26)*/
SIGNAL_MAPPING(DATA12,XB027_2_T,vme_cbr.tdc.data[96],XB[26][1].T);/*,ZERO_SUPPRESS_ITEM(XB,26)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB028_1_E,vme_cbr.adc[1].data[29],XB[27][0].E);/*,ZERO_SUPPRESS_ITEM(XB,27)*/
SIGNAL_MAPPING(DATA12,XB028_1_T,vme_cbr.tdc.data[93],XB[27][0].T);/*,ZERO_SUPPRESS_ITEM(XB,27)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB028_2_E,vme_cbr.adc[0].data[3],XB[27][1].E);/*,ZERO_SUPPRESS_ITEM(XB,27)*/
SIGNAL_MAPPING(DATA12,XB028_2_T,vme_cbr.tdc.data[99],XB[27][1].T);/*,ZERO_SUPPRESS_ITEM(XB,27)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB029_1_E,vme_cbr.adc[2].data[9],XB[28][0].E);/*,ZERO_SUPPRESS_ITEM(XB,28)*/
SIGNAL_MAPPING(DATA12,XB029_1_T,vme_cbr.tdc.data[41],XB[28][0].T);/*,ZERO_SUPPRESS_ITEM(XB,28)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB030_1_E,vme_cbr.adc[2].data[23],XB[29][0].E);/*,ZERO_SUPPRESS_ITEM(XB,29)*/
SIGNAL_MAPPING(DATA12,XB030_1_T,vme_cbr.tdc.data[55],XB[29][0].T);/*,ZERO_SUPPRESS_ITEM(XB,29)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB031_1_E,vme_cbr.adc[3].data[3],XB[30][0].E);/*,ZERO_SUPPRESS_ITEM(XB,30)*/
SIGNAL_MAPPING(DATA12,XB031_1_T,vme_cbr.tdc.data[3],XB[30][0].T);/*,ZERO_SUPPRESS_ITEM(XB,30)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB032_1_E,vme_cbr.adc[3].data[12],XB[31][0].E);/*,ZERO_SUPPRESS_ITEM(XB,31)*/
SIGNAL_MAPPING(DATA12,XB032_1_T,vme_cbr.tdc.data[12],XB[31][0].T);/*,ZERO_SUPPRESS_ITEM(XB,31)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB033_1_E,vme_cbr.adc[3].data[16],XB[32][0].E);/*,ZERO_SUPPRESS_ITEM(XB,32)*/
SIGNAL_MAPPING(DATA12,XB033_1_T,vme_cbr.tdc.data[16],XB[32][0].T);/*,ZERO_SUPPRESS_ITEM(XB,32)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB034_1_E,vme_cbr.adc[3].data[17],XB[33][0].E);/*,ZERO_SUPPRESS_ITEM(XB,33)*/
SIGNAL_MAPPING(DATA12,XB034_1_T,vme_cbr.tdc.data[17],XB[33][0].T);/*,ZERO_SUPPRESS_ITEM(XB,33)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB035_1_E,vme_cbr.adc[3].data[13],XB[34][0].E);/*,ZERO_SUPPRESS_ITEM(XB,34)*/
SIGNAL_MAPPING(DATA12,XB035_1_T,vme_cbr.tdc.data[13],XB[34][0].T);/*,ZERO_SUPPRESS_ITEM(XB,34)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB036_1_E,vme_cbr.adc[3].data[8],XB[35][0].E);/*,ZERO_SUPPRESS_ITEM(XB,35)*/
SIGNAL_MAPPING(DATA12,XB036_1_T,vme_cbr.tdc.data[8],XB[35][0].T);/*,ZERO_SUPPRESS_ITEM(XB,35)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB037_1_E,vme_cbr.adc[2].data[29],XB[36][0].E);/*,ZERO_SUPPRESS_ITEM(XB,36)*/
SIGNAL_MAPPING(DATA12,XB037_1_T,vme_cbr.tdc.data[61],XB[36][0].T);/*,ZERO_SUPPRESS_ITEM(XB,36)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB038_1_E,vme_cbr.adc[2].data[12],XB[37][0].E);/*,ZERO_SUPPRESS_ITEM(XB,37)*/
SIGNAL_MAPPING(DATA12,XB038_1_T,vme_cbr.tdc.data[44],XB[37][0].T);/*,ZERO_SUPPRESS_ITEM(XB,37)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB039_1_E,vme_cbr.adc[2].data[0],XB[38][0].E);/*,ZERO_SUPPRESS_ITEM(XB,38)*/
SIGNAL_MAPPING(DATA12,XB039_1_T,vme_cbr.tdc.data[32],XB[38][0].T);/*,ZERO_SUPPRESS_ITEM(XB,38)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB039_2_E,vme_cbr.adc[0].data[27],XB[38][1].E);/*,ZERO_SUPPRESS_ITEM(XB,38)*/
SIGNAL_MAPPING(DATA12,XB039_2_T,vme_cbr.tdc.data[123],XB[38][1].T);/*,ZERO_SUPPRESS_ITEM(XB,38)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB040_1_E,vme_cbr.adc[1].data[20],XB[39][0].E);/*,ZERO_SUPPRESS_ITEM(XB,39)*/
SIGNAL_MAPPING(DATA12,XB040_1_T,vme_cbr.tdc.data[84],XB[39][0].T);/*,ZERO_SUPPRESS_ITEM(XB,39)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB040_2_E,vme_cbr.adc[0].data[23],XB[39][1].E);/*,ZERO_SUPPRESS_ITEM(XB,39)*/
SIGNAL_MAPPING(DATA12,XB040_2_T,vme_cbr.tdc.data[119],XB[39][1].T);/*,ZERO_SUPPRESS_ITEM(XB,39)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB041_1_E,vme_cbr.adc[1].data[5],XB[40][0].E);/*,ZERO_SUPPRESS_ITEM(XB,40)*/
SIGNAL_MAPPING(DATA12,XB041_1_T,vme_cbr.tdc.data[69],XB[40][0].T);/*,ZERO_SUPPRESS_ITEM(XB,40)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB041_2_E,vme_cbr.adc[0].data[22],XB[40][1].E);/*,ZERO_SUPPRESS_ITEM(XB,40)*/
SIGNAL_MAPPING(DATA12,XB041_2_T,vme_cbr.tdc.data[118],XB[40][1].T);/*,ZERO_SUPPRESS_ITEM(XB,40)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB042_1_E,vme_cbr.adc[1].data[7],XB[41][0].E);/*,ZERO_SUPPRESS_ITEM(XB,41)*/
SIGNAL_MAPPING(DATA12,XB042_1_T,vme_cbr.tdc.data[71],XB[41][0].T);/*,ZERO_SUPPRESS_ITEM(XB,41)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB042_2_E,vme_cbr.adc[0].data[11],XB[41][1].E);/*,ZERO_SUPPRESS_ITEM(XB,41)*/
SIGNAL_MAPPING(DATA12,XB042_2_T,vme_cbr.tdc.data[107],XB[41][1].T);/*,ZERO_SUPPRESS_ITEM(XB,41)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB043_1_E,vme_cbr.adc[1].data[6],XB[42][0].E);/*,ZERO_SUPPRESS_ITEM(XB,42)*/
SIGNAL_MAPPING(DATA12,XB043_1_T,vme_cbr.tdc.data[70],XB[42][0].T);/*,ZERO_SUPPRESS_ITEM(XB,42)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB043_2_E,vme_cbr.adc[0].data[7],XB[42][1].E);/*,ZERO_SUPPRESS_ITEM(XB,42)*/
SIGNAL_MAPPING(DATA12,XB043_2_T,vme_cbr.tdc.data[103],XB[42][1].T);/*,ZERO_SUPPRESS_ITEM(XB,42)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB044_1_E,vme_cbr.adc[1].data[21],XB[43][0].E);/*,ZERO_SUPPRESS_ITEM(XB,43)*/
SIGNAL_MAPPING(DATA12,XB044_1_T,vme_cbr.tdc.data[85],XB[43][0].T);/*,ZERO_SUPPRESS_ITEM(XB,43)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB044_2_E,vme_cbr.adc[0].data[6],XB[43][1].E);/*,ZERO_SUPPRESS_ITEM(XB,43)*/
SIGNAL_MAPPING(DATA12,XB044_2_T,vme_cbr.tdc.data[102],XB[43][1].T);/*,ZERO_SUPPRESS_ITEM(XB,43)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB045_1_E,vme_cbr.adc[2].data[1],XB[44][0].E);/*,ZERO_SUPPRESS_ITEM(XB,44)*/
SIGNAL_MAPPING(DATA12,XB045_1_T,vme_cbr.tdc.data[33],XB[44][0].T);/*,ZERO_SUPPRESS_ITEM(XB,44)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB045_2_E,vme_cbr.adc[0].data[10],XB[44][1].E);/*,ZERO_SUPPRESS_ITEM(XB,44)*/
SIGNAL_MAPPING(DATA12,XB045_2_T,vme_cbr.tdc.data[106],XB[44][1].T);/*,ZERO_SUPPRESS_ITEM(XB,44)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB046_1_E,vme_cbr.adc[2].data[13],XB[45][0].E);/*,ZERO_SUPPRESS_ITEM(XB,45)*/
SIGNAL_MAPPING(DATA12,XB046_1_T,vme_cbr.tdc.data[45],XB[45][0].T);/*,ZERO_SUPPRESS_ITEM(XB,45)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB047_1_E,vme_cbr.adc[2].data[30],XB[46][0].E);/*,ZERO_SUPPRESS_ITEM(XB,46)*/
SIGNAL_MAPPING(DATA12,XB047_1_T,vme_cbr.tdc.data[62],XB[46][0].T);/*,ZERO_SUPPRESS_ITEM(XB,46)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB048_1_E,vme_cbr.adc[3].data[9],XB[47][0].E);/*,ZERO_SUPPRESS_ITEM(XB,47)*/
SIGNAL_MAPPING(DATA12,XB048_1_T,vme_cbr.tdc.data[9],XB[47][0].T);/*,ZERO_SUPPRESS_ITEM(XB,47)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB049_1_E,vme_cbr.adc[3].data[25],XB[48][0].E);/*,ZERO_SUPPRESS_ITEM(XB,48)*/
SIGNAL_MAPPING(DATA12,XB049_1_T,vme_cbr.tdc.data[25],XB[48][0].T);/*,ZERO_SUPPRESS_ITEM(XB,48)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB050_1_E,vme_cbr.adc[3].data[24],XB[49][0].E);/*,ZERO_SUPPRESS_ITEM(XB,49)*/
SIGNAL_MAPPING(DATA12,XB050_1_T,vme_cbr.tdc.data[24],XB[49][0].T);/*,ZERO_SUPPRESS_ITEM(XB,49)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB051_1_E,vme_cbr.adc[3].data[26],XB[50][0].E);/*,ZERO_SUPPRESS_ITEM(XB,50)*/
SIGNAL_MAPPING(DATA12,XB051_1_T,vme_cbr.tdc.data[26],XB[50][0].T);/*,ZERO_SUPPRESS_ITEM(XB,50)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB052_1_E,vme_cbr.adc[3].data[20],XB[51][0].E);/*,ZERO_SUPPRESS_ITEM(XB,51)*/
SIGNAL_MAPPING(DATA12,XB052_1_T,vme_cbr.tdc.data[20],XB[51][0].T);/*,ZERO_SUPPRESS_ITEM(XB,51)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB053_1_E,vme_cbr.adc[3].data[14],XB[52][0].E);/*,ZERO_SUPPRESS_ITEM(XB,52)*/
SIGNAL_MAPPING(DATA12,XB053_1_T,vme_cbr.tdc.data[14],XB[52][0].T);/*,ZERO_SUPPRESS_ITEM(XB,52)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB054_1_E,vme_cbr.adc[3].data[0],XB[53][0].E);/*,ZERO_SUPPRESS_ITEM(XB,53)*/
SIGNAL_MAPPING(DATA12,XB054_1_T,vme_cbr.tdc.data[0],XB[53][0].T);/*,ZERO_SUPPRESS_ITEM(XB,53)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB055_1_E,vme_cbr.adc[2].data[20],XB[54][0].E);/*,ZERO_SUPPRESS_ITEM(XB,54)*/
SIGNAL_MAPPING(DATA12,XB055_1_T,vme_cbr.tdc.data[52],XB[54][0].T);/*,ZERO_SUPPRESS_ITEM(XB,54)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB056_1_E,vme_cbr.adc[2].data[10],XB[55][0].E);/*,ZERO_SUPPRESS_ITEM(XB,55)*/
SIGNAL_MAPPING(DATA12,XB056_1_T,vme_cbr.tdc.data[42],XB[55][0].T);/*,ZERO_SUPPRESS_ITEM(XB,55)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB057_1_E,vme_cbr.adc[1].data[30],XB[56][0].E);/*,ZERO_SUPPRESS_ITEM(XB,56)*/
SIGNAL_MAPPING(DATA12,XB057_1_T,vme_cbr.tdc.data[94],XB[56][0].T);/*,ZERO_SUPPRESS_ITEM(XB,56)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB057_2_E,vme_cbr.adc[0].data[21],XB[56][1].E);/*,ZERO_SUPPRESS_ITEM(XB,56)*/
SIGNAL_MAPPING(DATA12,XB057_2_T,vme_cbr.tdc.data[117],XB[56][1].T);/*,ZERO_SUPPRESS_ITEM(XB,56)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB058_1_E,vme_cbr.adc[1].data[14],XB[57][0].E);/*,ZERO_SUPPRESS_ITEM(XB,57)*/
SIGNAL_MAPPING(DATA12,XB058_1_T,vme_cbr.tdc.data[78],XB[57][0].T);/*,ZERO_SUPPRESS_ITEM(XB,57)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB058_2_E,vme_cbr.adc[0].data[30],XB[57][1].E);/*,ZERO_SUPPRESS_ITEM(XB,57)*/
SIGNAL_MAPPING(DATA12,XB058_2_T,vme_cbr.tdc.data[126],XB[57][1].T);/*,ZERO_SUPPRESS_ITEM(XB,57)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB059_1_E,vme_cbr.adc[1].data[8],XB[58][0].E);/*,ZERO_SUPPRESS_ITEM(XB,58)*/
SIGNAL_MAPPING(DATA12,XB059_1_T,vme_cbr.tdc.data[72],XB[58][0].T);/*,ZERO_SUPPRESS_ITEM(XB,58)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB059_2_E,vme_cbr.adc[0].data[25],XB[58][1].E);/*,ZERO_SUPPRESS_ITEM(XB,58)*/
SIGNAL_MAPPING(DATA12,XB059_2_T,vme_cbr.tdc.data[121],XB[58][1].T);/*,ZERO_SUPPRESS_ITEM(XB,58)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB060_1_E,vme_cbr.adc[1].data[1],XB[59][0].E);/*,ZERO_SUPPRESS_ITEM(XB,59)*/
SIGNAL_MAPPING(DATA12,XB060_1_T,vme_cbr.tdc.data[65],XB[59][0].T);/*,ZERO_SUPPRESS_ITEM(XB,59)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB060_2_E,vme_cbr.adc[0].data[19],XB[59][1].E);/*,ZERO_SUPPRESS_ITEM(XB,59)*/
SIGNAL_MAPPING(DATA12,XB060_2_T,vme_cbr.tdc.data[115],XB[59][1].T);/*,ZERO_SUPPRESS_ITEM(XB,59)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB061_1_E,vme_cbr.adc[1].data[0],XB[60][0].E);/*,ZERO_SUPPRESS_ITEM(XB,60)*/
SIGNAL_MAPPING(DATA12,XB061_1_T,vme_cbr.tdc.data[64],XB[60][0].T);/*,ZERO_SUPPRESS_ITEM(XB,60)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB061_2_E,vme_cbr.adc[0].data[1],XB[60][1].E);/*,ZERO_SUPPRESS_ITEM(XB,60)*/
SIGNAL_MAPPING(DATA12,XB061_2_T,vme_cbr.tdc.data[97],XB[60][1].T);/*,ZERO_SUPPRESS_ITEM(XB,60)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB062_1_E,vme_cbr.adc[1].data[2],XB[61][0].E);/*,ZERO_SUPPRESS_ITEM(XB,61)*/
SIGNAL_MAPPING(DATA12,XB062_1_T,vme_cbr.tdc.data[66],XB[61][0].T);/*,ZERO_SUPPRESS_ITEM(XB,61)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB062_2_E,vme_cbr.adc[0].data[4],XB[61][1].E);/*,ZERO_SUPPRESS_ITEM(XB,61)*/
SIGNAL_MAPPING(DATA12,XB062_2_T,vme_cbr.tdc.data[100],XB[61][1].T);/*,ZERO_SUPPRESS_ITEM(XB,61)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB063_1_E,vme_cbr.adc[1].data[9],XB[62][0].E);/*,ZERO_SUPPRESS_ITEM(XB,62)*/
SIGNAL_MAPPING(DATA12,XB063_1_T,vme_cbr.tdc.data[73],XB[62][0].T);/*,ZERO_SUPPRESS_ITEM(XB,62)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB063_2_E,vme_cbr.adc[0].data[13],XB[62][1].E);/*,ZERO_SUPPRESS_ITEM(XB,62)*/
SIGNAL_MAPPING(DATA12,XB063_2_T,vme_cbr.tdc.data[109],XB[62][1].T);/*,ZERO_SUPPRESS_ITEM(XB,62)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB064_1_E,vme_cbr.adc[1].data[15],XB[63][0].E);/*,ZERO_SUPPRESS_ITEM(XB,63)*/
SIGNAL_MAPPING(DATA12,XB064_1_T,vme_cbr.tdc.data[79],XB[63][0].T);/*,ZERO_SUPPRESS_ITEM(XB,63)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB064_2_E,vme_cbr.adc[0].data[2],XB[63][1].E);/*,ZERO_SUPPRESS_ITEM(XB,63)*/
SIGNAL_MAPPING(DATA12,XB064_2_T,vme_cbr.tdc.data[98],XB[63][1].T);/*,ZERO_SUPPRESS_ITEM(XB,63)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB065_1_E,vme_cbr.adc[1].data[31],XB[64][0].E);/*,ZERO_SUPPRESS_ITEM(XB,64)*/
SIGNAL_MAPPING(DATA12,XB065_1_T,vme_cbr.tdc.data[95],XB[64][0].T);/*,ZERO_SUPPRESS_ITEM(XB,64)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB065_2_E,vme_cbr.adc[0].data[14],XB[64][1].E);/*,ZERO_SUPPRESS_ITEM(XB,64)*/
SIGNAL_MAPPING(DATA12,XB065_2_T,vme_cbr.tdc.data[110],XB[64][1].T);/*,ZERO_SUPPRESS_ITEM(XB,64)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB066_1_E,vme_cbr.adc[2].data[11],XB[65][0].E);/*,ZERO_SUPPRESS_ITEM(XB,65)*/
SIGNAL_MAPPING(DATA12,XB066_1_T,vme_cbr.tdc.data[43],XB[65][0].T);/*,ZERO_SUPPRESS_ITEM(XB,65)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB067_1_E,vme_cbr.adc[2].data[21],XB[66][0].E);/*,ZERO_SUPPRESS_ITEM(XB,66)*/
SIGNAL_MAPPING(DATA12,XB067_1_T,vme_cbr.tdc.data[53],XB[66][0].T);/*,ZERO_SUPPRESS_ITEM(XB,66)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB068_1_E,vme_cbr.adc[3].data[1],XB[67][0].E);/*,ZERO_SUPPRESS_ITEM(XB,67)*/
SIGNAL_MAPPING(DATA12,XB068_1_T,vme_cbr.tdc.data[1],XB[67][0].T);/*,ZERO_SUPPRESS_ITEM(XB,67)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB069_1_E,vme_cbr.adc[3].data[15],XB[68][0].E);/*,ZERO_SUPPRESS_ITEM(XB,68)*/
SIGNAL_MAPPING(DATA12,XB069_1_T,vme_cbr.tdc.data[15],XB[68][0].T);/*,ZERO_SUPPRESS_ITEM(XB,68)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB070_1_E,vme_cbr.adc[3].data[21],XB[69][0].E);/*,ZERO_SUPPRESS_ITEM(XB,69)*/
SIGNAL_MAPPING(DATA12,XB070_1_T,vme_cbr.tdc.data[21],XB[69][0].T);/*,ZERO_SUPPRESS_ITEM(XB,69)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB071_1_E,vme_cbr.adc[3].data[28],XB[70][0].E);/*,ZERO_SUPPRESS_ITEM(XB,70)*/
SIGNAL_MAPPING(DATA12,XB071_1_T,vme_cbr.tdc.data[28],XB[70][0].T);/*,ZERO_SUPPRESS_ITEM(XB,70)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB072_1_E,vme_cbr.adc[3].data[30],XB[71][0].E);/*,ZERO_SUPPRESS_ITEM(XB,71)*/
SIGNAL_MAPPING(DATA12,XB072_1_T,vme_cbr.tdc.data[30],XB[71][0].T);/*,ZERO_SUPPRESS_ITEM(XB,71)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB073_1_E,vme_cbr.adc[3].data[29],XB[72][0].E);/*,ZERO_SUPPRESS_ITEM(XB,72)*/
SIGNAL_MAPPING(DATA12,XB073_1_T,vme_cbr.tdc.data[29],XB[72][0].T);/*,ZERO_SUPPRESS_ITEM(XB,72)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB074_1_E,vme_cbr.adc[3].data[27],XB[73][0].E);/*,ZERO_SUPPRESS_ITEM(XB,73)*/
SIGNAL_MAPPING(DATA12,XB074_1_T,vme_cbr.tdc.data[27],XB[73][0].T);/*,ZERO_SUPPRESS_ITEM(XB,73)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB075_1_E,vme_cbr.adc[3].data[7],XB[74][0].E);/*,ZERO_SUPPRESS_ITEM(XB,74)*/
SIGNAL_MAPPING(DATA12,XB075_1_T,vme_cbr.tdc.data[7],XB[74][0].T);/*,ZERO_SUPPRESS_ITEM(XB,74)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB076_1_E,vme_cbr.adc[2].data[28],XB[75][0].E);/*,ZERO_SUPPRESS_ITEM(XB,75)*/
SIGNAL_MAPPING(DATA12,XB076_1_T,vme_cbr.tdc.data[60],XB[75][0].T);/*,ZERO_SUPPRESS_ITEM(XB,75)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB078_1_E,vme_cbr.adc[2].data[2],XB[77][0].E);/*,ZERO_SUPPRESS_ITEM(XB,77)*/
SIGNAL_MAPPING(DATA12,XB078_1_T,vme_cbr.tdc.data[34],XB[77][0].T);/*,ZERO_SUPPRESS_ITEM(XB,77)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB078_2_E,vme_cbr.adc[0].data[18],XB[77][1].E);/*,ZERO_SUPPRESS_ITEM(XB,77)*/
SIGNAL_MAPPING(DATA12,XB078_2_T,vme_cbr.tdc.data[114],XB[77][1].T);/*,ZERO_SUPPRESS_ITEM(XB,77)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB079_1_E,vme_cbr.adc[1].data[24],XB[78][0].E);/*,ZERO_SUPPRESS_ITEM(XB,78)*/
SIGNAL_MAPPING(DATA12,XB079_1_T,vme_cbr.tdc.data[88],XB[78][0].T);/*,ZERO_SUPPRESS_ITEM(XB,78)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB079_2_E,vme_cbr.adc[0].data[24],XB[78][1].E);/*,ZERO_SUPPRESS_ITEM(XB,78)*/
SIGNAL_MAPPING(DATA12,XB079_2_T,vme_cbr.tdc.data[120],XB[78][1].T);/*,ZERO_SUPPRESS_ITEM(XB,78)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB080_2_E,vme_cbr.adc[0].data[17],XB[79][1].E);/*,ZERO_SUPPRESS_ITEM(XB,79)*/
SIGNAL_MAPPING(DATA12,XB080_2_T,vme_cbr.tdc.data[113],XB[79][1].T);/*,ZERO_SUPPRESS_ITEM(XB,79)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB083_1_E,vme_cbl.adc[0].data[26],XB[82][0].E);/*,ZERO_SUPPRESS_ITEM(XB,82)*/
SIGNAL_MAPPING(DATA12,XB083_1_T,vme_cbl.tdc.data[106],XB[82][0].T);/*,ZERO_SUPPRESS_ITEM(XB,82)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB084_1_E,vme_cbl.adc[0].data[7],XB[83][0].E);/*,ZERO_SUPPRESS_ITEM(XB,83)*/
SIGNAL_MAPPING(DATA12,XB084_1_T,vme_cbl.tdc.data[119],XB[83][0].T);/*,ZERO_SUPPRESS_ITEM(XB,83)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB085_1_E,vme_cbl.adc[1].data[28],XB[84][0].E);/*,ZERO_SUPPRESS_ITEM(XB,84)*/
SIGNAL_MAPPING(DATA12,XB085_1_T,vme_cbl.tdc.data[76],XB[84][0].T);/*,ZERO_SUPPRESS_ITEM(XB,84)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB086_1_E,vme_cbl.adc[1].data[18],XB[85][0].E);/*,ZERO_SUPPRESS_ITEM(XB,85)*/
SIGNAL_MAPPING(DATA12,XB086_1_T,vme_cbl.tdc.data[66],XB[85][0].T);/*,ZERO_SUPPRESS_ITEM(XB,85)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB087_1_E,vme_cbl.adc[1].data[2],XB[86][0].E);/*,ZERO_SUPPRESS_ITEM(XB,86)*/
SIGNAL_MAPPING(DATA12,XB087_1_T,vme_cbl.tdc.data[82],XB[86][0].T);/*,ZERO_SUPPRESS_ITEM(XB,86)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB087_2_E,vme_cbl.adc[3].data[22],XB[86][1].E);/*,ZERO_SUPPRESS_ITEM(XB,86)*/
SIGNAL_MAPPING(DATA12,XB087_2_T,vme_cbl.tdc.data[6],XB[86][1].T);/*,ZERO_SUPPRESS_ITEM(XB,86)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB088_1_E,vme_cbl.adc[2].data[24],XB[87][0].E);/*,ZERO_SUPPRESS_ITEM(XB,87)*/
SIGNAL_MAPPING(DATA12,XB088_1_T,vme_cbl.tdc.data[40],XB[87][0].T);/*,ZERO_SUPPRESS_ITEM(XB,87)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB088_2_E,vme_cbl.adc[3].data[29],XB[87][1].E);/*,ZERO_SUPPRESS_ITEM(XB,87)*/
SIGNAL_MAPPING(DATA12,XB088_2_T,vme_cbl.tdc.data[13],XB[87][1].T);/*,ZERO_SUPPRESS_ITEM(XB,87)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB089_1_E,vme_cbl.adc[2].data[4],XB[88][0].E);/*,ZERO_SUPPRESS_ITEM(XB,88)*/
SIGNAL_MAPPING(DATA12,XB089_1_T,vme_cbl.tdc.data[52],XB[88][0].T);/*,ZERO_SUPPRESS_ITEM(XB,88)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB089_2_E,vme_cbl.adc[3].data[23],XB[88][1].E);/*,ZERO_SUPPRESS_ITEM(XB,88)*/
SIGNAL_MAPPING(DATA12,XB089_2_T,vme_cbl.tdc.data[7],XB[88][1].T);/*,ZERO_SUPPRESS_ITEM(XB,88)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB090_1_E,vme_cbl.adc[2].data[1],XB[89][0].E);/*,ZERO_SUPPRESS_ITEM(XB,89)*/
SIGNAL_MAPPING(DATA12,XB090_1_T,vme_cbl.tdc.data[49],XB[89][0].T);/*,ZERO_SUPPRESS_ITEM(XB,89)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB090_2_E,vme_cbl.adc[3].data[18],XB[89][1].E);/*,ZERO_SUPPRESS_ITEM(XB,89)*/
SIGNAL_MAPPING(DATA12,XB090_2_T,vme_cbl.tdc.data[2],XB[89][1].T);/*,ZERO_SUPPRESS_ITEM(XB,89)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB091_1_E,vme_cbl.adc[2].data[0],XB[90][0].E);/*,ZERO_SUPPRESS_ITEM(XB,90)*/
SIGNAL_MAPPING(DATA12,XB091_1_T,vme_cbl.tdc.data[48],XB[90][0].T);/*,ZERO_SUPPRESS_ITEM(XB,90)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB091_2_E,vme_cbl.adc[3].data[11],XB[90][1].E);/*,ZERO_SUPPRESS_ITEM(XB,90)*/
SIGNAL_MAPPING(DATA12,XB091_2_T,vme_cbl.tdc.data[27],XB[90][1].T);/*,ZERO_SUPPRESS_ITEM(XB,90)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB092_1_E,vme_cbl.adc[2].data[2],XB[91][0].E);/*,ZERO_SUPPRESS_ITEM(XB,91)*/
SIGNAL_MAPPING(DATA12,XB092_1_T,vme_cbl.tdc.data[50],XB[91][0].T);/*,ZERO_SUPPRESS_ITEM(XB,91)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB092_2_E,vme_cbl.adc[3].data[4],XB[91][1].E);/*,ZERO_SUPPRESS_ITEM(XB,91)*/
SIGNAL_MAPPING(DATA12,XB092_2_T,vme_cbl.tdc.data[20],XB[91][1].T);/*,ZERO_SUPPRESS_ITEM(XB,91)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB093_1_E,vme_cbl.adc[2].data[8],XB[92][0].E);/*,ZERO_SUPPRESS_ITEM(XB,92)*/
SIGNAL_MAPPING(DATA12,XB093_1_T,vme_cbl.tdc.data[56],XB[92][0].T);/*,ZERO_SUPPRESS_ITEM(XB,92)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB093_2_E,vme_cbl.adc[3].data[9],XB[92][1].E);/*,ZERO_SUPPRESS_ITEM(XB,92)*/
SIGNAL_MAPPING(DATA12,XB093_2_T,vme_cbl.tdc.data[25],XB[92][1].T);/*,ZERO_SUPPRESS_ITEM(XB,92)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB094_1_E,vme_cbl.adc[2].data[14],XB[93][0].E);/*,ZERO_SUPPRESS_ITEM(XB,93)*/
SIGNAL_MAPPING(DATA12,XB094_1_T,vme_cbl.tdc.data[62],XB[93][0].T);/*,ZERO_SUPPRESS_ITEM(XB,93)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB094_2_E,vme_cbl.adc[3].data[14],XB[93][1].E);/*,ZERO_SUPPRESS_ITEM(XB,93)*/
SIGNAL_MAPPING(DATA12,XB094_2_T,vme_cbl.tdc.data[30],XB[93][1].T);/*,ZERO_SUPPRESS_ITEM(XB,93)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB095_1_E,vme_cbl.adc[2].data[30],XB[94][0].E);/*,ZERO_SUPPRESS_ITEM(XB,94)*/
SIGNAL_MAPPING(DATA12,XB095_1_T,vme_cbl.tdc.data[46],XB[94][0].T);/*,ZERO_SUPPRESS_ITEM(XB,94)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB095_2_E,vme_cbl.adc[3].data[1],XB[94][1].E);/*,ZERO_SUPPRESS_ITEM(XB,94)*/
SIGNAL_MAPPING(DATA12,XB095_2_T,vme_cbl.tdc.data[17],XB[94][1].T);/*,ZERO_SUPPRESS_ITEM(XB,94)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB096_1_E,vme_cbl.adc[1].data[10],XB[95][0].E);/*,ZERO_SUPPRESS_ITEM(XB,95)*/
SIGNAL_MAPPING(DATA12,XB096_1_T,vme_cbl.tdc.data[90],XB[95][0].T);/*,ZERO_SUPPRESS_ITEM(XB,95)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB097_1_E,vme_cbl.adc[1].data[20],XB[96][0].E);/*,ZERO_SUPPRESS_ITEM(XB,96)*/
SIGNAL_MAPPING(DATA12,XB097_1_T,vme_cbl.tdc.data[68],XB[96][0].T);/*,ZERO_SUPPRESS_ITEM(XB,96)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB098_1_E,vme_cbl.adc[0].data[0],XB[97][0].E);/*,ZERO_SUPPRESS_ITEM(XB,97)*/
SIGNAL_MAPPING(DATA12,XB098_1_T,vme_cbl.tdc.data[112],XB[97][0].T);/*,ZERO_SUPPRESS_ITEM(XB,97)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB099_1_E,vme_cbl.adc[0].data[14],XB[98][0].E);/*,ZERO_SUPPRESS_ITEM(XB,98)*/
SIGNAL_MAPPING(DATA12,XB099_1_T,vme_cbl.tdc.data[126],XB[98][0].T);/*,ZERO_SUPPRESS_ITEM(XB,98)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB100_1_E,vme_cbl.adc[0].data[20],XB[99][0].E);/*,ZERO_SUPPRESS_ITEM(XB,99)*/
SIGNAL_MAPPING(DATA12,XB100_1_T,vme_cbl.tdc.data[100],XB[99][0].T);/*,ZERO_SUPPRESS_ITEM(XB,99)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB101_1_E,vme_cbl.adc[0].data[28],XB[100][0].E);/*,ZERO_SUPPRESS_ITEM(XB,100)*/
SIGNAL_MAPPING(DATA12,XB101_1_T,vme_cbl.tdc.data[108],XB[100][0].T);/*,ZERO_SUPPRESS_ITEM(XB,100)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB102_1_E,vme_cbl.adc[0].data[30],XB[101][0].E);/*,ZERO_SUPPRESS_ITEM(XB,101)*/
SIGNAL_MAPPING(DATA12,XB102_1_T,vme_cbl.tdc.data[110],XB[101][0].T);/*,ZERO_SUPPRESS_ITEM(XB,101)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB103_1_E,vme_cbl.adc[0].data[29],XB[102][0].E);/*,ZERO_SUPPRESS_ITEM(XB,102)*/
SIGNAL_MAPPING(DATA12,XB103_1_T,vme_cbl.tdc.data[109],XB[102][0].T);/*,ZERO_SUPPRESS_ITEM(XB,102)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB104_1_E,vme_cbl.adc[0].data[21],XB[103][0].E);/*,ZERO_SUPPRESS_ITEM(XB,103)*/
SIGNAL_MAPPING(DATA12,XB104_1_T,vme_cbl.tdc.data[101],XB[103][0].T);/*,ZERO_SUPPRESS_ITEM(XB,103)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB105_1_E,vme_cbl.adc[0].data[15],XB[104][0].E);/*,ZERO_SUPPRESS_ITEM(XB,104)*/
SIGNAL_MAPPING(DATA12,XB105_1_T,vme_cbl.tdc.data[127],XB[104][0].T);/*,ZERO_SUPPRESS_ITEM(XB,104)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB106_1_E,vme_cbl.adc[0].data[1],XB[105][0].E);/*,ZERO_SUPPRESS_ITEM(XB,105)*/
SIGNAL_MAPPING(DATA12,XB106_1_T,vme_cbl.tdc.data[113],XB[105][0].T);/*,ZERO_SUPPRESS_ITEM(XB,105)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB107_1_E,vme_cbl.adc[1].data[21],XB[106][0].E);/*,ZERO_SUPPRESS_ITEM(XB,106)*/
SIGNAL_MAPPING(DATA12,XB107_1_T,vme_cbl.tdc.data[69],XB[106][0].T);/*,ZERO_SUPPRESS_ITEM(XB,106)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB108_1_E,vme_cbl.adc[1].data[11],XB[107][0].E);/*,ZERO_SUPPRESS_ITEM(XB,107)*/
SIGNAL_MAPPING(DATA12,XB108_1_T,vme_cbl.tdc.data[91],XB[107][0].T);/*,ZERO_SUPPRESS_ITEM(XB,107)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB109_1_E,vme_cbl.adc[2].data[31],XB[108][0].E);/*,ZERO_SUPPRESS_ITEM(XB,108)*/
SIGNAL_MAPPING(DATA12,XB109_1_T,vme_cbl.tdc.data[47],XB[108][0].T);/*,ZERO_SUPPRESS_ITEM(XB,108)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB109_2_E,vme_cbl.adc[3].data[25],XB[108][1].E);/*,ZERO_SUPPRESS_ITEM(XB,108)*/
SIGNAL_MAPPING(DATA12,XB109_2_T,vme_cbl.tdc.data[9],XB[108][1].T);/*,ZERO_SUPPRESS_ITEM(XB,108)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB110_1_E,vme_cbl.adc[2].data[15],XB[109][0].E);/*,ZERO_SUPPRESS_ITEM(XB,109)*/
SIGNAL_MAPPING(DATA12,XB110_1_T,vme_cbl.tdc.data[63],XB[109][0].T);/*,ZERO_SUPPRESS_ITEM(XB,109)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB110_2_E,vme_cbl.adc[3].data[19],XB[109][1].E);/*,ZERO_SUPPRESS_ITEM(XB,109)*/
SIGNAL_MAPPING(DATA12,XB110_2_T,vme_cbl.tdc.data[3],XB[109][1].T);/*,ZERO_SUPPRESS_ITEM(XB,109)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB111_1_E,vme_cbl.adc[2].data[9],XB[110][0].E);/*,ZERO_SUPPRESS_ITEM(XB,110)*/
SIGNAL_MAPPING(DATA12,XB111_1_T,vme_cbl.tdc.data[57],XB[110][0].T);/*,ZERO_SUPPRESS_ITEM(XB,110)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB111_2_E,vme_cbl.adc[3].data[28],XB[110][1].E);/*,ZERO_SUPPRESS_ITEM(XB,110)*/
SIGNAL_MAPPING(DATA12,XB111_2_T,vme_cbl.tdc.data[12],XB[110][1].T);/*,ZERO_SUPPRESS_ITEM(XB,110)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB112_1_E,vme_cbl.adc[2].data[5],XB[111][0].E);/*,ZERO_SUPPRESS_ITEM(XB,111)*/
SIGNAL_MAPPING(DATA12,XB112_1_T,vme_cbl.tdc.data[53],XB[111][0].T);/*,ZERO_SUPPRESS_ITEM(XB,111)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB112_2_E,vme_cbl.adc[3].data[20],XB[111][1].E);/*,ZERO_SUPPRESS_ITEM(XB,111)*/
SIGNAL_MAPPING(DATA12,XB112_2_T,vme_cbl.tdc.data[4],XB[111][1].T);/*,ZERO_SUPPRESS_ITEM(XB,111)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB113_1_E,vme_cbl.adc[2].data[7],XB[112][0].E);/*,ZERO_SUPPRESS_ITEM(XB,112)*/
SIGNAL_MAPPING(DATA12,XB113_1_T,vme_cbl.tdc.data[55],XB[112][0].T);/*,ZERO_SUPPRESS_ITEM(XB,112)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB113_2_E,vme_cbl.adc[3].data[3],XB[112][1].E);/*,ZERO_SUPPRESS_ITEM(XB,112)*/
SIGNAL_MAPPING(DATA12,XB113_2_T,vme_cbl.tdc.data[19],XB[112][1].T);/*,ZERO_SUPPRESS_ITEM(XB,112)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB114_1_E,vme_cbl.adc[2].data[6],XB[113][0].E);/*,ZERO_SUPPRESS_ITEM(XB,113)*/
SIGNAL_MAPPING(DATA12,XB114_1_T,vme_cbl.tdc.data[54],XB[113][0].T);/*,ZERO_SUPPRESS_ITEM(XB,113)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB114_2_E,vme_cbl.adc[3].data[13],XB[113][1].E);/*,ZERO_SUPPRESS_ITEM(XB,113)*/
SIGNAL_MAPPING(DATA12,XB114_2_T,vme_cbl.tdc.data[29],XB[113][1].T);/*,ZERO_SUPPRESS_ITEM(XB,113)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB115_1_E,vme_cbl.adc[2].data[20],XB[114][0].E);/*,ZERO_SUPPRESS_ITEM(XB,114)*/
SIGNAL_MAPPING(DATA12,XB115_1_T,vme_cbl.tdc.data[36],XB[114][0].T);/*,ZERO_SUPPRESS_ITEM(XB,114)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB115_2_E,vme_cbl.adc[3].data[12],XB[114][1].E);/*,ZERO_SUPPRESS_ITEM(XB,114)*/
SIGNAL_MAPPING(DATA12,XB115_2_T,vme_cbl.tdc.data[28],XB[114][1].T);/*,ZERO_SUPPRESS_ITEM(XB,114)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB116_1_E,vme_cbl.adc[1].data[0],XB[115][0].E);/*,ZERO_SUPPRESS_ITEM(XB,115)*/
SIGNAL_MAPPING(DATA12,XB116_1_T,vme_cbl.tdc.data[80],XB[115][0].T);/*,ZERO_SUPPRESS_ITEM(XB,115)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB116_2_E,vme_cbl.adc[3].data[7],XB[115][1].E);/*,ZERO_SUPPRESS_ITEM(XB,115)*/
SIGNAL_MAPPING(DATA12,XB116_2_T,vme_cbl.tdc.data[23],XB[115][1].T);/*,ZERO_SUPPRESS_ITEM(XB,115)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB117_1_E,vme_cbl.adc[1].data[12],XB[116][0].E);/*,ZERO_SUPPRESS_ITEM(XB,116)*/
SIGNAL_MAPPING(DATA12,XB117_1_T,vme_cbl.tdc.data[92],XB[116][0].T);/*,ZERO_SUPPRESS_ITEM(XB,116)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB118_1_E,vme_cbl.adc[1].data[29],XB[117][0].E);/*,ZERO_SUPPRESS_ITEM(XB,117)*/
SIGNAL_MAPPING(DATA12,XB118_1_T,vme_cbl.tdc.data[77],XB[117][0].T);/*,ZERO_SUPPRESS_ITEM(XB,117)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB119_1_E,vme_cbl.adc[0].data[8],XB[118][0].E);/*,ZERO_SUPPRESS_ITEM(XB,118)*/
SIGNAL_MAPPING(DATA12,XB119_1_T,vme_cbl.tdc.data[120],XB[118][0].T);/*,ZERO_SUPPRESS_ITEM(XB,118)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB120_1_E,vme_cbl.adc[0].data[25],XB[119][0].E);/*,ZERO_SUPPRESS_ITEM(XB,119)*/
SIGNAL_MAPPING(DATA12,XB120_1_T,vme_cbl.tdc.data[105],XB[119][0].T);/*,ZERO_SUPPRESS_ITEM(XB,119)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB121_1_E,vme_cbl.adc[0].data[24],XB[120][0].E);/*,ZERO_SUPPRESS_ITEM(XB,120)*/
SIGNAL_MAPPING(DATA12,XB121_1_T,vme_cbl.tdc.data[104],XB[120][0].T);/*,ZERO_SUPPRESS_ITEM(XB,120)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB122_1_E,vme_cbl.adc[0].data[27],XB[121][0].E);/*,ZERO_SUPPRESS_ITEM(XB,121)*/
SIGNAL_MAPPING(DATA12,XB122_1_T,vme_cbl.tdc.data[107],XB[121][0].T);/*,ZERO_SUPPRESS_ITEM(XB,121)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB123_1_E,vme_cbl.adc[0].data[9],XB[122][0].E);/*,ZERO_SUPPRESS_ITEM(XB,122)*/
SIGNAL_MAPPING(DATA12,XB123_1_T,vme_cbl.tdc.data[121],XB[122][0].T);/*,ZERO_SUPPRESS_ITEM(XB,122)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB124_1_E,vme_cbl.adc[1].data[30],XB[123][0].E);/*,ZERO_SUPPRESS_ITEM(XB,123)*/
SIGNAL_MAPPING(DATA12,XB124_1_T,vme_cbl.tdc.data[78],XB[123][0].T);/*,ZERO_SUPPRESS_ITEM(XB,123)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB125_1_E,vme_cbl.adc[1].data[13],XB[124][0].E);/*,ZERO_SUPPRESS_ITEM(XB,124)*/
SIGNAL_MAPPING(DATA12,XB125_1_T,vme_cbl.tdc.data[93],XB[124][0].T);/*,ZERO_SUPPRESS_ITEM(XB,124)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB126_1_E,vme_cbl.adc[1].data[1],XB[125][0].E);/*,ZERO_SUPPRESS_ITEM(XB,125)*/
SIGNAL_MAPPING(DATA12,XB126_1_T,vme_cbl.tdc.data[81],XB[125][0].T);/*,ZERO_SUPPRESS_ITEM(XB,125)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB126_2_E,vme_cbl.adc[3].data[21],XB[125][1].E);/*,ZERO_SUPPRESS_ITEM(XB,125)*/
SIGNAL_MAPPING(DATA12,XB126_2_T,vme_cbl.tdc.data[5],XB[125][1].T);/*,ZERO_SUPPRESS_ITEM(XB,125)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB127_1_E,vme_cbl.adc[2].data[21],XB[126][0].E);/*,ZERO_SUPPRESS_ITEM(XB,126)*/
SIGNAL_MAPPING(DATA12,XB127_1_T,vme_cbl.tdc.data[37],XB[126][0].T);/*,ZERO_SUPPRESS_ITEM(XB,126)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB127_2_E,vme_cbl.adc[3].data[16],XB[126][1].E);/*,ZERO_SUPPRESS_ITEM(XB,126)*/
SIGNAL_MAPPING(DATA12,XB127_2_T,vme_cbl.tdc.data[0],XB[126][1].T);/*,ZERO_SUPPRESS_ITEM(XB,126)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB128_1_E,vme_cbl.adc[2].data[16],XB[127][0].E);/*,ZERO_SUPPRESS_ITEM(XB,127)*/
SIGNAL_MAPPING(DATA12,XB128_1_T,vme_cbl.tdc.data[32],XB[127][0].T);/*,ZERO_SUPPRESS_ITEM(XB,127)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB128_2_E,vme_cbl.adc[3].data[26],XB[127][1].E);/*,ZERO_SUPPRESS_ITEM(XB,127)*/
SIGNAL_MAPPING(DATA12,XB128_2_T,vme_cbl.tdc.data[10],XB[127][1].T);/*,ZERO_SUPPRESS_ITEM(XB,127)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB129_1_E,vme_cbl.adc[2].data[12],XB[128][0].E);/*,ZERO_SUPPRESS_ITEM(XB,128)*/
SIGNAL_MAPPING(DATA12,XB129_1_T,vme_cbl.tdc.data[60],XB[128][0].T);/*,ZERO_SUPPRESS_ITEM(XB,128)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB129_2_E,vme_cbl.adc[3].data[17],XB[128][1].E);/*,ZERO_SUPPRESS_ITEM(XB,128)*/
SIGNAL_MAPPING(DATA12,XB129_2_T,vme_cbl.tdc.data[1],XB[128][1].T);/*,ZERO_SUPPRESS_ITEM(XB,128)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB130_1_E,vme_cbl.adc[2].data[13],XB[129][0].E);/*,ZERO_SUPPRESS_ITEM(XB,129)*/
SIGNAL_MAPPING(DATA12,XB130_1_T,vme_cbl.tdc.data[61],XB[129][0].T);/*,ZERO_SUPPRESS_ITEM(XB,129)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB130_2_E,vme_cbl.adc[3].data[6],XB[129][1].E);/*,ZERO_SUPPRESS_ITEM(XB,129)*/
SIGNAL_MAPPING(DATA12,XB130_2_T,vme_cbl.tdc.data[22],XB[129][1].T);/*,ZERO_SUPPRESS_ITEM(XB,129)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB131_1_E,vme_cbl.adc[2].data[17],XB[130][0].E);/*,ZERO_SUPPRESS_ITEM(XB,130)*/
SIGNAL_MAPPING(DATA12,XB131_1_T,vme_cbl.tdc.data[33],XB[130][0].T);/*,ZERO_SUPPRESS_ITEM(XB,130)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB131_2_E,vme_cbl.adc[3].data[0],XB[130][1].E);/*,ZERO_SUPPRESS_ITEM(XB,130)*/
SIGNAL_MAPPING(DATA12,XB131_2_T,vme_cbl.tdc.data[16],XB[130][1].T);/*,ZERO_SUPPRESS_ITEM(XB,130)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB132_1_E,vme_cbl.adc[2].data[28],XB[131][0].E);/*,ZERO_SUPPRESS_ITEM(XB,131)*/
SIGNAL_MAPPING(DATA12,XB132_1_T,vme_cbl.tdc.data[44],XB[131][0].T);/*,ZERO_SUPPRESS_ITEM(XB,131)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB132_2_E,vme_cbl.adc[3].data[15],XB[131][1].E);/*,ZERO_SUPPRESS_ITEM(XB,131)*/
SIGNAL_MAPPING(DATA12,XB132_2_T,vme_cbl.tdc.data[31],XB[131][1].T);/*,ZERO_SUPPRESS_ITEM(XB,131)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB133_1_E,vme_cbl.adc[1].data[8],XB[132][0].E);/*,ZERO_SUPPRESS_ITEM(XB,132)*/
SIGNAL_MAPPING(DATA12,XB133_1_T,vme_cbl.tdc.data[88],XB[132][0].T);/*,ZERO_SUPPRESS_ITEM(XB,132)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB134_1_E,vme_cbl.adc[1].data[22],XB[133][0].E);/*,ZERO_SUPPRESS_ITEM(XB,133)*/
SIGNAL_MAPPING(DATA12,XB134_1_T,vme_cbl.tdc.data[70],XB[133][0].T);/*,ZERO_SUPPRESS_ITEM(XB,133)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB135_1_E,vme_cbl.adc[0].data[2],XB[134][0].E);/*,ZERO_SUPPRESS_ITEM(XB,134)*/
SIGNAL_MAPPING(DATA12,XB135_1_T,vme_cbl.tdc.data[114],XB[134][0].T);/*,ZERO_SUPPRESS_ITEM(XB,134)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB136_1_E,vme_cbl.adc[0].data[12],XB[135][0].E);/*,ZERO_SUPPRESS_ITEM(XB,135)*/
SIGNAL_MAPPING(DATA12,XB136_1_T,vme_cbl.tdc.data[124],XB[135][0].T);/*,ZERO_SUPPRESS_ITEM(XB,135)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB137_1_E,vme_cbl.adc[0].data[16],XB[136][0].E);/*,ZERO_SUPPRESS_ITEM(XB,136)*/
SIGNAL_MAPPING(DATA12,XB137_1_T,vme_cbl.tdc.data[96],XB[136][0].T);/*,ZERO_SUPPRESS_ITEM(XB,136)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB138_1_E,vme_cbl.adc[0].data[17],XB[137][0].E);/*,ZERO_SUPPRESS_ITEM(XB,137)*/
SIGNAL_MAPPING(DATA12,XB138_1_T,vme_cbl.tdc.data[97],XB[137][0].T);/*,ZERO_SUPPRESS_ITEM(XB,137)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB139_1_E,vme_cbl.adc[0].data[13],XB[138][0].E);/*,ZERO_SUPPRESS_ITEM(XB,138)*/
SIGNAL_MAPPING(DATA12,XB139_1_T,vme_cbl.tdc.data[125],XB[138][0].T);/*,ZERO_SUPPRESS_ITEM(XB,138)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB140_1_E,vme_cbl.adc[0].data[3],XB[139][0].E);/*,ZERO_SUPPRESS_ITEM(XB,139)*/
SIGNAL_MAPPING(DATA12,XB140_1_T,vme_cbl.tdc.data[115],XB[139][0].T);/*,ZERO_SUPPRESS_ITEM(XB,139)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB141_1_E,vme_cbl.adc[1].data[23],XB[140][0].E);/*,ZERO_SUPPRESS_ITEM(XB,140)*/
SIGNAL_MAPPING(DATA12,XB141_1_T,vme_cbl.tdc.data[71],XB[140][0].T);/*,ZERO_SUPPRESS_ITEM(XB,140)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB142_1_E,vme_cbl.adc[1].data[9],XB[141][0].E);/*,ZERO_SUPPRESS_ITEM(XB,141)*/
SIGNAL_MAPPING(DATA12,XB142_1_T,vme_cbl.tdc.data[89],XB[141][0].T);/*,ZERO_SUPPRESS_ITEM(XB,141)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB143_1_E,vme_cbl.adc[2].data[29],XB[142][0].E);/*,ZERO_SUPPRESS_ITEM(XB,142)*/
SIGNAL_MAPPING(DATA12,XB143_1_T,vme_cbl.tdc.data[45],XB[142][0].T);/*,ZERO_SUPPRESS_ITEM(XB,142)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB143_2_E,vme_cbl.adc[3].data[31],XB[142][1].E);/*,ZERO_SUPPRESS_ITEM(XB,142)*/
SIGNAL_MAPPING(DATA12,XB143_2_T,vme_cbl.tdc.data[15],XB[142][1].T);/*,ZERO_SUPPRESS_ITEM(XB,142)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB144_1_E,vme_cbl.adc[2].data[26],XB[143][0].E);/*,ZERO_SUPPRESS_ITEM(XB,143)*/
SIGNAL_MAPPING(DATA12,XB144_1_T,vme_cbl.tdc.data[42],XB[143][0].T);/*,ZERO_SUPPRESS_ITEM(XB,143)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB144_2_E,vme_cbl.adc[3].data[24],XB[143][1].E);/*,ZERO_SUPPRESS_ITEM(XB,143)*/
SIGNAL_MAPPING(DATA12,XB144_2_T,vme_cbl.tdc.data[8],XB[143][1].T);/*,ZERO_SUPPRESS_ITEM(XB,143)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB145_1_E,vme_cbl.adc[2].data[25],XB[144][0].E);/*,ZERO_SUPPRESS_ITEM(XB,144)*/
SIGNAL_MAPPING(DATA12,XB145_1_T,vme_cbl.tdc.data[41],XB[144][0].T);/*,ZERO_SUPPRESS_ITEM(XB,144)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB145_2_E,vme_cbl.adc[3].data[2],XB[144][1].E);/*,ZERO_SUPPRESS_ITEM(XB,144)*/
SIGNAL_MAPPING(DATA12,XB145_2_T,vme_cbl.tdc.data[18],XB[144][1].T);/*,ZERO_SUPPRESS_ITEM(XB,144)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB146_1_E,vme_cbl.adc[2].data[27],XB[145][0].E);/*,ZERO_SUPPRESS_ITEM(XB,145)*/
SIGNAL_MAPPING(DATA12,XB146_1_T,vme_cbl.tdc.data[43],XB[145][0].T);/*,ZERO_SUPPRESS_ITEM(XB,145)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB146_2_E,vme_cbl.adc[3].data[10],XB[145][1].E);/*,ZERO_SUPPRESS_ITEM(XB,145)*/
SIGNAL_MAPPING(DATA12,XB146_2_T,vme_cbl.tdc.data[26],XB[145][1].T);/*,ZERO_SUPPRESS_ITEM(XB,145)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB147_1_E,vme_cbl.adc[1].data[6],XB[146][0].E);/*,ZERO_SUPPRESS_ITEM(XB,146)*/
SIGNAL_MAPPING(DATA12,XB147_1_T,vme_cbl.tdc.data[86],XB[146][0].T);/*,ZERO_SUPPRESS_ITEM(XB,146)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB147_2_E,vme_cbl.adc[3].data[5],XB[146][1].E);/*,ZERO_SUPPRESS_ITEM(XB,146)*/
SIGNAL_MAPPING(DATA12,XB147_2_T,vme_cbl.tdc.data[21],XB[146][1].T);/*,ZERO_SUPPRESS_ITEM(XB,146)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB148_1_E,vme_cbl.adc[1].data[14],XB[147][0].E);/*,ZERO_SUPPRESS_ITEM(XB,147)*/
SIGNAL_MAPPING(DATA12,XB148_1_T,vme_cbl.tdc.data[94],XB[147][0].T);/*,ZERO_SUPPRESS_ITEM(XB,147)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB149_1_E,vme_cbl.adc[1].data[24],XB[148][0].E);/*,ZERO_SUPPRESS_ITEM(XB,148)*/
SIGNAL_MAPPING(DATA12,XB149_1_T,vme_cbl.tdc.data[72],XB[148][0].T);/*,ZERO_SUPPRESS_ITEM(XB,148)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB150_1_E,vme_cbl.adc[0].data[4],XB[149][0].E);/*,ZERO_SUPPRESS_ITEM(XB,149)*/
SIGNAL_MAPPING(DATA12,XB150_1_T,vme_cbl.tdc.data[116],XB[149][0].T);/*,ZERO_SUPPRESS_ITEM(XB,149)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB151_1_E,vme_cbl.adc[0].data[6],XB[150][0].E);/*,ZERO_SUPPRESS_ITEM(XB,150)*/
SIGNAL_MAPPING(DATA12,XB151_1_T,vme_cbl.tdc.data[118],XB[150][0].T);/*,ZERO_SUPPRESS_ITEM(XB,150)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB152_1_E,vme_cbl.adc[0].data[5],XB[151][0].E);/*,ZERO_SUPPRESS_ITEM(XB,151)*/
SIGNAL_MAPPING(DATA12,XB152_1_T,vme_cbl.tdc.data[117],XB[151][0].T);/*,ZERO_SUPPRESS_ITEM(XB,151)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB153_1_E,vme_cbl.adc[1].data[25],XB[152][0].E);/*,ZERO_SUPPRESS_ITEM(XB,152)*/
SIGNAL_MAPPING(DATA12,XB153_1_T,vme_cbl.tdc.data[73],XB[152][0].T);/*,ZERO_SUPPRESS_ITEM(XB,152)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB154_1_E,vme_cbl.adc[1].data[15],XB[153][0].E);/*,ZERO_SUPPRESS_ITEM(XB,153)*/
SIGNAL_MAPPING(DATA12,XB154_1_T,vme_cbl.tdc.data[95],XB[153][0].T);/*,ZERO_SUPPRESS_ITEM(XB,153)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB155_1_E,vme_cbl.adc[1].data[7],XB[154][0].E);/*,ZERO_SUPPRESS_ITEM(XB,154)*/
SIGNAL_MAPPING(DATA12,XB155_1_T,vme_cbl.tdc.data[87],XB[154][0].T);/*,ZERO_SUPPRESS_ITEM(XB,154)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB155_2_E,vme_cbl.adc[3].data[27],XB[154][1].E);/*,ZERO_SUPPRESS_ITEM(XB,154)*/
SIGNAL_MAPPING(DATA12,XB155_2_T,vme_cbl.tdc.data[11],XB[154][1].T);/*,ZERO_SUPPRESS_ITEM(XB,154)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB156_1_E,vme_cbl.adc[1].data[4],XB[155][0].E);/*,ZERO_SUPPRESS_ITEM(XB,155)*/
SIGNAL_MAPPING(DATA12,XB156_1_T,vme_cbl.tdc.data[84],XB[155][0].T);/*,ZERO_SUPPRESS_ITEM(XB,155)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB156_2_E,vme_cbl.adc[3].data[30],XB[155][1].E);/*,ZERO_SUPPRESS_ITEM(XB,155)*/
SIGNAL_MAPPING(DATA12,XB156_2_T,vme_cbl.tdc.data[14],XB[155][1].T);/*,ZERO_SUPPRESS_ITEM(XB,155)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB157_1_E,vme_cbl.adc[1].data[5],XB[156][0].E);/*,ZERO_SUPPRESS_ITEM(XB,156)*/
SIGNAL_MAPPING(DATA12,XB157_1_T,vme_cbl.tdc.data[85],XB[156][0].T);/*,ZERO_SUPPRESS_ITEM(XB,156)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB157_2_E,vme_cbl.adc[3].data[8],XB[156][1].E);/*,ZERO_SUPPRESS_ITEM(XB,156)*/
SIGNAL_MAPPING(DATA12,XB157_2_T,vme_cbl.tdc.data[24],XB[156][1].T);/*,ZERO_SUPPRESS_ITEM(XB,156)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB158_1_E,vme_cbl.adc[1].data[16],XB[157][0].E);/*,ZERO_SUPPRESS_ITEM(XB,157)*/
SIGNAL_MAPPING(DATA12,XB158_1_T,vme_cbl.tdc.data[64],XB[157][0].T);/*,ZERO_SUPPRESS_ITEM(XB,157)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB159_1_E,vme_cbl.adc[1].data[26],XB[158][0].E);/*,ZERO_SUPPRESS_ITEM(XB,158)*/
SIGNAL_MAPPING(DATA12,XB159_1_T,vme_cbl.tdc.data[74],XB[158][0].T);/*,ZERO_SUPPRESS_ITEM(XB,158)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB160_1_E,vme_cbl.adc[1].data[27],XB[159][0].E);/*,ZERO_SUPPRESS_ITEM(XB,159)*/
SIGNAL_MAPPING(DATA12,XB160_1_T,vme_cbl.tdc.data[75],XB[159][0].T);/*,ZERO_SUPPRESS_ITEM(XB,159)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB161_1_E,vme_cbl.adc[1].data[17],XB[160][0].E);/*,ZERO_SUPPRESS_ITEM(XB,160)*/
SIGNAL_MAPPING(DATA12,XB161_1_T,vme_cbl.tdc.data[65],XB[160][0].T);/*,ZERO_SUPPRESS_ITEM(XB,160)*/
SIGNAL_MAPPING(DATA14_OVERFLOW,XB162_1_E,vme_cbl.adc[1].data[19],XB[161][0].E);/*,ZERO_SUPPRESS_ITEM(XB,161)*/
SIGNAL_MAPPING(DATA12,XB162_1_T,vme_cbl.tdc.data[67],XB[161][0].T);/*,ZERO_SUPPRESS_ITEM(XB,161)*/
SIGNAL_MAPPING(DATA12,XBTRIG01_1_T,vme1.tdc775POS_ROLU.data[16],XBTRIG[0][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG02_1_T,vme1.tdc775POS_ROLU.data[17],XBTRIG[1][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG03_1_T,vme1.tdc775POS_ROLU.data[18],XBTRIG[2][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG04_1_T,vme1.tdc775POS_ROLU.data[19],XBTRIG[3][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG05_1_T,vme1.tdc775POS_ROLU.data[20],XBTRIG[4][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG06_1_T,vme1.tdc775POS_ROLU.data[21],XBTRIG[5][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG07_1_T,vme1.tdc775POS_ROLU.data[22],XBTRIG[6][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG08_1_T,vme1.tdc775POS_ROLU.data[23],XBTRIG[7][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG09_1_T,vme1.tdc775POS_ROLU.data[24],XBTRIG[8][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG10_1_T,vme1.tdc775POS_ROLU.data[25],XBTRIG[9][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG11_1_T,vme1.tdc775POS_ROLU.data[26],XBTRIG[10][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG12_1_T,vme1.tdc775POS_ROLU.data[27],XBTRIG[11][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG13_1_T,vme1.tdc775POS_ROLU.data[28],XBTRIG[12][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG14_1_T,vme1.tdc775POS_ROLU.data[29],XBTRIG[13][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG15_1_T,vme1.tdc775POS_ROLU.data[30],XBTRIG[14][0].T);
SIGNAL_MAPPING(DATA12,XBTRIG16_1_T,vme1.tdc775POS_ROLU.data[31],XBTRIG[15][0].T);

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "s406.spec" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "s406.spec" },
  { 13, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 14, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 15, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_lecroy_4434.spec" },
  { 16, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_lecroy_4434.spec" },
  { 32, 24, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 33, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_silena_4418.spec" },
  { 34, 28, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_silena_4418.spec" },
  { 61, 25, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 62, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_phillips_7164.spec" },
  { 63, 26, "/u/taniuchi/s467/upexps/../ucesb/spec/camac_phillips_7164.spec" },
  { 88, 26, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 90, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/fastbus.spec" },
  { 91, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/fastbus.spec" },
  { 126, 28, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 128, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v775.spec" },
  { 129, 26, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v775.spec" },
  { 173, 30, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 174, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v830.spec" },
  { 175, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v830.spec" },
  { 204, 31, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 205, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 206, 27, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 207, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 208, 39, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 406, 28, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 412, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 413, 39, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 611, 34, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_caen_v1290.spec" },
  { 612, 32, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 614, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_madc32.spec" },
  { 615, 23, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_madc32.spec" },
  { 657, 34, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 658, 1, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_mdpp16.spec" },
  { 659, 35, "/u/taniuchi/s467/upexps/../ucesb/spec/vme_mesytec_mdpp16.spec" },
  { 701, 35, "/u/taniuchi/s467/upexps/../ucesb/spec/spec.spec" },
  { 702, 7, "s406.spec" },
  { 703, 1, "siderem01_vme.spec" },
  { 708, 1, "/u/taniuchi/s467/upexps/../ucesb/dets/sst/sst_ext.spec" },
  { 709, 24, "/u/taniuchi/s467/upexps/../ucesb/dets/sst/sst_ext.spec" },
  { 711, 6, "siderem01_vme.spec" },
  { 767, 8, "s406.spec" },
  { 768, 1, "/u/taniuchi/s467/upexps/../ucesb/dets/pdc/cros3_ext.spec" },
  { 769, 23, "/u/taniuchi/s467/upexps/../ucesb/dets/pdc/cros3_ext.spec" },
  { 781, 1, "/u/taniuchi/s467/upexps/../ucesb/dets/pdc/cros3_v27rewrite.spec" },
  { 782, 34, "/u/taniuchi/s467/upexps/../ucesb/dets/pdc/cros3_v27rewrite.spec" },
  { 916, 35, "/u/taniuchi/s467/upexps/../ucesb/dets/pdc/cros3_ext.spec" },
  { 926, 9, "s406.spec" },
  { 927, 1, "./../land_common/land_camac_converter.spec" },
  { 939, 1, "./camac_c2.hh" },
  { 941, 13, "./../land_common/land_camac_converter.spec" },
  { 942, 1, "./camac_c3.hh" },
  { 944, 14, "./../land_common/land_camac_converter.spec" },
  { 948, 1, "./../land_common/ntp_tcal.spec" },
  { 1059, 18, "./../land_common/land_camac_converter.spec" },
  { 1071, 10, "s406.spec" },
  { 1072, 1, "./../land_common/land_camac_scaler.spec" },
  { 1113, 11, "s406.spec" },
  { 1114, 1, "./../land_common/land_camac_pileup.spec" },
  { 1145, 12, "s406.spec" },
  { 1146, 1, "./../land_common/land_vme.spec" },
  { 1207, 13, "s406.spec" },
  { 1208, 1, "land_vme_subev.spec" },
  { 1317, 14, "s406.spec" },
  { 1318, 1, "./../land_common/land_type_subtype.spec" },
  { 1319, 15, "s406.spec" },
  { 1321, 1, "./../land_common/vuprom_v35.spec" },
  { 1350, 17, "s406.spec" },
  { 1351, 1, "./../land_common/tacquila.spec" },
  { 1417, 18, "s406.spec" },
  { 1462, 1, "mapping.hh" },
  { 1672, 63, "s406.spec" },
  { 1673, 1, "xb_mapping.hh" },
  { 2118, 64, "s406.spec" },
};

/** END_LOCATIONS *****************************************************/

