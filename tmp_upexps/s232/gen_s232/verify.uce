
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

CAMAC_LECROY_4434(channels)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    UINT32 ch_data NOENCODE
    {
       0_23: value;
      24_31: 0;
      ENCODE(data[index],(value=value));
    }
  }
}

CAMAC_PHILLIPS_7164(channels,mark_channel_no)
{
  MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    if(mark_channel_no)
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        12_15: channel = CHECK(index);
        ENCODE(data[index],(value=value));
      }
    }
    else
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        ENCODE(data[index],(value=value));
      }
    }
  }
}

CAMAC_SILENA_4418(channels,mark_channel_no)
{
  MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    if(mark_channel_no)
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
        12_14: channel = CHECK(index);
           15: overflow;
        ENCODE(data[index],(value=value,overflow=overflow));
      }
    }
    else
    {
      UINT16 ch_data NOENCODE
      {
         0_11: value;
           15: overflow;
        ENCODE(data[index],(value=value,overflow=overflow));
      }
    }
  }
}

FASTBUS_LECROY_1875(geom,channels)
{
  MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  UINT32 ch_data NOENCODE
  {
     0_11: value;
    16_21: channel = RANGE(0,(channels - 1));
       23: range;
    24_26: n = CHECK(0);
    27_31: geom = MATCH(geom);
    ENCODE(data[channel],(value=value,range=range));
  }
}

FASTBUS_LECROY_1885(geom,channels)
{
  MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  UINT32 ch_data NOENCODE
  {
     0_11: value;
    16_22: channel = RANGE(0,(channels - 1));
       23: range;
    24_26: n = CHECK(0);
    27_31: geom = MATCH(geom);
    ENCODE(data[channel],(value=value,range=range));
  }
}

NTP64_TIME()
{
  UINT32 sec;
  UINT32 frac;
}

NTP_MESSAGE(id)
{
  UINT32 header
  {
     0_15: word_count;
       16: quick_burst;
    24_31: id = MATCH(id);
  }
  MARK_COUNT(start);
  UINT32 server_id;
  UINT32 sspp
  {
     0_07: precision;
     8_15: poll;
    16_19: stratum;
    24_26: mode;
    27_29: version = CHECK(3);
    30_31: leap;
  }
  UINT32 root_dly
  {
     0_15: frac;
    16_31: sec;
  }
  UINT32 root_disp
  {
     0_15: frac;
    16_31: sec;
  }
  UINT32 refid;
  reftime = NTP64_TIME();
  origtime = NTP64_TIME();
  rectime = NTP64_TIME();
  tmittime = NTP64_TIME();
  rxtime = NTP64_TIME();
  if(header.quick_burst)
  {
    orig2time = NTP64_TIME();
    rec2time = NTP64_TIME();
    tmit2time = NTP64_TIME();
    rx2time = NTP64_TIME();
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_count,start,end,0,4)
}

RANDOM_TCAL(id)
{
  UINT32 header
  {
     0_07: word_count;
     8_11: pulses;
    12_17: clock_bits;
       18: has_tstamp1;
       19: has_tstamp2;
    24_31: id = MATCH(id);
  }
  MARK_COUNT(start);
  if(header.has_tstamp1)
  {
    tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
  }
  if(header.has_tstamp2)
  {
    tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_count,start,end,0,4)
}

RANDOM_TCAL_TSTAMP_CLOCK()
{
  UINT32 soft_latches;
  UINT32 hard_latches;
  UINT32 clock_ticks;
  before = NTP64_TIME();
  after = NTP64_TIME();
}

SOFT_SCALER32(channels)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  list(0<=index<channels)
  {
    UINT32 ch_data NOENCODE
    {
       0_31: value;
      ENCODE(data[index],(value=value));
    }
  }
}

VME_CAEN_V1190(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   data=data);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1190_SHORT(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         data=data);
    norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  UINT32 ch_data NOENCODE
  {
     0_18: value;
    19_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  }
}

VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
{
  UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
}

VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(tdc_start);
  UINT32 header
  {
     0_11: bunch_id;
    12_23: event_id = CHECK(event_id);
    24_25: tdc = MATCH(tdc);
    27_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_18: value;
    19_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  }
  optional UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
  MARK_COUNT(tdc_end);
  UINT32 trailer
  {
     0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    12_23: event_id = CHECK(header.event_id);
    24_25: tdc = CHECK(tdc);
    27_31: 3;
  }
}

VME_CAEN_V1290(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   data=data);
    tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   data=data);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1290_SHORT(geom)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(v1190_start);
  UINT32 header
  {
     0_04: geom = MATCH(geom);
     5_26: event_number;
    27_31: 8;
  }
  select several
  {
    tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         data=data);
    tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         data=data);
    norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  }
  UINT32 trigger
  {
     0_26: time_tag;
    27_31: 17;
  }
  MARK_COUNT(v1190_end);
  UINT32 trailer
  {
     0_04: geom = CHECK(geom);
     5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
       24: tdc_error;
       25: buffer_overflow;
       26: trigger_lost;
    27_31: 16;
  }
}

VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  UINT32 ch_data NOENCODE
  {
     0_20: value;
    21_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  }
}

VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
{
  UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
}

VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
{
  MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  MARK_COUNT(tdc_start);
  UINT32 header
  {
     0_11: bunch_id;
    12_23: event_id = CHECK(event_id);
    24_25: tdc = MATCH(tdc);
    27_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_20: value;
    21_23: channel_low;
    24_25: tdc = CHECK(tdc);
       26: trailing;
    27_31: 0;
    ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  }
  optional UINT32 error_flags
  {
     0_14: flags;
    24_25: tdc = CHECK(tdc);
    27_31: 4;
  }
  MARK_COUNT(tdc_end);
  UINT32 trailer
  {
     0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    12_23: event_id = CHECK(header.event_id);
    24_25: tdc = CHECK(tdc);
    27_31: 3;
  }
}

VME_CAEN_V775(geom,crate)
{
  MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     8_13: count;
    16_23: crate = MATCH(crate);
    24_26: 2;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_11: value;
         12: overflow;
         13: underflow;
         14: valid;
      16_20: channel;
      24_26: 0;
      27_31: geom = CHECK(geom);
      ENCODE(data[channel],(value=value,overflow=overflow));
    }
  }
  UINT32 eob
  {
     0_23: event_number;
    24_26: 4;
    27_31: geom = CHECK(geom);
  }
}

VME_CAEN_V830(geom)
{
  MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  UINT32 header
  {
     0_15: event_number;
    16_17: ts;
    18_23: count;
       26: 1;
    27_31: geom = MATCH(geom);
  }
  list(0<=index<header.count)
  {
    UINT32 ch_data NOENCODE
    {
       0_25: value;
         26: 0;
      27_31: channel;
      ENCODE(data[channel],(value=value));
    }
  }
}

VME_MESYTEC_MADC32(geom)
{
  MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_14: adc_resol;
       15: out_form;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_12: value;
       14: outofrange;
    16_20: channel;
    21_29: 32;
    30_31: 0;
    ENCODE(data[channel],(value=value,overflow=outofrange));
  }
  optional UINT32 filler NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

VME_MESYTEC_MDPP16(geom)
{
  MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_09: word_number;
    10_12: adc_res;
    13_15: tdc_res;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_15: value;
    16_21: channel;
       22: overflow;
       23: pileup;
    24_27: 0;
    28_31: 1;
    ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  }
  several UINT32 fill_word NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

SUBEVENT(LAND_CAMAC_CONVERTER)
{
  UINT16 tpat;
  UINT16 tprev;
  UINT16 tnext;
  UINT16 tprev2;
  if(EXTERNAL has_data)
  {
    tPHI7079 = CAMAC_PHILLIPS_7164(channels=16,mark_channel_no=1);
    aPHI12160 = CAMAC_PHILLIPS_7164(channels=14,mark_channel_no=1);
    qSIA0415 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    qSIA0418 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    qSIA0458 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    tSIA0400 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    tSIA0426 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    tSIA0401 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
  }
}

SUBEVENT(LAND_CAMAC_SCALER)
{
  scaler0 = CAMAC_LECROY_4434(channels=32);
  scaler1 = CAMAC_LECROY_4434(channels=32);
  scaler2 = CAMAC_LECROY_4434(channels=32);
  if(EXTERNAL has_timestamp)
  {
    UINT32 timestamp;
    UINT32 endianess
    {
       0_31: 0x87654321;
    }
  }
}

SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
{
  UINT32 timestamp;
  UINT32 endianess
  {
     0_31: 0x87654321;
  }
}

SUBEVENT(LAND_CAMAC_TCAL_INFO)
{
  UINT32 info;
  select several
  {
    rtcal = RANDOM_TCAL(id=231);
    ntp = NTP_MESSAGE(id=239);
  }
}

SUBEVENT(LAND_FASTBUS1)
{
  UINT32 zero NOENCODE
  {
     0_31: 0;
  }
  select several
  {
    T87044 = FASTBUS_LECROY_1875(geom=4,channels=64);
    T87024 = FASTBUS_LECROY_1875(geom=5,channels=64);
    T81800 = FASTBUS_LECROY_1875(geom=6,channels=64);
    Q47342 = FASTBUS_LECROY_1885(geom=7,channels=96);
    Q11111 = FASTBUS_LECROY_1885(geom=8,channels=96);
    Q47264 = FASTBUS_LECROY_1885(geom=9,channels=96);
    Q46848 = FASTBUS_LECROY_1885(geom=10,channels=96);
    T81855 = FASTBUS_LECROY_1875(geom=12,channels=64);
    Q17320 = FASTBUS_LECROY_1885(geom=13,channels=96);
    Q47315 = FASTBUS_LECROY_1885(geom=14,channels=96);
    Q15372 = FASTBUS_LECROY_1885(geom=15,channels=96);
    Q46962 = FASTBUS_LECROY_1885(geom=16,channels=96);
    Q15358 = FASTBUS_LECROY_1885(geom=17,channels=96);
    Q46993 = FASTBUS_LECROY_1885(geom=18,channels=96);
    T87047 = FASTBUS_LECROY_1875(geom=19,channels=64);
    T48854 = FASTBUS_LECROY_1875(geom=20,channels=64);
    T81808 = FASTBUS_LECROY_1875(geom=21,channels=64);
    T81859 = FASTBUS_LECROY_1875(geom=22,channels=64);
    T81795 = FASTBUS_LECROY_1875(geom=23,channels=64);
    T81806 = FASTBUS_LECROY_1875(geom=24,channels=64);
    T48834 = FASTBUS_LECROY_1875(geom=25,channels=64);
  }
}

SUBEVENT(LAND_FASTBUS_ERROR)
{
  UINT32 error_code
  {
        0: timeout_waiting_smi;
        1: illegal_block_transfer;
        2: fifa_address_overflow;
        3: fifa_register_error;
       16: init_error;
  }
  UINT32 error_num;
}

SUBEVENT(LAND_FASTBUS_ERROR_NGF)
{
  UINT32 magic
  {
     0_31: 0x10000000;
  }
  UINT32 error_code
  {
        0: error;
        1: uninitialized;
        2: ss1;
        3: wc;
        4: mid;
        5: fifo_empty;
        6: fifo_not_empty;
        7: not_finished;
        8: bad_end_addr;
        9: word_lost;
  }
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  fastbus_error = LAND_FASTBUS_ERROR(type=31,subtype=0xc1c);
  fastbus1 = LAND_FASTBUS1(type=32,subtype=0xc1c);
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(CS001_1_E,fastbus1.Q11111.data[0],DATA12);
SIGNAL(CS001_1_T,fastbus1.T81800.data[0],DATA12);
SIGNAL(CS002_1_E,fastbus1.Q11111.data[2],DATA12);
SIGNAL(CS002_1_T,fastbus1.T81800.data[2],DATA12);
SIGNAL(CS003_1_E,fastbus1.Q11111.data[4],DATA12);
SIGNAL(CS003_1_T,fastbus1.T81800.data[4],DATA12);
SIGNAL(CS004_1_E,fastbus1.Q11111.data[65],DATA12);
SIGNAL(CS004_1_T,fastbus1.T87024.data[1],DATA12);
SIGNAL(CS005_1_E,fastbus1.Q11111.data[67],DATA12);
SIGNAL(CS005_1_T,fastbus1.T87024.data[3],DATA12);
SIGNAL(CS006_1_E,fastbus1.Q11111.data[69],DATA12);
SIGNAL(CS006_1_T,fastbus1.T87024.data[5],DATA12);
SIGNAL(CS007_1_E,fastbus1.Q11111.data[71],DATA12);
SIGNAL(CS007_1_T,fastbus1.T87024.data[7],DATA12);
SIGNAL(CS008_1_E,fastbus1.Q11111.data[73],DATA12);
SIGNAL(CS008_1_T,fastbus1.T87024.data[9],DATA12);
SIGNAL(CS009_1_E,fastbus1.Q11111.data[75],DATA12);
SIGNAL(CS009_1_T,fastbus1.T87024.data[11],DATA12);
SIGNAL(CS010_1_E,fastbus1.Q11111.data[6],DATA12);
SIGNAL(CS010_1_T,fastbus1.T81800.data[6],DATA12);
SIGNAL(CS011_1_E,fastbus1.Q11111.data[8],DATA12);
SIGNAL(CS011_1_T,fastbus1.T81800.data[8],DATA12);
SIGNAL(CS012_1_E,fastbus1.Q11111.data[10],DATA12);
SIGNAL(CS012_1_T,fastbus1.T81800.data[10],DATA12);
SIGNAL(CS013_1_E,fastbus1.Q11111.data[12],DATA12);
SIGNAL(CS013_1_T,fastbus1.T81800.data[12],DATA12);
SIGNAL(CS014_1_E,fastbus1.Q11111.data[14],DATA12);
SIGNAL(CS014_1_T,fastbus1.T81800.data[14],DATA12);
SIGNAL(CS015_1_E,fastbus1.Q11111.data[1],DATA12);
SIGNAL(CS015_1_T,fastbus1.T81800.data[1],DATA12);
SIGNAL(CS016_1_E,fastbus1.Q11111.data[77],DATA12);
SIGNAL(CS016_1_T,fastbus1.T87024.data[13],DATA12);
SIGNAL(CS017_1_E,fastbus1.Q11111.data[79],DATA12);
SIGNAL(CS017_1_T,fastbus1.T87024.data[15],DATA12);
SIGNAL(CS018_1_E,fastbus1.Q11111.data[80],DATA12);
SIGNAL(CS018_1_T,fastbus1.T87024.data[16],DATA12);
SIGNAL(CS019_1_E,fastbus1.Q11111.data[82],DATA12);
SIGNAL(CS019_1_T,fastbus1.T87024.data[18],DATA12);
SIGNAL(CS020_1_E,fastbus1.Q11111.data[84],DATA12);
SIGNAL(CS020_1_T,fastbus1.T87024.data[20],DATA12);
SIGNAL(CS021_1_E,fastbus1.Q11111.data[86],DATA12);
SIGNAL(CS021_1_T,fastbus1.T87024.data[22],DATA12);
SIGNAL(CS022_1_E,fastbus1.Q11111.data[3],DATA12);
SIGNAL(CS022_1_T,fastbus1.T81800.data[3],DATA12);
SIGNAL(CS023_1_E,fastbus1.Q11111.data[5],DATA12);
SIGNAL(CS023_1_T,fastbus1.T81800.data[5],DATA12);
SIGNAL(CS024_1_E,fastbus1.Q11111.data[7],DATA12);
SIGNAL(CS024_1_T,fastbus1.T81800.data[7],DATA12);
SIGNAL(CS025_1_E,fastbus1.Q11111.data[9],DATA12);
SIGNAL(CS025_1_T,fastbus1.T81800.data[9],DATA12);
SIGNAL(CS026_1_E,fastbus1.Q11111.data[11],DATA12);
SIGNAL(CS026_1_T,fastbus1.T81800.data[11],DATA12);
SIGNAL(CS027_1_E,fastbus1.Q11111.data[13],DATA12);
SIGNAL(CS027_1_T,fastbus1.T81800.data[13],DATA12);
SIGNAL(CS028_1_E,fastbus1.Q11111.data[88],DATA12);
SIGNAL(CS028_1_T,fastbus1.T87024.data[24],DATA12);
SIGNAL(CS029_1_E,fastbus1.Q11111.data[90],DATA12);
SIGNAL(CS029_1_T,fastbus1.T87024.data[26],DATA12);
SIGNAL(CS030_1_E,fastbus1.Q11111.data[92],DATA12);
SIGNAL(CS030_1_T,fastbus1.T87024.data[28],DATA12);
SIGNAL(CS031_1_E,fastbus1.Q11111.data[94],DATA12);
SIGNAL(CS031_1_T,fastbus1.T87024.data[30],DATA12);
SIGNAL(CS032_1_E,fastbus1.Q11111.data[81],DATA12);
SIGNAL(CS032_1_T,fastbus1.T87024.data[17],DATA12);
SIGNAL(CS033_1_E,fastbus1.Q11111.data[83],DATA12);
SIGNAL(CS033_1_T,fastbus1.T87024.data[19],DATA12);
SIGNAL(CS034_1_E,fastbus1.Q11111.data[15],DATA12);
SIGNAL(CS034_1_T,fastbus1.T81800.data[15],DATA12);
SIGNAL(CS035_1_E,fastbus1.Q11111.data[16],DATA12);
SIGNAL(CS035_1_T,fastbus1.T81800.data[16],DATA12);
SIGNAL(CS036_1_E,fastbus1.Q11111.data[18],DATA12);
SIGNAL(CS036_1_T,fastbus1.T81800.data[18],DATA12);
SIGNAL(CS037_1_E,fastbus1.Q11111.data[20],DATA12);
SIGNAL(CS037_1_T,fastbus1.T81800.data[20],DATA12);
SIGNAL(CS038_1_E,fastbus1.Q11111.data[22],DATA12);
SIGNAL(CS038_1_T,fastbus1.T81800.data[22],DATA12);
SIGNAL(CS039_1_E,fastbus1.Q11111.data[24],DATA12);
SIGNAL(CS039_1_T,fastbus1.T81800.data[24],DATA12);
SIGNAL(CS040_1_E,fastbus1.Q11111.data[85],DATA12);
SIGNAL(CS040_1_T,fastbus1.T87024.data[21],DATA12);
SIGNAL(CS041_1_E,fastbus1.Q11111.data[87],DATA12);
SIGNAL(CS041_1_T,fastbus1.T87024.data[23],DATA12);
SIGNAL(CS042_1_E,fastbus1.Q11111.data[89],DATA12);
SIGNAL(CS042_1_T,fastbus1.T87024.data[25],DATA12);
SIGNAL(CS043_1_E,fastbus1.Q11111.data[91],DATA12);
SIGNAL(CS043_1_T,fastbus1.T87024.data[27],DATA12);
SIGNAL(CS044_1_E,fastbus1.Q11111.data[93],DATA12);
SIGNAL(CS044_1_T,fastbus1.T87024.data[29],DATA12);
SIGNAL(CS045_1_E,fastbus1.Q11111.data[95],DATA12);
SIGNAL(CS045_1_T,fastbus1.T87024.data[31],DATA12);
SIGNAL(CS046_1_E,fastbus1.Q11111.data[26],DATA12);
SIGNAL(CS046_1_T,fastbus1.T81800.data[26],DATA12);
SIGNAL(CS047_1_E,fastbus1.Q11111.data[28],DATA12);
SIGNAL(CS047_1_T,fastbus1.T81800.data[28],DATA12);
SIGNAL(CS048_1_E,fastbus1.Q11111.data[30],DATA12);
SIGNAL(CS048_1_T,fastbus1.T81800.data[30],DATA12);
SIGNAL(CS049_1_E,fastbus1.Q11111.data[17],DATA12);
SIGNAL(CS049_1_T,fastbus1.T81800.data[17],DATA12);
SIGNAL(CS050_1_E,fastbus1.Q11111.data[19],DATA12);
SIGNAL(CS050_1_T,fastbus1.T81800.data[19],DATA12);
SIGNAL(CS051_1_E,fastbus1.Q11111.data[21],DATA12);
SIGNAL(CS051_1_T,fastbus1.T81800.data[21],DATA12);
SIGNAL(CS052_1_E,fastbus1.Q47342.data[0],DATA12);
SIGNAL(CS052_1_T,fastbus1.T87044.data[16],DATA12);
SIGNAL(CS053_1_E,fastbus1.Q47342.data[2],DATA12);
SIGNAL(CS053_1_T,fastbus1.T87044.data[18],DATA12);
SIGNAL(CS054_1_E,fastbus1.Q47342.data[4],DATA12);
SIGNAL(CS054_1_T,fastbus1.T87044.data[20],DATA12);
SIGNAL(CS055_1_E,fastbus1.Q47342.data[6],DATA12);
SIGNAL(CS055_1_T,fastbus1.T87044.data[22],DATA12);
SIGNAL(CS056_1_E,fastbus1.Q47342.data[8],DATA12);
SIGNAL(CS056_1_T,fastbus1.T87044.data[24],DATA12);
SIGNAL(CS057_1_E,fastbus1.Q47342.data[10],DATA12);
SIGNAL(CS057_1_T,fastbus1.T87044.data[26],DATA12);
SIGNAL(CS058_1_E,fastbus1.Q11111.data[23],DATA12);
SIGNAL(CS058_1_T,fastbus1.T81800.data[23],DATA12);
SIGNAL(CS059_1_E,fastbus1.Q11111.data[25],DATA12);
SIGNAL(CS059_1_T,fastbus1.T81800.data[25],DATA12);
SIGNAL(CS060_1_E,fastbus1.Q11111.data[27],DATA12);
SIGNAL(CS060_1_T,fastbus1.T81800.data[27],DATA12);
SIGNAL(CS061_1_E,fastbus1.Q11111.data[29],DATA12);
SIGNAL(CS061_1_T,fastbus1.T81800.data[29],DATA12);
SIGNAL(CS062_1_E,fastbus1.Q11111.data[31],DATA12);
SIGNAL(CS062_1_T,fastbus1.T81800.data[31],DATA12);
SIGNAL(CS063_1_E,fastbus1.Q11111.data[32],DATA12);
SIGNAL(CS063_1_T,fastbus1.T81800.data[32],DATA12);
SIGNAL(CS064_1_E,fastbus1.Q47342.data[12],DATA12);
SIGNAL(CS064_1_T,fastbus1.T87044.data[28],DATA12);
SIGNAL(CS065_1_E,fastbus1.Q47342.data[14],DATA12);
SIGNAL(CS065_1_T,fastbus1.T87044.data[30],DATA12);
SIGNAL(CS066_1_E,fastbus1.Q47342.data[1],DATA12);
SIGNAL(CS066_1_T,fastbus1.T87044.data[17],DATA12);
SIGNAL(CS067_1_E,fastbus1.Q47342.data[3],DATA12);
SIGNAL(CS067_1_T,fastbus1.T87044.data[19],DATA12);
SIGNAL(CS068_1_E,fastbus1.Q47342.data[5],DATA12);
SIGNAL(CS068_1_T,fastbus1.T87044.data[21],DATA12);
SIGNAL(CS069_1_E,fastbus1.Q47342.data[7],DATA12);
SIGNAL(CS069_1_T,fastbus1.T87044.data[23],DATA12);
SIGNAL(CS070_1_E,fastbus1.Q11111.data[34],DATA12);
SIGNAL(CS070_1_T,fastbus1.T81800.data[34],DATA12);
SIGNAL(CS071_1_E,fastbus1.Q11111.data[36],DATA12);
SIGNAL(CS071_1_T,fastbus1.T81800.data[36],DATA12);
SIGNAL(CS072_1_E,fastbus1.Q11111.data[38],DATA12);
SIGNAL(CS072_1_T,fastbus1.T81800.data[38],DATA12);
SIGNAL(CS073_1_E,fastbus1.Q11111.data[40],DATA12);
SIGNAL(CS073_1_T,fastbus1.T81800.data[40],DATA12);
SIGNAL(CS074_1_E,fastbus1.Q11111.data[42],DATA12);
SIGNAL(CS074_1_T,fastbus1.T81800.data[42],DATA12);
SIGNAL(CS075_1_E,fastbus1.Q11111.data[44],DATA12);
SIGNAL(CS075_1_T,fastbus1.T81800.data[44],DATA12);
SIGNAL(CS076_1_E,fastbus1.Q47342.data[9],DATA12);
SIGNAL(CS076_1_T,fastbus1.T87044.data[25],DATA12);
SIGNAL(CS077_1_E,fastbus1.Q47342.data[11],DATA12);
SIGNAL(CS077_1_T,fastbus1.T87044.data[27],DATA12);
SIGNAL(CS078_1_E,fastbus1.Q47342.data[13],DATA12);
SIGNAL(CS078_1_T,fastbus1.T87044.data[29],DATA12);
SIGNAL(CS079_1_E,fastbus1.Q47342.data[15],DATA12);
SIGNAL(CS079_1_T,fastbus1.T87044.data[31],DATA12);
SIGNAL(CS080_1_E,fastbus1.Q47342.data[16],DATA12);
SIGNAL(CS080_1_T,fastbus1.T87024.data[48],DATA12);
SIGNAL(CS081_1_E,fastbus1.Q47342.data[18],DATA12);
SIGNAL(CS081_1_T,fastbus1.T87024.data[50],DATA12);
SIGNAL(CS082_1_E,fastbus1.Q11111.data[46],DATA12);
SIGNAL(CS082_1_T,fastbus1.T81800.data[46],DATA12);
SIGNAL(CS083_1_E,fastbus1.Q11111.data[33],DATA12);
SIGNAL(CS083_1_T,fastbus1.T81800.data[33],DATA12);
SIGNAL(CS084_1_E,fastbus1.Q11111.data[35],DATA12);
SIGNAL(CS084_1_T,fastbus1.T81800.data[35],DATA12);
SIGNAL(CS085_1_E,fastbus1.Q11111.data[37],DATA12);
SIGNAL(CS085_1_T,fastbus1.T81800.data[37],DATA12);
SIGNAL(CS086_1_E,fastbus1.Q11111.data[39],DATA12);
SIGNAL(CS086_1_T,fastbus1.T81800.data[39],DATA12);
SIGNAL(CS087_1_E,fastbus1.Q11111.data[41],DATA12);
SIGNAL(CS087_1_T,fastbus1.T81800.data[41],DATA12);
SIGNAL(CS088_1_E,fastbus1.Q47342.data[20],DATA12);
SIGNAL(CS088_1_T,fastbus1.T87024.data[52],DATA12);
SIGNAL(CS089_1_E,fastbus1.Q47342.data[22],DATA12);
SIGNAL(CS089_1_T,fastbus1.T87024.data[54],DATA12);
SIGNAL(CS090_1_E,fastbus1.Q47342.data[24],DATA12);
SIGNAL(CS090_1_T,fastbus1.T87024.data[56],DATA12);
SIGNAL(CS091_1_E,fastbus1.Q47342.data[26],DATA12);
SIGNAL(CS091_1_T,fastbus1.T87024.data[58],DATA12);
SIGNAL(CS092_1_E,fastbus1.Q47342.data[28],DATA12);
SIGNAL(CS092_1_T,fastbus1.T87024.data[60],DATA12);
SIGNAL(CS093_1_E,fastbus1.Q47342.data[30],DATA12);
SIGNAL(CS093_1_T,fastbus1.T87024.data[62],DATA12);
SIGNAL(CS094_1_E,fastbus1.Q11111.data[43],DATA12);
SIGNAL(CS094_1_T,fastbus1.T81800.data[43],DATA12);
SIGNAL(CS095_1_E,fastbus1.Q11111.data[45],DATA12);
SIGNAL(CS095_1_T,fastbus1.T81800.data[45],DATA12);
SIGNAL(CS096_1_E,fastbus1.Q11111.data[47],DATA12);
SIGNAL(CS096_1_T,fastbus1.T81800.data[47],DATA12);
SIGNAL(CS097_1_E,fastbus1.Q11111.data[48],DATA12);
SIGNAL(CS097_1_T,fastbus1.T81800.data[48],DATA12);
SIGNAL(CS098_1_E,fastbus1.Q11111.data[50],DATA12);
SIGNAL(CS098_1_T,fastbus1.T81800.data[50],DATA12);
SIGNAL(CS099_1_E,fastbus1.Q11111.data[52],DATA12);
SIGNAL(CS099_1_T,fastbus1.T81800.data[52],DATA12);
SIGNAL(CS100_1_E,fastbus1.Q47342.data[17],DATA12);
SIGNAL(CS100_1_T,fastbus1.T87024.data[49],DATA12);
SIGNAL(CS101_1_E,fastbus1.Q47342.data[19],DATA12);
SIGNAL(CS101_1_T,fastbus1.T87024.data[51],DATA12);
SIGNAL(CS102_1_E,fastbus1.Q47342.data[21],DATA12);
SIGNAL(CS102_1_T,fastbus1.T87024.data[53],DATA12);
SIGNAL(CS103_1_E,fastbus1.Q47342.data[23],DATA12);
SIGNAL(CS103_1_T,fastbus1.T87024.data[55],DATA12);
SIGNAL(CS104_1_E,fastbus1.Q47342.data[25],DATA12);
SIGNAL(CS104_1_T,fastbus1.T87024.data[57],DATA12);
SIGNAL(CS105_1_E,fastbus1.Q47342.data[27],DATA12);
SIGNAL(CS105_1_T,fastbus1.T87024.data[59],DATA12);
SIGNAL(CS106_1_E,fastbus1.Q11111.data[54],DATA12);
SIGNAL(CS106_1_T,fastbus1.T81800.data[54],DATA12);
SIGNAL(CS107_1_E,fastbus1.Q11111.data[56],DATA12);
SIGNAL(CS107_1_T,fastbus1.T81800.data[56],DATA12);
SIGNAL(CS108_1_E,fastbus1.Q11111.data[58],DATA12);
SIGNAL(CS108_1_T,fastbus1.T81800.data[58],DATA12);
SIGNAL(CS109_1_E,fastbus1.Q11111.data[60],DATA12);
SIGNAL(CS109_1_T,fastbus1.T81800.data[60],DATA12);
SIGNAL(CS110_1_E,fastbus1.Q11111.data[62],DATA12);
SIGNAL(CS110_1_T,fastbus1.T81800.data[62],DATA12);
SIGNAL(CS111_1_E,fastbus1.Q11111.data[49],DATA12);
SIGNAL(CS111_1_T,fastbus1.T81800.data[49],DATA12);
SIGNAL(CS112_1_E,fastbus1.Q47342.data[29],DATA12);
SIGNAL(CS112_1_T,fastbus1.T87024.data[61],DATA12);
SIGNAL(CS113_1_E,fastbus1.Q47342.data[31],DATA12);
SIGNAL(CS113_1_T,fastbus1.T87024.data[63],DATA12);
SIGNAL(CS114_1_E,fastbus1.Q47342.data[32],DATA12);
SIGNAL(CS114_1_T,fastbus1.T87044.data[0],DATA12);
SIGNAL(CS115_1_E,fastbus1.Q47342.data[34],DATA12);
SIGNAL(CS115_1_T,fastbus1.T87044.data[2],DATA12);
SIGNAL(CS116_1_E,fastbus1.Q47342.data[36],DATA12);
SIGNAL(CS116_1_T,fastbus1.T87044.data[4],DATA12);
SIGNAL(CS117_1_E,fastbus1.Q47342.data[38],DATA12);
SIGNAL(CS117_1_T,fastbus1.T87044.data[6],DATA12);
SIGNAL(CS118_1_E,fastbus1.Q11111.data[51],DATA12);
SIGNAL(CS118_1_T,fastbus1.T81800.data[51],DATA12);
SIGNAL(CS119_1_E,fastbus1.Q11111.data[53],DATA12);
SIGNAL(CS119_1_T,fastbus1.T81800.data[53],DATA12);
SIGNAL(CS120_1_E,fastbus1.Q11111.data[55],DATA12);
SIGNAL(CS120_1_T,fastbus1.T81800.data[55],DATA12);
SIGNAL(CS121_1_E,fastbus1.Q11111.data[57],DATA12);
SIGNAL(CS121_1_T,fastbus1.T81800.data[57],DATA12);
SIGNAL(CS122_1_E,fastbus1.Q11111.data[59],DATA12);
SIGNAL(CS122_1_T,fastbus1.T81800.data[59],DATA12);
SIGNAL(CS123_1_E,fastbus1.Q11111.data[61],DATA12);
SIGNAL(CS123_1_T,fastbus1.T81800.data[61],DATA12);
SIGNAL(CS124_1_E,fastbus1.Q47342.data[40],DATA12);
SIGNAL(CS124_1_T,fastbus1.T87044.data[8],DATA12);
SIGNAL(CS125_1_E,fastbus1.Q47342.data[42],DATA12);
SIGNAL(CS125_1_T,fastbus1.T87044.data[10],DATA12);
SIGNAL(CS126_1_E,fastbus1.Q47342.data[44],DATA12);
SIGNAL(CS126_1_T,fastbus1.T87044.data[12],DATA12);
SIGNAL(CS127_1_E,fastbus1.Q47342.data[46],DATA12);
SIGNAL(CS127_1_T,fastbus1.T87044.data[14],DATA12);
SIGNAL(CS128_1_E,fastbus1.Q47342.data[33],DATA12);
SIGNAL(CS128_1_T,fastbus1.T87044.data[1],DATA12);
SIGNAL(CS129_1_E,fastbus1.Q47342.data[35],DATA12);
SIGNAL(CS129_1_T,fastbus1.T87044.data[3],DATA12);
SIGNAL(CS130_1_E,fastbus1.Q11111.data[63],DATA12);
SIGNAL(CS130_1_T,fastbus1.T81800.data[63],DATA12);
SIGNAL(CS131_1_E,fastbus1.Q11111.data[64],DATA12);
SIGNAL(CS131_1_T,fastbus1.T87024.data[0],DATA12);
SIGNAL(CS132_1_E,fastbus1.Q11111.data[66],DATA12);
SIGNAL(CS132_1_T,fastbus1.T87024.data[2],DATA12);
SIGNAL(CS133_1_E,fastbus1.Q11111.data[68],DATA12);
SIGNAL(CS133_1_T,fastbus1.T87024.data[4],DATA12);
SIGNAL(CS134_1_E,fastbus1.Q11111.data[70],DATA12);
SIGNAL(CS134_1_T,fastbus1.T87024.data[6],DATA12);
SIGNAL(CS135_1_E,fastbus1.Q11111.data[72],DATA12);
SIGNAL(CS135_1_T,fastbus1.T87024.data[8],DATA12);
SIGNAL(CS136_1_E,fastbus1.Q47342.data[37],DATA12);
SIGNAL(CS136_1_T,fastbus1.T87044.data[5],DATA12);
SIGNAL(CS137_1_E,fastbus1.Q47342.data[39],DATA12);
SIGNAL(CS137_1_T,fastbus1.T87044.data[7],DATA12);
SIGNAL(CS138_1_E,fastbus1.Q47342.data[41],DATA12);
SIGNAL(CS138_1_T,fastbus1.T87044.data[9],DATA12);
SIGNAL(CS139_1_E,fastbus1.Q47342.data[43],DATA12);
SIGNAL(CS139_1_T,fastbus1.T87044.data[11],DATA12);
SIGNAL(CS140_1_E,fastbus1.Q47342.data[45],DATA12);
SIGNAL(CS140_1_T,fastbus1.T87044.data[13],DATA12);
SIGNAL(CS141_1_E,fastbus1.Q47342.data[47],DATA12);
SIGNAL(CS141_1_T,fastbus1.T87044.data[15],DATA12);
SIGNAL(CS142_1_E,fastbus1.Q11111.data[74],DATA12);
SIGNAL(CS142_1_T,fastbus1.T87024.data[10],DATA12);
SIGNAL(CS143_1_E,fastbus1.Q11111.data[76],DATA12);
SIGNAL(CS143_1_T,fastbus1.T87024.data[12],DATA12);
SIGNAL(CS144_1_E,fastbus1.Q11111.data[78],DATA12);
SIGNAL(CS144_1_T,fastbus1.T87024.data[14],DATA12);
SIGNAL(CS145_1_E,fastbus1.Q47342.data[48],DATA12);
SIGNAL(CS145_1_T,fastbus1.T87024.data[32],DATA12);
SIGNAL(CS146_1_E,fastbus1.Q47342.data[50],DATA12);
SIGNAL(CS146_1_T,fastbus1.T87024.data[34],DATA12);
SIGNAL(CS147_1_E,fastbus1.Q47342.data[52],DATA12);
SIGNAL(CS147_1_T,fastbus1.T87024.data[36],DATA12);
SIGNAL(CS148_1_E,fastbus1.Q47342.data[54],DATA12);
SIGNAL(CS148_1_T,fastbus1.T87024.data[38],DATA12);
SIGNAL(CS149_1_E,fastbus1.Q47342.data[56],DATA12);
SIGNAL(CS149_1_T,fastbus1.T87024.data[40],DATA12);
SIGNAL(CS150_1_E,fastbus1.Q47342.data[58],DATA12);
SIGNAL(CS150_1_T,fastbus1.T87024.data[42],DATA12);
SIGNAL(CS151_1_E,fastbus1.Q47342.data[49],DATA12);
SIGNAL(CS151_1_T,fastbus1.T87024.data[33],DATA12);
SIGNAL(CS152_1_E,fastbus1.Q47342.data[51],DATA12);
SIGNAL(CS152_1_T,fastbus1.T87024.data[35],DATA12);
SIGNAL(CS153_1_E,fastbus1.Q47342.data[53],DATA12);
SIGNAL(CS153_1_T,fastbus1.T87024.data[37],DATA12);
SIGNAL(CS154_1_E,fastbus1.Q47342.data[55],DATA12);
SIGNAL(CS154_1_T,fastbus1.T87024.data[39],DATA12);
SIGNAL(CS155_1_E,fastbus1.Q47342.data[57],DATA12);
SIGNAL(CS155_1_T,fastbus1.T87024.data[41],DATA12);
SIGNAL( ZERO_SUPPRESS:CS1_1);
SIGNAL( ZERO_SUPPRESS:CV1_1);
SIGNAL( ZERO_SUPPRESS:FGR1_1);
SIGNAL( ZERO_SUPPRESS:GFI1_1);
SIGNAL( ZERO_SUPPRESS:N1_1);
SIGNAL( ZERO_SUPPRESS:NTF1);
SIGNAL( ZERO_SUPPRESS:TFW1);
SIGNAL( ZERO_SUPPRESS:V1_1);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: CAMAC_LECROY_4434
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_LECROY_4434
class CAMAC_LECROY_4434
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_LECROY_4434
class PACKER_CAMAC_LECROY_4434
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA24,DATA24,32> data;
  // list(0<=index<channels)

    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_LECROY_4434);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_src_t>
void CAMAC_LECROY_4434::__unpack(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 24; // 0..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 value : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(18,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(16,ch_data.unnamed_24_31,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(17,index);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_4434::__unpack,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_src_t>
bool CAMAC_LECROY_4434::__match(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 24; // 0..23
        uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_24_31 : 8; // 24..31
        uint32 value : 24; // 0..23
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(18,uint32 ,ch_data,ch_data.u32);
    MATCH_BITS_EQUAL(16,ch_data.unnamed_24_31,0);
    return true;
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_LECROY_4434::__match,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_LECROY_4434.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_LECROY_4434(channels)
template<typename __data_dest_t>
void PACKER_CAMAC_LECROY_4434::__packer(__data_dest_t &__buffer,uint32 channels)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_23: value;
      // 24_31: 0;
      // ENCODE(data[index],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_LECROY_4434::__packer,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_PHILLIPS_7164
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_PHILLIPS_7164
class CAMAC_PHILLIPS_7164
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_PHILLIPS_7164
class PACKER_CAMAC_PHILLIPS_7164
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12,DATA12,16> data;
  // list(0<=index<channels)

    // if(mark_channel_no)

    // else

      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels,uint32 mark_channel_no);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_PHILLIPS_7164);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_src_t>
void CAMAC_PHILLIPS_7164::__unpack(__data_src_t &__buffer,uint32 channels
                                                         ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 4; // 12..15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 channel : 4; // 12..15
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(34,uint16 ,ch_data,ch_data.u16);
      CHECK_BITS_EQUAL(32,ch_data.channel,index);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(33,index);
        __item.value = ch_data.value;
      }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_15 : 4;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 dummy_12_15 : 4;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(42,uint16 ,ch_data,ch_data.u16);
      CHECK_UNNAMED_BITS_ZERO(42,ch_data.u16,0xf000);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(41,index);
        __item.value = ch_data.value;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_PHILLIPS_7164::__unpack,uint32 channels
                                                              ,uint32 mark_channel_no);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_src_t>
bool CAMAC_PHILLIPS_7164::__match(__data_src_t &__buffer,uint32 channels
                                                        ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 4; // 12..15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 channel : 4; // 12..15
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(34,uint16 ,ch_data,ch_data.u16);
      MATCH_BITS_EQUAL(32,ch_data.channel,index);
      return true;
      return false;
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_15 : 4;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 dummy_12_15 : 4;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(42,uint16 ,ch_data,ch_data.u16);
      MATCH_UNNAMED_BITS_ZERO(42,ch_data.u16,0xf000);
      return true;
      return false;
    }
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_PHILLIPS_7164::__match,uint32 channels
                                                             ,uint32 mark_channel_no);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_PHILLIPS_7164.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_PHILLIPS_7164(channels,mark_channel_no)
template<typename __data_dest_t>
void PACKER_CAMAC_PHILLIPS_7164::__packer(__data_dest_t &__buffer,uint32 channels
                                                                 ,uint32 mark_channel_no)
{
  // MEMBER(DATA12 data[16] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_15: channel = CHECK(index);
        // ENCODE(data[index],(value=value));
      // }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // ENCODE(data[index],(value=value));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_PHILLIPS_7164::__packer,uint32 channels
                                                              ,uint32 mark_channel_no);

/** END_PACKER ********************************************************/

//
// Generating code for: CAMAC_SILENA_4418
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
#if !PACKER_CODE
# define DECLARED_UNPACK_CAMAC_SILENA_4418
class CAMAC_SILENA_4418
#else//PACKER_CODE
# define DECLARED_PACKER_CAMAC_SILENA_4418
class PACKER_CAMAC_SILENA_4418
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,8> data;
  // list(0<=index<channels)

    // if(mark_channel_no)

    // else

      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels,uint32 mark_channel_no);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(CAMAC_SILENA_4418);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_src_t>
void CAMAC_SILENA_4418::__unpack(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 3; // 12..14
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 channel : 3; // 12..14
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(60,uint16 ,ch_data,ch_data.u16);
      CHECK_BITS_EQUAL(57,ch_data.channel,index);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(59,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_14 : 3;
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 dummy_12_14 : 3;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(69,uint16 ,ch_data,ch_data.u16);
      CHECK_UNNAMED_BITS_ZERO(69,ch_data.u16,0x7000);
      {
        typedef __typeof__(*(&(data))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = data.insert_index(68,index);
        __item.value = ch_data.value;
        __item.overflow = ch_data.overflow;
      }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_SILENA_4418::__unpack,uint32 channels
                                                            ,uint32 mark_channel_no);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_src_t>
bool CAMAC_SILENA_4418::__match(__data_src_t &__buffer,uint32 channels,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 channel : 3; // 12..14
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 channel : 3; // 12..14
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(60,uint16 ,ch_data,ch_data.u16);
      MATCH_BITS_EQUAL(57,ch_data.channel,index);
      return true;
      return false;
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint16 value : 12; // 0..11
          uint16 dummy_12_14 : 3;
          uint16 overflow : 1; // 15
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint16 overflow : 1; // 15
          uint16 dummy_12_14 : 3;
          uint16 value : 12; // 0..11
#endif
        };
        uint16  u16;
      } ch_data;
      READ_FROM_BUFFER_FULL(69,uint16 ,ch_data,ch_data.u16);
      MATCH_UNNAMED_BITS_ZERO(69,ch_data.u16,0x7000);
      return true;
      return false;
    }
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,CAMAC_SILENA_4418::__match,uint32 channels
                                                           ,uint32 mark_channel_no);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for CAMAC_SILENA_4418.
 *
 * Do not edit - automatically generated.
 */

// CAMAC_SILENA_4418(channels,mark_channel_no)
template<typename __data_dest_t>
void PACKER_CAMAC_SILENA_4418::__packer(__data_dest_t &__buffer,uint32 channels
                                                               ,uint32 mark_channel_no)
{
  // MEMBER(DATA12_OVERFLOW data[8] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // if(mark_channel_no)

    // else

    if (mark_channel_no)
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        // 12_14: channel = CHECK(index);
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
    }

    else
    {
      // UINT16 ch_data NOENCODE
      // {
        //  0_11: value;
        //    15: overflow;
        // ENCODE(data[index],(value=value,overflow=overflow));
      // }
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,CAMAC_SILENA_4418::__packer,uint32 channels
                                                            ,uint32 mark_channel_no);

/** END_PACKER ********************************************************/

//
// Generating code for: FASTBUS_LECROY_1875
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_FASTBUS_LECROY_1875
class FASTBUS_LECROY_1875
#else//PACKER_CODE
# define DECLARED_PACKER_FASTBUS_LECROY_1875
class PACKER_FASTBUS_LECROY_1875
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_RANGE,DATA12_RANGE,64> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FASTBUS_LECROY_1875);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_src_t>
void FASTBUS_LECROY_1875::__unpack(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 6; // 16..21
      uint32 dummy_22 : 1;
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 dummy_22 : 1;
      uint32 channel : 6; // 16..21
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(85,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(80,ch_data.channel,(channels - 1));
  CHECK_BITS_EQUAL(82,ch_data.n,0);
  CHECK_BITS_EQUAL(83,ch_data.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(85,ch_data.u32,0x0040f000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(84,ch_data.channel);
    __item.value = ch_data.value;
    __item.range = ch_data.range;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1875::__unpack,uint32 geom
                                                              ,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_src_t>
bool FASTBUS_LECROY_1875::__match(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 6; // 16..21
      uint32 dummy_22 : 1;
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 dummy_22 : 1;
      uint32 channel : 6; // 16..21
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(85,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(80,ch_data.channel,(channels - 1));
  MATCH_BITS_EQUAL(82,ch_data.n,0);
  MATCH_BITS_EQUAL(83,ch_data.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(85,ch_data.u32,0x0040f000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FASTBUS_LECROY_1875::__match,uint32 geom
                                                             ,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FASTBUS_LECROY_1875.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1875(geom,channels)
template<typename __data_dest_t>
void PACKER_FASTBUS_LECROY_1875::__packer(__data_dest_t &__buffer,uint32 geom
                                                                 ,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[64] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_21: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1875::__packer,uint32 geom
                                                              ,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: FASTBUS_LECROY_1885
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_FASTBUS_LECROY_1885
class FASTBUS_LECROY_1885
#else//PACKER_CODE
# define DECLARED_PACKER_FASTBUS_LECROY_1885
class PACKER_FASTBUS_LECROY_1885
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_RANGE,DATA12_RANGE,96> data;
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FASTBUS_LECROY_1885);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_src_t>
void FASTBUS_LECROY_1885::__unpack(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 7; // 16..22
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 channel : 7; // 16..22
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(99,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_RANGE_MAX(94,ch_data.channel,(channels - 1));
  CHECK_BITS_EQUAL(96,ch_data.n,0);
  CHECK_BITS_EQUAL(97,ch_data.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(99,ch_data.u32,0x0000f000);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(98,ch_data.channel);
    __item.value = ch_data.value;
    __item.range = ch_data.range;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1885::__unpack,uint32 geom
                                                              ,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_src_t>
bool FASTBUS_LECROY_1885::__match(__data_src_t &__buffer,uint32 geom,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 12; // 0..11
      uint32 dummy_12_15 : 4;
      uint32 channel : 7; // 16..22
      uint32 range : 1; // 23
      uint32 n : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 n : 3; // 24..26
      uint32 range : 1; // 23
      uint32 channel : 7; // 16..22
      uint32 dummy_12_15 : 4;
      uint32 value : 12; // 0..11
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(99,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_RANGE_MAX(94,ch_data.channel,(channels - 1));
  MATCH_BITS_EQUAL(96,ch_data.n,0);
  MATCH_BITS_EQUAL(97,ch_data.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(99,ch_data.u32,0x0000f000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FASTBUS_LECROY_1885::__match,uint32 geom
                                                             ,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FASTBUS_LECROY_1885.
 *
 * Do not edit - automatically generated.
 */

// FASTBUS_LECROY_1885(geom,channels)
template<typename __data_dest_t>
void PACKER_FASTBUS_LECROY_1885::__packer(__data_dest_t &__buffer,uint32 geom
                                                                 ,uint32 channels)
{
  // MEMBER(DATA12_RANGE data[96] ZERO_SUPPRESS);
  // UINT32 ch_data NOENCODE
  // {
    //  0_11: value;
    // 16_22: channel = RANGE(0,(channels - 1));
    //    23: range;
    // 24_26: n = CHECK(0);
    // 27_31: geom = MATCH(geom);
    // ENCODE(data[channel],(value=value,range=range));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FASTBUS_LECROY_1885::__packer,uint32 geom
                                                              ,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: NTP64_TIME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
#if !PACKER_CODE
# define DECLARED_UNPACK_NTP64_TIME
class NTP64_TIME
#else//PACKER_CODE
# define DECLARED_PACKER_NTP64_TIME
class PACKER_NTP64_TIME
#endif//PACKER_CODE

{
public:
  // UINT32 sec;
  uint32  sec;
  // UINT32 frac;
  uint32  frac;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(NTP64_TIME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
template<typename __data_src_t>
void NTP64_TIME::__unpack(__data_src_t &__buffer)
{
  // UINT32 sec;
  READ_FROM_BUFFER(104,uint32 ,sec);
  // UINT32 frac;
  READ_FROM_BUFFER(105,uint32 ,frac);
}
FORCE_IMPL_DATA_SRC_FCN(void,NTP64_TIME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
template<typename __data_src_t>
bool NTP64_TIME::__match(__data_src_t &__buffer)
{
  // UINT32 sec;
  uint32  __sec;
  READ_FROM_BUFFER(104,uint32 ,__sec);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,NTP64_TIME::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for NTP64_TIME.
 *
 * Do not edit - automatically generated.
 */

// NTP64_TIME()
template<typename __data_dest_t>
void PACKER_NTP64_TIME::__packer(__data_dest_t &__buffer)
{
  // UINT32 sec;
  // UINT32 frac;
}
FORCE_IMPL_DATA_SRC_FCN(void,NTP64_TIME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: NTP_MESSAGE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_NTP_MESSAGE
class NTP_MESSAGE
#else//PACKER_CODE
# define DECLARED_PACKER_NTP_MESSAGE
class PACKER_NTP_MESSAGE
#endif//PACKER_CODE

{
public:
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 16; // 0..15
      uint32 quick_burst : 1; // 16
      uint32 dummy_17_23 : 7;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_17_23 : 7;
      uint32 quick_burst : 1; // 16
      uint32 word_count : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // MARK_COUNT(start);
  // UINT32 server_id;
  uint32  server_id;
  // UINT32 sspp
  // {
    //  0_07: precision;
    //  8_15: poll;
    // 16_19: stratum;
    // 24_26: mode;
    // 27_29: version = CHECK(3);
    // 30_31: leap;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 precision : 8; // 0..7
      uint32 poll : 8; // 8..15
      uint32 stratum : 4; // 16..19
      uint32 dummy_20_23 : 4;
      uint32 mode : 3; // 24..26
      uint32 version : 3; // 27..29
      uint32 leap : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 leap : 2; // 30..31
      uint32 version : 3; // 27..29
      uint32 mode : 3; // 24..26
      uint32 dummy_20_23 : 4;
      uint32 stratum : 4; // 16..19
      uint32 poll : 8; // 8..15
      uint32 precision : 8; // 0..7
#endif
    };
    uint32  u32;
  } sspp;
  // UINT32 root_dly
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 frac : 16; // 0..15
      uint32 sec : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sec : 16; // 16..31
      uint32 frac : 16; // 0..15
#endif
    };
    uint32  u32;
  } root_dly;
  // UINT32 root_disp
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 frac : 16; // 0..15
      uint32 sec : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sec : 16; // 16..31
      uint32 frac : 16; // 0..15
#endif
    };
    uint32  u32;
  } root_disp;
  // UINT32 refid;
  uint32  refid;
  // reftime = NTP64_TIME();
  // origtime = NTP64_TIME();
  // rectime = NTP64_TIME();
  // tmittime = NTP64_TIME();
  // rxtime = NTP64_TIME();
  // if(header.quick_burst)

    // orig2time = NTP64_TIME();
    // rec2time = NTP64_TIME();
    // tmit2time = NTP64_TIME();
    // rx2time = NTP64_TIME();
    SINGLE(NTP64_TIME,orig2time);
    SINGLE(NTP64_TIME,tmit2time);
    SINGLE(NTP64_TIME,rec2time);
    SINGLE(NTP64_TIME,rx2time);
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_count,start,end,0,4)
  SINGLE(NTP64_TIME,reftime);
  SINGLE(NTP64_TIME,origtime);
  SINGLE(NTP64_TIME,rectime);
  SINGLE(NTP64_TIME,tmittime);
  SINGLE(NTP64_TIME,rxtime);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(NTP_MESSAGE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
template<typename __data_src_t>
void NTP_MESSAGE::__unpack(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(115,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(114,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(115,header.u32,0x00fe0000);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 server_id;
  READ_FROM_BUFFER(117,uint32 ,server_id);
  // UINT32 sspp
  // {
    //  0_07: precision;
    //  8_15: poll;
    // 16_19: stratum;
    // 24_26: mode;
    // 27_29: version = CHECK(3);
    // 30_31: leap;
  // }
  READ_FROM_BUFFER_FULL(126,uint32 ,sspp,sspp.u32);
  CHECK_BITS_EQUAL(124,sspp.version,3);
  CHECK_UNNAMED_BITS_ZERO(126,sspp.u32,0x00f00000);
  // UINT32 root_dly
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  READ_FROM_BUFFER_FULL(131,uint32 ,root_dly,root_dly.u32);
  // UINT32 root_disp
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  READ_FROM_BUFFER_FULL(136,uint32 ,root_disp,root_disp.u32);
  // UINT32 refid;
  READ_FROM_BUFFER(137,uint32 ,refid);
  // reftime = NTP64_TIME();
  UNPACK_DECL(138,NTP64_TIME,reftime);
  // origtime = NTP64_TIME();
  UNPACK_DECL(139,NTP64_TIME,origtime);
  // rectime = NTP64_TIME();
  UNPACK_DECL(140,NTP64_TIME,rectime);
  // tmittime = NTP64_TIME();
  UNPACK_DECL(141,NTP64_TIME,tmittime);
  // rxtime = NTP64_TIME();
  UNPACK_DECL(142,NTP64_TIME,rxtime);
  // if(header.quick_burst)

  if (header.quick_burst)
  {
    // orig2time = NTP64_TIME();
    UNPACK_DECL(145,NTP64_TIME,orig2time);
    // rec2time = NTP64_TIME();
    UNPACK_DECL(146,NTP64_TIME,rec2time);
    // tmit2time = NTP64_TIME();
    UNPACK_DECL(147,NTP64_TIME,tmit2time);
    // rx2time = NTP64_TIME();
    UNPACK_DECL(148,NTP64_TIME,rx2time);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_count,start,end,0,4)
  CHECK_WORD_COUNT(151,header.word_count,start,end,0,4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,NTP_MESSAGE::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
template<typename __data_src_t>
bool NTP_MESSAGE::__match(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 16; // 0..15
      uint32 quick_burst : 1; // 16
      uint32 dummy_17_23 : 7;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_17_23 : 7;
      uint32 quick_burst : 1; // 16
      uint32 word_count : 16; // 0..15
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(115,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(114,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(115,__header.u32,0x00fe0000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,NTP_MESSAGE::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for NTP_MESSAGE.
 *
 * Do not edit - automatically generated.
 */

// NTP_MESSAGE(id)
template<typename __data_dest_t>
void PACKER_NTP_MESSAGE::__packer(__data_dest_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_15: word_count;
    //    16: quick_burst;
    // 24_31: id = MATCH(id);
  // }
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 server_id;
  // UINT32 sspp
  // {
    //  0_07: precision;
    //  8_15: poll;
    // 16_19: stratum;
    // 24_26: mode;
    // 27_29: version = CHECK(3);
    // 30_31: leap;
  // }
  // UINT32 root_dly
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  // UINT32 root_disp
  // {
    //  0_15: frac;
    // 16_31: sec;
  // }
  // UINT32 refid;
  // reftime = NTP64_TIME();
  PACK_DECL(138,NTP64_TIME,reftime);
  // origtime = NTP64_TIME();
  PACK_DECL(139,NTP64_TIME,origtime);
  // rectime = NTP64_TIME();
  PACK_DECL(140,NTP64_TIME,rectime);
  // tmittime = NTP64_TIME();
  PACK_DECL(141,NTP64_TIME,tmittime);
  // rxtime = NTP64_TIME();
  PACK_DECL(142,NTP64_TIME,rxtime);
  // if(header.quick_burst)

  if (header.quick_burst)
  {
    // orig2time = NTP64_TIME();
    PACK_DECL(145,NTP64_TIME,orig2time);
    // rec2time = NTP64_TIME();
    PACK_DECL(146,NTP64_TIME,rec2time);
    // tmit2time = NTP64_TIME();
    PACK_DECL(147,NTP64_TIME,tmit2time);
    // rx2time = NTP64_TIME();
    PACK_DECL(148,NTP64_TIME,rx2time);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_count,start,end,0,4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,NTP_MESSAGE::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: RANDOM_TCAL
//
//
// Generating code for: RANDOM_TCAL_TSTAMP_CLOCK
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
#if !PACKER_CODE
# define DECLARED_UNPACK_RANDOM_TCAL_TSTAMP_CLOCK
class RANDOM_TCAL_TSTAMP_CLOCK
#else//PACKER_CODE
# define DECLARED_PACKER_RANDOM_TCAL_TSTAMP_CLOCK
class PACKER_RANDOM_TCAL_TSTAMP_CLOCK
#endif//PACKER_CODE

{
public:
  // UINT32 soft_latches;
  uint32  soft_latches;
  // UINT32 hard_latches;
  uint32  hard_latches;
  // UINT32 clock_ticks;
  uint32  clock_ticks;
  // before = NTP64_TIME();
  // after = NTP64_TIME();
  SINGLE(NTP64_TIME,before);
  SINGLE(NTP64_TIME,after);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(RANDOM_TCAL_TSTAMP_CLOCK);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
template<typename __data_src_t>
void RANDOM_TCAL_TSTAMP_CLOCK::__unpack(__data_src_t &__buffer)
{
  // UINT32 soft_latches;
  READ_FROM_BUFFER(180,uint32 ,soft_latches);
  // UINT32 hard_latches;
  READ_FROM_BUFFER(181,uint32 ,hard_latches);
  // UINT32 clock_ticks;
  READ_FROM_BUFFER(182,uint32 ,clock_ticks);
  // before = NTP64_TIME();
  UNPACK_DECL(183,NTP64_TIME,before);
  // after = NTP64_TIME();
  UNPACK_DECL(184,NTP64_TIME,after);
}
FORCE_IMPL_DATA_SRC_FCN(void,RANDOM_TCAL_TSTAMP_CLOCK::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
template<typename __data_src_t>
bool RANDOM_TCAL_TSTAMP_CLOCK::__match(__data_src_t &__buffer)
{
  // UINT32 soft_latches;
  uint32  __soft_latches;
  READ_FROM_BUFFER(180,uint32 ,__soft_latches);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,RANDOM_TCAL_TSTAMP_CLOCK::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for RANDOM_TCAL_TSTAMP_CLOCK.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL_TSTAMP_CLOCK()
template<typename __data_dest_t>
void PACKER_RANDOM_TCAL_TSTAMP_CLOCK::__packer(__data_dest_t &__buffer)
{
  // UINT32 soft_latches;
  // UINT32 hard_latches;
  // UINT32 clock_ticks;
  // before = NTP64_TIME();
  PACK_DECL(183,NTP64_TIME,before);
  // after = NTP64_TIME();
  PACK_DECL(184,NTP64_TIME,after);
}
FORCE_IMPL_DATA_SRC_FCN(void,RANDOM_TCAL_TSTAMP_CLOCK::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_RANDOM_TCAL
class RANDOM_TCAL
#else//PACKER_CODE
# define DECLARED_PACKER_RANDOM_TCAL
class PACKER_RANDOM_TCAL
#endif//PACKER_CODE

{
public:
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 8; // 0..7
      uint32 pulses : 4; // 8..11
      uint32 clock_bits : 6; // 12..17
      uint32 has_tstamp1 : 1; // 18
      uint32 has_tstamp2 : 1; // 19
      uint32 dummy_20_23 : 4;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_20_23 : 4;
      uint32 has_tstamp2 : 1; // 19
      uint32 has_tstamp1 : 1; // 18
      uint32 clock_bits : 6; // 12..17
      uint32 pulses : 4; // 8..11
      uint32 word_count : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  // MARK_COUNT(start);
  // if(header.has_tstamp1)

    // tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
    SINGLE(RANDOM_TCAL_TSTAMP_CLOCK,tstamp1);
  // if(header.has_tstamp2)

    // tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
    SINGLE(RANDOM_TCAL_TSTAMP_CLOCK,tstamp2);
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_count,start,end,0,4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(RANDOM_TCAL);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
template<typename __data_src_t>
void RANDOM_TCAL::__unpack(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(164,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(163,header.id,id);
  CHECK_UNNAMED_BITS_ZERO(164,header.u32,0x00f00000);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // if(header.has_tstamp1)

  if (header.has_tstamp1)
  {
    // tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
    UNPACK_DECL(168,RANDOM_TCAL_TSTAMP_CLOCK,tstamp1);
  }
  // if(header.has_tstamp2)

  if (header.has_tstamp2)
  {
    // tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
    UNPACK_DECL(172,RANDOM_TCAL_TSTAMP_CLOCK,tstamp2);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_count,start,end,0,4)
  CHECK_WORD_COUNT(175,header.word_count,start,end,0,4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,RANDOM_TCAL::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
template<typename __data_src_t>
bool RANDOM_TCAL::__match(__data_src_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 8; // 0..7
      uint32 pulses : 4; // 8..11
      uint32 clock_bits : 6; // 12..17
      uint32 has_tstamp1 : 1; // 18
      uint32 has_tstamp2 : 1; // 19
      uint32 dummy_20_23 : 4;
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 dummy_20_23 : 4;
      uint32 has_tstamp2 : 1; // 19
      uint32 has_tstamp1 : 1; // 18
      uint32 clock_bits : 6; // 12..17
      uint32 pulses : 4; // 8..11
      uint32 word_count : 8; // 0..7
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(164,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(163,__header.id,id);
  MATCH_UNNAMED_BITS_ZERO(164,__header.u32,0x00f00000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,RANDOM_TCAL::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for RANDOM_TCAL.
 *
 * Do not edit - automatically generated.
 */

// RANDOM_TCAL(id)
template<typename __data_dest_t>
void PACKER_RANDOM_TCAL::__packer(__data_dest_t &__buffer,uint32 id)
{
  // UINT32 header
  // {
    //  0_07: word_count;
    //  8_11: pulses;
    // 12_17: clock_bits;
    //    18: has_tstamp1;
    //    19: has_tstamp2;
    // 24_31: id = MATCH(id);
  // }
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // if(header.has_tstamp1)

  if (header.has_tstamp1)
  {
    // tstamp1 = RANDOM_TCAL_TSTAMP_CLOCK();
    PACK_DECL(168,RANDOM_TCAL_TSTAMP_CLOCK,tstamp1);
  }
  // if(header.has_tstamp2)

  if (header.has_tstamp2)
  {
    // tstamp2 = RANDOM_TCAL_TSTAMP_CLOCK();
    PACK_DECL(172,RANDOM_TCAL_TSTAMP_CLOCK,tstamp2);
  }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_count,start,end,0,4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,RANDOM_TCAL::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: SOFT_SCALER32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
#if !PACKER_CODE
# define DECLARED_UNPACK_SOFT_SCALER32
class SOFT_SCALER32
#else//PACKER_CODE
# define DECLARED_PACKER_SOFT_SCALER32
class PACKER_SOFT_SCALER32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // list(0<=index<channels)

    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 channels);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 channels);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 channels);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SOFT_SCALER32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
template<typename __data_src_t>
void SOFT_SCALER32::__unpack(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(196,uint32 ,ch_data,ch_data.u32);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(195,index);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,SOFT_SCALER32::__unpack,uint32 channels);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
template<typename __data_src_t>
bool SOFT_SCALER32::__match(__data_src_t &__buffer,uint32 channels)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  for (uint32 index = 0; index < (uint32) (channels); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(196,uint32 ,ch_data,ch_data.u32);
    return true;
    return false;
  }
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,SOFT_SCALER32::__match,uint32 channels);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SOFT_SCALER32.
 *
 * Do not edit - automatically generated.
 */

// SOFT_SCALER32(channels)
template<typename __data_dest_t>
void PACKER_SOFT_SCALER32::__packer(__data_dest_t &__buffer,uint32 channels)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // list(0<=index<channels)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_31: value;
      // ENCODE(data[index],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,SOFT_SCALER32::__packer,uint32 channels);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190
//
//
// Generating code for: VME_CAEN_V1190_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SUBTDC
class VME_CAEN_V1190_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SUBTDC
class PACKER_VME_CAEN_V1190_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;
  // MARK_COUNT(tdc_end);
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1190_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id
                                                           ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._data;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  READ_FROM_BUFFER_FULL(314,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(311,header.event_id,event_id);
  CHECK_BITS_EQUAL(312,header.tdc,tdc);
  CHECK_BITS_EQUAL(313,header.unnamed_27_31,1);
  CHECK_UNNAMED_BITS_ZERO(314,header.u32,0x04000000);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_0;
  PEEK_FROM_BUFFER_FULL(323,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(319,ch_data.tdc,tdc,data_done_0);
  CHECK_JUMP_BITS_EQUAL(321,ch_data.unnamed_27_31,0,data_done_0);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(322,((ch_data.tdc << 5) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
  }
  data_done_0:;
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  if (__buffer.empty()) goto data_done_1;
  PEEK_FROM_BUFFER_FULL(329,uint32 ,error_flags,__error_flags.u32);
  CHECK_JUMP_BITS_EQUAL(327,__error_flags.tdc,tdc,data_done_1);
  CHECK_JUMP_BITS_EQUAL(328,__error_flags.unnamed_27_31,4,data_done_1);
  CHECK_JUMP_UNNAMED_BITS_ZERO(329,__error_flags.u32,0x04ff8000,data_done_1);
  error_flags.u32 = __error_flags.u32;
  __buffer.advance(sizeof(__error_flags.u32));
  data_done_1:;
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  READ_FROM_BUFFER_FULL(337,uint32 ,trailer,trailer.u32);
  CHECK_WORD_COUNT(333,trailer.word_count,tdc_start,tdc_end,4,4);
  CHECK_BITS_EQUAL(334,trailer.event_id,header.event_id);
  CHECK_BITS_EQUAL(335,trailer.tdc,tdc);
  CHECK_BITS_EQUAL(336,trailer.unnamed_27_31,3);
  CHECK_UNNAMED_BITS_ZERO(337,trailer.u32,0x04000000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SUBTDC::__unpack,uint32 tdc
                                                                ,uint32 event_id
                                                                ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1190_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(314,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(311,__header.event_id,event_id);
  MATCH_BITS_EQUAL(312,__header.tdc,tdc);
  MATCH_BITS_EQUAL(313,__header.unnamed_27_31,1);
  MATCH_UNNAMED_BITS_ZERO(314,__header.u32,0x04000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SUBTDC::__match,uint32 tdc
                                                               ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                   ,uint32 event_id
                                                                   ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SUBTDC::__packer,uint32 tdc
                                                                ,uint32 event_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190
class VME_CAEN_V1190
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190
class PACKER_VME_CAEN_V1190
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  SINGLE(VME_CAEN_V1190_SUBTDC,tdc[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_src_t>
void VME_CAEN_V1190::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(209,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(206,header.geom,geom);
  CHECK_BITS_EQUAL(208,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1190_SUBTDC tdc[0]: (s32) => (0xff000000,0x08000000)
    // optimized match 2: VME_CAEN_V1190_SUBTDC tdc[1]: (s32) => (0xff000000,0x09000000)
    // optimized match 3: VME_CAEN_V1190_SUBTDC tdc[2]: (s32) => (0xff000000,0x0a000000)
    // optimized match 4: VME_CAEN_V1190_SUBTDC tdc[3]: (s32) => (0xff000000,0x0b000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(220,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(213,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(213,VME_CAEN_V1190_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(215,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(215,VME_CAEN_V1190_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(217,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(217,VME_CAEN_V1190_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(219,spurious_match_abort_loop_0,VME_CAEN_V1190_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(219,VME_CAEN_V1190_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_0:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(225,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(224,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(235,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(229,trailer.geom,geom);
  CHECK_WORD_COUNT(230,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(234,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(235,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_src_t>
bool VME_CAEN_V1190::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(209,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(206,__header.geom,geom);
  MATCH_BITS_EQUAL(208,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1190_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1190_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1190_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1190_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  {
    PACK_DECL(213,VME_CAEN_V1190_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(215,VME_CAEN_V1190_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(217,VME_CAEN_V1190_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(219,VME_CAEN_V1190_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_SHORT
//
//
// Generating code for: VME_CAEN_V1190_SHORT_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT_SUBTDC
class VME_CAEN_V1190_SHORT_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT_SUBTDC
class PACKER_VME_CAEN_V1190_SHORT_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc
                                                                 ,uint32 event_id
                                                                 ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(291,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(287,ch_data.tdc,tdc);
  CHECK_BITS_EQUAL(289,ch_data.unnamed_27_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(290,((ch_data.tdc << 5) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC::__unpack,uint32 tdc
                                                                      ,uint32 event_id
                                                                      ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc
                                                                ,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 19; // 0..18
      uint32 channel_low : 5; // 19..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 5; // 19..23
      uint32 value : 19; // 0..18
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(291,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(287,ch_data.tdc,tdc);
  MATCH_BITS_EQUAL(289,ch_data.unnamed_27_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT_SUBTDC::__match,uint32 tdc
                                                                     ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                         ,uint32 event_id
                                                                         ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_18: value;
    // 19_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 5) | channel_low)],(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC::__packer,uint32 tdc
                                                                      ,uint32 event_id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1190_SHORT_SUBTDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
class VME_CAEN_V1190_SHORT_SUBTDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
class PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT_SUBTDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__unpack(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  READ_FROM_BUFFER_FULL(301,uint32 ,error_flags,error_flags.u32);
  CHECK_BITS_EQUAL(299,error_flags.tdc,tdc);
  CHECK_BITS_EQUAL(300,error_flags.unnamed_27_31,4);
  CHECK_UNNAMED_BITS_ZERO(301,error_flags.u32,0x04ff8000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__unpack,uint32 tdc);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__match(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  READ_FROM_BUFFER_FULL(301,uint32 ,error_flags,__error_flags.u32);
  MATCH_BITS_EQUAL(299,__error_flags.tdc,tdc);
  MATCH_BITS_EQUAL(300,__error_flags.unnamed_27_31,4);
  MATCH_UNNAMED_BITS_ZERO(301,__error_flags.u32,0x04ff8000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__match,uint32 tdc);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__packer(__data_dest_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT_SUBTDC_ERROR::__packer,uint32 tdc);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1190_SHORT
class VME_CAEN_V1190_SHORT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1190_SHORT
class PACKER_VME_CAEN_V1190_SHORT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  SINGLE(VME_CAEN_V1190_SHORT_SUBTDC,tdc[4]);
  SINGLE(VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1190_SHORT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_src_t>
void VME_CAEN_V1190_SHORT::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(247,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(244,header.geom,geom);
  CHECK_BITS_EQUAL(246,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  bitsone<4> __visited1;
  __visited1.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1190_SHORT_SUBTDC tdc[0]: (s32) => (0xfb000000,0x00000000)
    // optimized match 2: VME_CAEN_V1190_SHORT_SUBTDC tdc[1]: (s32) => (0xfb000000,0x01000000)
    // optimized match 3: VME_CAEN_V1190_SHORT_SUBTDC tdc[2]: (s32) => (0xfb000000,0x02000000)
    // optimized match 4: VME_CAEN_V1190_SHORT_SUBTDC tdc[3]: (s32) => (0xfb000000,0x03000000)
    // optimized match 5: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[0]: (s32) => (0xffff8000,0x20000000)
    // optimized match 6: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[1]: (s32) => (0xffff8000,0x21000000)
    // optimized match 7: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[2]: (s32) => (0xffff8000,0x22000000)
    // optimized match 8: VME_CAEN_V1190_SHORT_SUBTDC_ERROR err[3]: (s32) => (0xffff8000,0x23000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(262,uint32,__match_peek);
    // differ = 23000000 : 24 25 29
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003) | /* 29,29 */ ((__match_peek >> 27) & 0x00000004);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 6, 7, 8, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(251,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(251,VME_CAEN_V1190_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(253,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(253,VME_CAEN_V1190_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(255,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(255,VME_CAEN_V1190_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(257,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(257,VME_CAEN_V1190_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(258,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/0);
        UNPACK_CHECK_NO_REVISIT(258,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],__visited1,0);
        UNPACK_DECL(258,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(259,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/1);
        UNPACK_CHECK_NO_REVISIT(259,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],__visited1,1);
        UNPACK_DECL(259,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(260,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/2);
        UNPACK_CHECK_NO_REVISIT(260,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],__visited1,2);
        UNPACK_DECL(260,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(261,spurious_match_abort_loop_1,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,/*tdc*/3);
        UNPACK_CHECK_NO_REVISIT(261,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],__visited1,3);
        UNPACK_DECL(261,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
        break;
    }
  }
  spurious_match_abort_loop_1:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(267,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(266,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(277,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(271,trailer.geom,geom);
  CHECK_WORD_COUNT(272,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(276,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(277,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_src_t>
bool VME_CAEN_V1190_SHORT::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(247,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(244,__header.geom,geom);
  MATCH_BITS_EQUAL(246,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1190_SHORT::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1190_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1190_SHORT(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1190_SHORT::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1190_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1190_SHORT_SUBTDC_ERROR(tdc=3);
  {
    PACK_DECL(251,VME_CAEN_V1190_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(253,VME_CAEN_V1190_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(255,VME_CAEN_V1190_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(257,VME_CAEN_V1190_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(258,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
    PACK_DECL(259,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
    PACK_DECL(260,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
    PACK_DECL(261,VME_CAEN_V1190_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1190_SHORT::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290
//
//
// Generating code for: VME_CAEN_V1290_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SUBTDC
class VME_CAEN_V1290_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SUBTDC
class PACKER_VME_CAEN_V1290_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;
  // MARK_COUNT(tdc_end);
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_count : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 word_count : 12; // 0..11
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1290_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id
                                                           ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._data;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  READ_FROM_BUFFER_FULL(454,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(451,header.event_id,event_id);
  CHECK_BITS_EQUAL(452,header.tdc,tdc);
  CHECK_BITS_EQUAL(453,header.unnamed_27_31,1);
  CHECK_UNNAMED_BITS_ZERO(454,header.u32,0x04000000);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_2;
  PEEK_FROM_BUFFER_FULL(463,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(459,ch_data.tdc,tdc,data_done_2);
  CHECK_JUMP_BITS_EQUAL(461,ch_data.unnamed_27_31,0,data_done_2);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(462,((ch_data.tdc << 3) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
  }
  data_done_2:;
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  if (__buffer.empty()) goto data_done_3;
  PEEK_FROM_BUFFER_FULL(469,uint32 ,error_flags,__error_flags.u32);
  CHECK_JUMP_BITS_EQUAL(467,__error_flags.tdc,tdc,data_done_3);
  CHECK_JUMP_BITS_EQUAL(468,__error_flags.unnamed_27_31,4,data_done_3);
  CHECK_JUMP_UNNAMED_BITS_ZERO(469,__error_flags.u32,0x04ff8000,data_done_3);
  error_flags.u32 = __error_flags.u32;
  __buffer.advance(sizeof(__error_flags.u32));
  data_done_3:;
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
  READ_FROM_BUFFER_FULL(477,uint32 ,trailer,trailer.u32);
  CHECK_WORD_COUNT(473,trailer.word_count,tdc_start,tdc_end,4,4);
  CHECK_BITS_EQUAL(474,trailer.event_id,header.event_id);
  CHECK_BITS_EQUAL(475,trailer.tdc,tdc);
  CHECK_BITS_EQUAL(476,trailer.unnamed_27_31,3);
  CHECK_UNNAMED_BITS_ZERO(477,trailer.u32,0x04000000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SUBTDC::__unpack,uint32 tdc
                                                                ,uint32 event_id
                                                                ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1290_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bunch_id : 12; // 0..11
      uint32 event_id : 12; // 12..23
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 event_id : 12; // 12..23
      uint32 bunch_id : 12; // 0..11
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(454,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(451,__header.event_id,event_id);
  MATCH_BITS_EQUAL(452,__header.tdc,tdc);
  MATCH_BITS_EQUAL(453,__header.unnamed_27_31,1);
  MATCH_UNNAMED_BITS_ZERO(454,__header.u32,0x04000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SUBTDC::__match,uint32 tdc
                                                               ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                   ,uint32 event_id
                                                                   ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(tdc_start);
  void *__mark_tdc_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_11: bunch_id;
    // 12_23: event_id = CHECK(event_id);
    // 24_25: tdc = MATCH(tdc);
    // 27_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  // optional UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  // MARK_COUNT(tdc_end);
  void *__mark_tdc_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_11: word_count = CHECK_COUNT(tdc_start,tdc_end,4,4);
    // 12_23: event_id = CHECK(header.event_id);
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 3;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SUBTDC::__packer,uint32 tdc
                                                                ,uint32 event_id);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290
class VME_CAEN_V1290
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290
class PACKER_VME_CAEN_V1290
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  SINGLE(VME_CAEN_V1290_SUBTDC,tdc[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_src_t>
void VME_CAEN_V1290::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(349,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(346,header.geom,geom);
  CHECK_BITS_EQUAL(348,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_SUBTDC tdc[0]: (s32) => (0xff000000,0x08000000)
    // optimized match 2: VME_CAEN_V1290_SUBTDC tdc[1]: (s32) => (0xff000000,0x09000000)
    // optimized match 3: VME_CAEN_V1290_SUBTDC tdc[2]: (s32) => (0xff000000,0x0a000000)
    // optimized match 4: VME_CAEN_V1290_SUBTDC tdc[3]: (s32) => (0xff000000,0x0b000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(360,uint32,__match_peek);
    // differ = 03000000 : 24 25
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003);
    static const sint8 __match_index_array[4] = { 1, 2, 3, 4, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(353,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(353,VME_CAEN_V1290_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(355,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(355,VME_CAEN_V1290_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(357,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(357,VME_CAEN_V1290_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(359,spurious_match_abort_loop_2,VME_CAEN_V1290_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(359,VME_CAEN_V1290_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
    }
  }
  spurious_match_abort_loop_2:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(365,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(364,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(375,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(369,trailer.geom,geom);
  CHECK_WORD_COUNT(370,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(374,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(375,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_src_t>
bool VME_CAEN_V1290::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(349,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(346,__header.geom,geom);
  MATCH_BITS_EQUAL(348,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1290_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[1] = VME_CAEN_V1290_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[2] = VME_CAEN_V1290_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                   // data=data);
    // tdc[3] = VME_CAEN_V1290_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                   // data=data);
  {
    PACK_DECL(353,VME_CAEN_V1290_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(355,VME_CAEN_V1290_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(357,VME_CAEN_V1290_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(359,VME_CAEN_V1290_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_SHORT
//
//
// Generating code for: VME_CAEN_V1290_SHORT_SUBTDC
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT_SUBTDC
class VME_CAEN_V1290_SHORT_SUBTDC
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT_SUBTDC
class PACKER_VME_CAEN_V1290_SHORT_SUBTDC
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc,uint32 event_id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc,uint32 event_id,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT_SUBTDC);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT_SUBTDC::__unpack(__data_src_t &__buffer,uint32 tdc
                                                                 ,uint32 event_id
                                                                 ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(431,uint32 ,ch_data,ch_data.u32);
  CHECK_BITS_EQUAL(427,ch_data.tdc,tdc);
  CHECK_BITS_EQUAL(429,ch_data.unnamed_27_31,0);
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(430,((ch_data.tdc << 3) | ch_data.channel_low));
    __item.value = ch_data.value;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC::__unpack,uint32 tdc
                                                                      ,uint32 event_id
                                                                      ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT_SUBTDC::__match(__data_src_t &__buffer,uint32 tdc
                                                                ,uint32 event_id)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 21; // 0..20
      uint32 channel_low : 3; // 21..23
      uint32 tdc : 2; // 24..25
      uint32 trailing : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trailing : 1; // 26
      uint32 tdc : 2; // 24..25
      uint32 channel_low : 3; // 21..23
      uint32 value : 21; // 0..20
#endif
    };
    uint32  u32;
  } ch_data;
  READ_FROM_BUFFER_FULL(431,uint32 ,ch_data,ch_data.u32);
  MATCH_BITS_EQUAL(427,ch_data.tdc,tdc);
  MATCH_BITS_EQUAL(429,ch_data.unnamed_27_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT_SUBTDC::__match,uint32 tdc
                                                                     ,uint32 event_id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT_SUBTDC.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC(tdc,event_id,data)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT_SUBTDC::__packer(__data_dest_t &__buffer,uint32 tdc
                                                                         ,uint32 event_id
                                                                         ,raw_array_multi_zero_suppress<DATA24,DATA24,32,128> &data)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // UINT32 ch_data NOENCODE
  // {
    //  0_20: value;
    // 21_23: channel_low;
    // 24_25: tdc = CHECK(tdc);
    //    26: trailing;
    // 27_31: 0;
    // ENCODE(data[((tdc << 3) | channel_low)],(value=value));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC::__packer,uint32 tdc
                                                                      ,uint32 event_id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V1290_SHORT_SUBTDC_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
class VME_CAEN_V1290_SHORT_SUBTDC_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
class PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR
#endif//PACKER_CODE

{
public:
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } error_flags;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 tdc);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 tdc);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 tdc);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT_SUBTDC_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__unpack(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  READ_FROM_BUFFER_FULL(441,uint32 ,error_flags,error_flags.u32);
  CHECK_BITS_EQUAL(439,error_flags.tdc,tdc);
  CHECK_BITS_EQUAL(440,error_flags.unnamed_27_31,4);
  CHECK_UNNAMED_BITS_ZERO(441,error_flags.u32,0x04ff8000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__unpack,uint32 tdc);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__match(__data_src_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 flags : 15; // 0..14
      uint32 dummy_15_23 : 9;
      uint32 tdc : 2; // 24..25
      uint32 dummy_26 : 1;
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 dummy_26 : 1;
      uint32 tdc : 2; // 24..25
      uint32 dummy_15_23 : 9;
      uint32 flags : 15; // 0..14
#endif
    };
    uint32  u32;
  } __error_flags;
  READ_FROM_BUFFER_FULL(441,uint32 ,error_flags,__error_flags.u32);
  MATCH_BITS_EQUAL(439,__error_flags.tdc,tdc);
  MATCH_BITS_EQUAL(440,__error_flags.unnamed_27_31,4);
  MATCH_UNNAMED_BITS_ZERO(441,__error_flags.u32,0x04ff8000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__match,uint32 tdc);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT_SUBTDC_ERROR.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__packer(__data_dest_t &__buffer,uint32 tdc)
{
  // UINT32 error_flags
  // {
    //  0_14: flags;
    // 24_25: tdc = CHECK(tdc);
    // 27_31: 4;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT_SUBTDC_ERROR::__packer,uint32 tdc);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V1290_SHORT
class VME_CAEN_V1290_SHORT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V1290_SHORT
class PACKER_VME_CAEN_V1290_SHORT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  raw_array_multi_zero_suppress<DATA24,DATA24,32,128> data;
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } header;
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  SINGLE(VME_CAEN_V1290_SHORT_SUBTDC,tdc[4]);
  SINGLE(VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[4]);
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time_tag : 27; // 0..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 time_tag : 27; // 0..26
#endif
    };
    uint32  u32;
  } trigger;
  // MARK_COUNT(v1190_end);
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 word_count : 15; // 5..19
      uint32 dummy_20_23 : 4;
      uint32 tdc_error : 1; // 24
      uint32 buffer_overflow : 1; // 25
      uint32 trigger_lost : 1; // 26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 trigger_lost : 1; // 26
      uint32 buffer_overflow : 1; // 25
      uint32 tdc_error : 1; // 24
      uint32 dummy_20_23 : 4;
      uint32 word_count : 15; // 5..19
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } trailer;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V1290_SHORT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_src_t>
void VME_CAEN_V1290_SHORT::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._data;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  READ_FROM_BUFFER_FULL(387,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(384,header.geom,geom);
  CHECK_BITS_EQUAL(386,header.unnamed_27_31,8);
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  bitsone<4> __visited2;
  __visited2.clear();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_CAEN_V1290_SHORT_SUBTDC tdc[0]: (s32) => (0xfb000000,0x00000000)
    // optimized match 2: VME_CAEN_V1290_SHORT_SUBTDC tdc[1]: (s32) => (0xfb000000,0x01000000)
    // optimized match 3: VME_CAEN_V1290_SHORT_SUBTDC tdc[2]: (s32) => (0xfb000000,0x02000000)
    // optimized match 4: VME_CAEN_V1290_SHORT_SUBTDC tdc[3]: (s32) => (0xfb000000,0x03000000)
    // optimized match 5: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[0]: (s32) => (0xffff8000,0x20000000)
    // optimized match 6: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[1]: (s32) => (0xffff8000,0x21000000)
    // optimized match 7: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[2]: (s32) => (0xffff8000,0x22000000)
    // optimized match 8: VME_CAEN_V1290_SHORT_SUBTDC_ERROR err[3]: (s32) => (0xffff8000,0x23000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(402,uint32,__match_peek);
    // differ = 23000000 : 24 25 29
    uint32 __match_index = 0 | /* 24,25 */ ((__match_peek >> 24) & 0x00000003) | /* 29,29 */ ((__match_peek >> 27) & 0x00000004);
    static const sint8 __match_index_array[8] = { 1, 2, 3, 4, 5, 6, 7, 8, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(391,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/0,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(391,VME_CAEN_V1290_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(393,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/1,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(393,VME_CAEN_V1290_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(395,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/2,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(395,VME_CAEN_V1290_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(397,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC,/*tdc*/3,/*event_id*/(header.event_number & 0xfff)/*,data:member*/);
        UNPACK_DECL(397,VME_CAEN_V1290_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(398,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/0);
        UNPACK_CHECK_NO_REVISIT(398,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],__visited2,0);
        UNPACK_DECL(398,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(399,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/1);
        UNPACK_CHECK_NO_REVISIT(399,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],__visited2,1);
        UNPACK_DECL(399,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(400,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/2);
        UNPACK_CHECK_NO_REVISIT(400,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],__visited2,2);
        UNPACK_DECL(400,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(401,spurious_match_abort_loop_3,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,/*tdc*/3);
        UNPACK_CHECK_NO_REVISIT(401,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],__visited2,3);
        UNPACK_DECL(401,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
        break;
    }
  }
  spurious_match_abort_loop_3:;
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  READ_FROM_BUFFER_FULL(407,uint32 ,trigger,trigger.u32);
  CHECK_BITS_EQUAL(406,trigger.unnamed_27_31,17);
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._data;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
  READ_FROM_BUFFER_FULL(417,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(411,trailer.geom,geom);
  CHECK_WORD_COUNT(412,trailer.word_count,v1190_start,v1190_end,4,4);
  CHECK_BITS_EQUAL(416,trailer.unnamed_27_31,16);
  CHECK_UNNAMED_BITS_ZERO(417,trailer.u32,0x00f00000);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_src_t>
bool VME_CAEN_V1290_SHORT::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 geom : 5; // 0..4
      uint32 event_number : 22; // 5..26
      uint32 unnamed_27_31 : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_27_31 : 5; // 27..31
      uint32 event_number : 22; // 5..26
      uint32 geom : 5; // 0..4
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(387,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(384,__header.geom,geom);
  MATCH_BITS_EQUAL(386,__header.unnamed_27_31,8);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V1290_SHORT::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V1290_SHORT.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V1290_SHORT(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V1290_SHORT::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA24 data[32] ZERO_SUPPRESS_MULTI(128));
  // MARK_COUNT(v1190_start);
  void *__mark_v1190_start = __buffer._offset;
  // UINT32 header
  // {
    //  0_04: geom = MATCH(geom);
    //  5_26: event_number;
    // 27_31: 8;
  // }
  // select several

    // tdc[0] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=0,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[1] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=1,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[2] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=2,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // tdc[3] = VME_CAEN_V1290_SHORT_SUBTDC(tdc=3,event_id=(header.event_number & 0xfff),
                                         // data=data);
    // norevisit err[0] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=0);
    // norevisit err[1] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=1);
    // norevisit err[2] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=2);
    // norevisit err[3] = VME_CAEN_V1290_SHORT_SUBTDC_ERROR(tdc=3);
  {
    PACK_DECL(391,VME_CAEN_V1290_SHORT_SUBTDC,tdc[0],/*tdc*/0,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(393,VME_CAEN_V1290_SHORT_SUBTDC,tdc[1],/*tdc*/1,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(395,VME_CAEN_V1290_SHORT_SUBTDC,tdc[2],/*tdc*/2,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(397,VME_CAEN_V1290_SHORT_SUBTDC,tdc[3],/*tdc*/3,/*event_id*/(header.event_number & 0xfff),/*data*/data);
    PACK_DECL(398,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[0],/*tdc*/0);
    PACK_DECL(399,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[1],/*tdc*/1);
    PACK_DECL(400,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[2],/*tdc*/2);
    PACK_DECL(401,VME_CAEN_V1290_SHORT_SUBTDC_ERROR,err[3],/*tdc*/3);
  }
  // UINT32 trigger
  // {
    //  0_26: time_tag;
    // 27_31: 17;
  // }
  // MARK_COUNT(v1190_end);
  void *__mark_v1190_end = __buffer._offset;
  // UINT32 trailer
  // {
    //  0_04: geom = CHECK(geom);
    //  5_19: word_count = CHECK_COUNT(v1190_start,v1190_end,4,4);
    //    24: tdc_error;
    //    25: buffer_overflow;
    //    26: trigger_lost;
    // 27_31: 16;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V1290_SHORT::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V775
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V775
class VME_CAEN_V775
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V775
class PACKER_VME_CAEN_V775
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA12_OVERFLOW,DATA12_OVERFLOW,32> data;
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 24; // 0..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 event_number : 24; // 0..23
#endif
    };
    uint32  u32;
  } eob;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom,uint32 crate);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom,uint32 crate);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom,uint32 crate);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V775);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_src_t>
void VME_CAEN_V775::__unpack(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 dummy_0_7 : 8;
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 dummy_0_7 : 8;
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(489,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(486,header.crate,crate);
  CHECK_BITS_EQUAL(487,header.unnamed_24_26,2);
  CHECK_BITS_EQUAL(488,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(489,header.u32,0x0000c0ff);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 12; // 0..11
        uint32 overflow : 1; // 12
        uint32 underflow : 1; // 13
        uint32 valid : 1; // 14
        uint32 dummy_15 : 1;
        uint32 channel : 5; // 16..20
        uint32 dummy_21_23 : 3;
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 geom : 5; // 27..31
        uint32 unnamed_24_26 : 3; // 24..26
        uint32 dummy_21_23 : 3;
        uint32 channel : 5; // 16..20
        uint32 dummy_15 : 1;
        uint32 valid : 1; // 14
        uint32 underflow : 1; // 13
        uint32 overflow : 1; // 12
        uint32 value : 12; // 0..11
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(502,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(499,ch_data.unnamed_24_26,0);
    CHECK_BITS_EQUAL(500,ch_data.geom,geom);
    CHECK_UNNAMED_BITS_ZERO(502,ch_data.u32,0x00e08000);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(501,ch_data.channel);
      __item.value = ch_data.value;
      __item.overflow = ch_data.overflow;
    }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
  READ_FROM_BUFFER_FULL(509,uint32 ,eob,eob.u32);
  CHECK_BITS_EQUAL(507,eob.unnamed_24_26,4);
  CHECK_BITS_EQUAL(508,eob.geom,geom);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V775::__unpack,uint32 geom,uint32 crate);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_src_t>
bool VME_CAEN_V775::__match(__data_src_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 dummy_0_7 : 8;
      uint32 count : 6; // 8..13
      uint32 dummy_14_15 : 2;
      uint32 crate : 8; // 16..23
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_24_26 : 3; // 24..26
      uint32 crate : 8; // 16..23
      uint32 dummy_14_15 : 2;
      uint32 count : 6; // 8..13
      uint32 dummy_0_7 : 8;
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(489,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(486,header.crate,crate);
  MATCH_BITS_EQUAL(487,header.unnamed_24_26,2);
  MATCH_BITS_EQUAL(488,header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(489,header.u32,0x0000c0ff);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V775::__match,uint32 geom,uint32 crate);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V775.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V775(geom,crate)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V775::__packer(__data_dest_t &__buffer,uint32 geom,uint32 crate)
{
  // MEMBER(DATA12_OVERFLOW data[32] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  8_13: count;
    // 16_23: crate = MATCH(crate);
    // 24_26: 2;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_11: value;
      //    12: overflow;
      //    13: underflow;
      //    14: valid;
      // 16_20: channel;
      // 24_26: 0;
      // 27_31: geom = CHECK(geom);
      // ENCODE(data[channel],(value=value,overflow=overflow));
    // }
  }
  // UINT32 eob
  // {
    //  0_23: event_number;
    // 24_26: 4;
    // 27_31: geom = CHECK(geom);
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V775::__packer,uint32 geom,uint32 crate);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_CAEN_V830
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_CAEN_V830
class VME_CAEN_V830
#else//PACKER_CODE
# define DECLARED_PACKER_VME_CAEN_V830
class PACKER_VME_CAEN_V830
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,32> data;
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 dummy_24_25 : 2;
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 dummy_24_25 : 2;
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.count)

    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_CAEN_V830);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
void VME_CAEN_V830::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  READ_FROM_BUFFER_FULL(522,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(520,header.unnamed_26_26,1);
  CHECK_BITS_EQUAL(521,header.geom,geom);
  CHECK_UNNAMED_BITS_ZERO(522,header.u32,0x03000000);
  // list(0<=index<header.count)

  for (uint32 index = 0; index < (uint32) (header.count); ++index)
  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 26; // 0..25
        uint32 unnamed_26_26 : 1; // 26
        uint32 channel : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel : 5; // 27..31
        uint32 unnamed_26_26 : 1; // 26
        uint32 value : 26; // 0..25
#endif
      };
      uint32  u32;
    } ch_data;
    READ_FROM_BUFFER_FULL(531,uint32 ,ch_data,ch_data.u32);
    CHECK_BITS_EQUAL(528,ch_data.unnamed_26_26,0);
    {
      typedef __typeof__(*(&(data))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = data.insert_index(530,ch_data.channel);
      __item.value = ch_data.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_src_t>
bool VME_CAEN_V830::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 event_number : 16; // 0..15
      uint32 ts : 2; // 16..17
      uint32 count : 6; // 18..23
      uint32 dummy_24_25 : 2;
      uint32 unnamed_26_26 : 1; // 26
      uint32 geom : 5; // 27..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 geom : 5; // 27..31
      uint32 unnamed_26_26 : 1; // 26
      uint32 dummy_24_25 : 2;
      uint32 count : 6; // 18..23
      uint32 ts : 2; // 16..17
      uint32 event_number : 16; // 0..15
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(522,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(520,__header.unnamed_26_26,1);
  MATCH_BITS_EQUAL(521,__header.geom,geom);
  MATCH_UNNAMED_BITS_ZERO(522,__header.u32,0x03000000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_CAEN_V830::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_CAEN_V830.
 *
 * Do not edit - automatically generated.
 */

// VME_CAEN_V830(geom)
template<typename __data_dest_t>
void PACKER_VME_CAEN_V830::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA32 data[32] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_15: event_number;
    // 16_17: ts;
    // 18_23: count;
    //    26: 1;
    // 27_31: geom = MATCH(geom);
  // }
  // list(0<=index<header.count)

  {
    // UINT32 ch_data NOENCODE
    // {
      //  0_25: value;
      //    26: 0;
      // 27_31: channel;
      // ENCODE(data[channel],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_CAEN_V830::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MADC32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MADC32
class VME_MESYTEC_MADC32
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MADC32
class PACKER_VME_MESYTEC_MADC32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA14_OVERFLOW,DATA14_OVERFLOW,32> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MADC32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
void VME_MESYTEC_MADC32::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(547,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(544,header.geom,geom);
  CHECK_BITS_EQUAL(545,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(546,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 13; // 0..12
      uint32 dummy_13 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_15 : 1;
      uint32 channel : 5; // 16..20
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 channel : 5; // 16..20
      uint32 dummy_15 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_13 : 1;
      uint32 value : 13; // 0..12
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_4;
  PEEK_FROM_BUFFER_FULL(556,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(553,ch_data.unnamed_21_29,32,data_done_4);
  CHECK_JUMP_BITS_EQUAL(554,ch_data.unnamed_30_31,0,data_done_4);
  CHECK_JUMP_UNNAMED_BITS_ZERO(556,ch_data.u32,0x0000a000,data_done_4);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(555,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.outofrange;
  }
  }
  data_done_4:;
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  if (__buffer.empty()) goto data_done_5;
  PEEK_FROM_BUFFER_FULL(560,uint32 ,filler,filler.u32);
  CHECK_JUMP_BITS_EQUAL(559,filler.unnamed_0_31,0,data_done_5);
  __buffer.advance(sizeof(filler.u32));
  data_done_5:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(565,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(564,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(567,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MADC32::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(547,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(544,header.geom,geom);
  MATCH_BITS_EQUAL(545,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(546,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MADC32::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MADC32::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MDPP16
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MDPP16
class VME_MESYTEC_MDPP16
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MDPP16
class PACKER_VME_MESYTEC_MDPP16
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16_OVERFLOW,DATA16_OVERFLOW,34,100> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MDPP16);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_src_t>
void VME_MESYTEC_MDPP16::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 10; // 0..9
      uint32 adc_res : 3; // 10..12
      uint32 tdc_res : 3; // 13..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_res : 3; // 13..15
      uint32 adc_res : 3; // 10..12
      uint32 word_number : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(582,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(579,header.geom,geom);
  CHECK_BITS_EQUAL(580,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(581,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 16; // 0..15
      uint32 channel : 6; // 16..21
      uint32 overflow : 1; // 22
      uint32 pileup : 1; // 23
      uint32 unnamed_24_27 : 4; // 24..27
      uint32 unnamed_28_31 : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_28_31 : 4; // 28..31
      uint32 unnamed_24_27 : 4; // 24..27
      uint32 pileup : 1; // 23
      uint32 overflow : 1; // 22
      uint32 channel : 6; // 16..21
      uint32 value : 16; // 0..15
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_6;
  PEEK_FROM_BUFFER_FULL(592,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(589,ch_data.unnamed_24_27,0,data_done_6);
  CHECK_JUMP_BITS_EQUAL(590,ch_data.unnamed_28_31,1,data_done_6);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(591,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.overflow;
    __item.pileup = ch_data.pileup;
  }
  }
  data_done_6:;
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } fill_word;
  if (__buffer.empty()) goto data_done_7;
  PEEK_FROM_BUFFER_FULL(596,uint32 ,fill_word,fill_word.u32);
  CHECK_JUMP_BITS_EQUAL(595,fill_word.unnamed_0_31,0,data_done_7);
  __buffer.advance(sizeof(fill_word.u32));
  }
  data_done_7:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(601,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(600,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(603,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MDPP16::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MDPP16::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 10; // 0..9
      uint32 adc_res : 3; // 10..12
      uint32 tdc_res : 3; // 13..15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 tdc_res : 3; // 13..15
      uint32 adc_res : 3; // 10..12
      uint32 word_number : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(582,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(579,header.geom,geom);
  MATCH_BITS_EQUAL(580,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(581,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MDPP16::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MDPP16.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MDPP16(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MDPP16::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA16_OVERFLOW data[34] ZERO_SUPPRESS_MULTI(100));
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_09: word_number;
    // 10_12: adc_res;
    // 13_15: tdc_res;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_15: value;
    // 16_21: channel;
    //    22: overflow;
    //    23: pileup;
    // 24_27: 0;
    // 28_31: 1;
    // ENCODE(data[channel],(value=value,overflow=overflow,pileup=pileup));
  // }
  // several UINT32 fill_word NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MDPP16::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_CONVERTER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_CONVERTER
class LAND_CAMAC_CONVERTER
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_CONVERTER
class PACKER_LAND_CAMAC_CONVERTER
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT16 tpat;
  uint16  tpat;
  // UINT16 tprev;
  uint16  tprev;
  // UINT16 tnext;
  uint16  tnext;
  // UINT16 tprev2;
  uint16  tprev2;
  // if(EXTERNAL has_data)

#ifndef __PSDC__
  uint32 has_data() const;
#endif//!__PSDC__
    // tPHI7079 = CAMAC_PHILLIPS_7164(channels=16,mark_channel_no=1);
    // aPHI12160 = CAMAC_PHILLIPS_7164(channels=14,mark_channel_no=1);
    // qSIA0415 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    // qSIA0418 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    // qSIA0458 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    // tSIA0400 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    // tSIA0426 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    // tSIA0401 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    SINGLE(CAMAC_PHILLIPS_7164,tPHI7079);
    SINGLE(CAMAC_SILENA_4418,qSIA0415);
    SINGLE(CAMAC_PHILLIPS_7164,aPHI12160);
    SINGLE(CAMAC_SILENA_4418,qSIA0418);
    SINGLE(CAMAC_SILENA_4418,qSIA0458);
    SINGLE(CAMAC_SILENA_4418,tSIA0400);
    SINGLE(CAMAC_SILENA_4418,tSIA0426);
    SINGLE(CAMAC_SILENA_4418,tSIA0401);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_CONVERTER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
template<typename __data_src_t>
void LAND_CAMAC_CONVERTER::__unpack(__data_src_t &__buffer)
{
  // UINT16 tpat;
  READ_FROM_BUFFER(608,uint16 ,tpat);
  // UINT16 tprev;
  READ_FROM_BUFFER(609,uint16 ,tprev);
  // UINT16 tnext;
  READ_FROM_BUFFER(610,uint16 ,tnext);
  // UINT16 tprev2;
  READ_FROM_BUFFER(611,uint16 ,tprev2);
  // if(EXTERNAL has_data)

  if (has_data())
  {
    // tPHI7079 = CAMAC_PHILLIPS_7164(channels=16,mark_channel_no=1);
    UNPACK_DECL(614,CAMAC_PHILLIPS_7164,tPHI7079,/*channels*/16,/*mark_channel_no*/1);
    // aPHI12160 = CAMAC_PHILLIPS_7164(channels=14,mark_channel_no=1);
    UNPACK_DECL(615,CAMAC_PHILLIPS_7164,aPHI12160,/*channels*/14,/*mark_channel_no*/1);
    // qSIA0415 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    UNPACK_DECL(616,CAMAC_SILENA_4418,qSIA0415,/*channels*/8,/*mark_channel_no*/0);
    // qSIA0418 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    UNPACK_DECL(617,CAMAC_SILENA_4418,qSIA0418,/*channels*/8,/*mark_channel_no*/0);
    // qSIA0458 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    UNPACK_DECL(618,CAMAC_SILENA_4418,qSIA0458,/*channels*/8,/*mark_channel_no*/0);
    // tSIA0400 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    UNPACK_DECL(619,CAMAC_SILENA_4418,tSIA0400,/*channels*/8,/*mark_channel_no*/0);
    // tSIA0426 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    UNPACK_DECL(620,CAMAC_SILENA_4418,tSIA0426,/*channels*/8,/*mark_channel_no*/0);
    // tSIA0401 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    UNPACK_DECL(621,CAMAC_SILENA_4418,tSIA0401,/*channels*/8,/*mark_channel_no*/0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_CONVERTER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_CONVERTER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_CONVERTER)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_CONVERTER::__packer(__data_dest_t &__buffer)
{
  // UINT16 tpat;
  // UINT16 tprev;
  // UINT16 tnext;
  // UINT16 tprev2;
  // if(EXTERNAL has_data)

  if (has_data())
  {
    // tPHI7079 = CAMAC_PHILLIPS_7164(channels=16,mark_channel_no=1);
    PACK_DECL(614,CAMAC_PHILLIPS_7164,tPHI7079,/*channels*/16,/*mark_channel_no*/1);
    // aPHI12160 = CAMAC_PHILLIPS_7164(channels=14,mark_channel_no=1);
    PACK_DECL(615,CAMAC_PHILLIPS_7164,aPHI12160,/*channels*/14,/*mark_channel_no*/1);
    // qSIA0415 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    PACK_DECL(616,CAMAC_SILENA_4418,qSIA0415,/*channels*/8,/*mark_channel_no*/0);
    // qSIA0418 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    PACK_DECL(617,CAMAC_SILENA_4418,qSIA0418,/*channels*/8,/*mark_channel_no*/0);
    // qSIA0458 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    PACK_DECL(618,CAMAC_SILENA_4418,qSIA0458,/*channels*/8,/*mark_channel_no*/0);
    // tSIA0400 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    PACK_DECL(619,CAMAC_SILENA_4418,tSIA0400,/*channels*/8,/*mark_channel_no*/0);
    // tSIA0426 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    PACK_DECL(620,CAMAC_SILENA_4418,tSIA0426,/*channels*/8,/*mark_channel_no*/0);
    // tSIA0401 = CAMAC_SILENA_4418(channels=8,mark_channel_no=0);
    PACK_DECL(621,CAMAC_SILENA_4418,tSIA0401,/*channels*/8,/*mark_channel_no*/0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_CONVERTER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_SCALER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_SCALER
class LAND_CAMAC_SCALER
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_SCALER
class PACKER_LAND_CAMAC_SCALER
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // scaler0 = CAMAC_LECROY_4434(channels=32);
  // scaler1 = CAMAC_LECROY_4434(channels=32);
  // scaler2 = CAMAC_LECROY_4434(channels=32);
  // if(EXTERNAL has_timestamp)

#ifndef __PSDC__
  uint32 has_timestamp() const;
#endif//!__PSDC__
    // UINT32 timestamp;
    uint32  timestamp;
    // UINT32 endianess
    // {
      //  0_31: 0x87654321;
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_0_31 : 32; // 0..31
#endif
      };
      uint32  u32;
    } endianess;
  SINGLE(CAMAC_LECROY_4434,scaler0);
  SINGLE(CAMAC_LECROY_4434,scaler2);
  SINGLE(CAMAC_LECROY_4434,scaler1);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_SCALER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
template<typename __data_src_t>
void LAND_CAMAC_SCALER::__unpack(__data_src_t &__buffer)
{
  // scaler0 = CAMAC_LECROY_4434(channels=32);
  UNPACK_DECL(627,CAMAC_LECROY_4434,scaler0,/*channels*/32);
  // scaler1 = CAMAC_LECROY_4434(channels=32);
  UNPACK_DECL(628,CAMAC_LECROY_4434,scaler1,/*channels*/32);
  // scaler2 = CAMAC_LECROY_4434(channels=32);
  UNPACK_DECL(629,CAMAC_LECROY_4434,scaler2,/*channels*/32);
  // if(EXTERNAL has_timestamp)

  if (has_timestamp())
  {
    // UINT32 timestamp;
    READ_FROM_BUFFER(632,uint32 ,timestamp);
    // UINT32 endianess
    // {
      //  0_31: 0x87654321;
    // }
    READ_FROM_BUFFER_FULL(636,uint32 ,endianess,endianess.u32);
    CHECK_BITS_EQUAL(635,endianess.unnamed_0_31,0x87654321);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_SCALER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_SCALER.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_SCALER)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_SCALER::__packer(__data_dest_t &__buffer)
{
  // scaler0 = CAMAC_LECROY_4434(channels=32);
  PACK_DECL(627,CAMAC_LECROY_4434,scaler0,/*channels*/32);
  // scaler1 = CAMAC_LECROY_4434(channels=32);
  PACK_DECL(628,CAMAC_LECROY_4434,scaler1,/*channels*/32);
  // scaler2 = CAMAC_LECROY_4434(channels=32);
  PACK_DECL(629,CAMAC_LECROY_4434,scaler2,/*channels*/32);
  // if(EXTERNAL has_timestamp)

  if (has_timestamp())
  {
    // UINT32 timestamp;
    // UINT32 endianess
    // {
      //  0_31: 0x87654321;
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_SCALER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_START_STOP_STAMP
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_START_STOP_STAMP
class LAND_CAMAC_START_STOP_STAMP
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_START_STOP_STAMP
class PACKER_LAND_CAMAC_START_STOP_STAMP
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 timestamp;
  uint32  timestamp;
  // UINT32 endianess
  // {
    //  0_31: 0x87654321;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } endianess;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_START_STOP_STAMP);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
template<typename __data_src_t>
void LAND_CAMAC_START_STOP_STAMP::__unpack(__data_src_t &__buffer)
{
  // UINT32 timestamp;
  READ_FROM_BUFFER(642,uint32 ,timestamp);
  // UINT32 endianess
  // {
    //  0_31: 0x87654321;
  // }
  READ_FROM_BUFFER_FULL(646,uint32 ,endianess,endianess.u32);
  CHECK_BITS_EQUAL(645,endianess.unnamed_0_31,0x87654321);
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_START_STOP_STAMP::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_START_STOP_STAMP.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_START_STOP_STAMP)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_START_STOP_STAMP::__packer(__data_dest_t &__buffer)
{
  // UINT32 timestamp;
  // UINT32 endianess
  // {
    //  0_31: 0x87654321;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_START_STOP_STAMP::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_CAMAC_TCAL_INFO
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_CAMAC_TCAL_INFO
class LAND_CAMAC_TCAL_INFO
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_CAMAC_TCAL_INFO
class PACKER_LAND_CAMAC_TCAL_INFO
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 info;
  uint32  info;
  // select several

    // rtcal = RANDOM_TCAL(id=231);
    // ntp = NTP_MESSAGE(id=239);
  SINGLE(RANDOM_TCAL,rtcal);
  SINGLE(NTP_MESSAGE,ntp);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_CAMAC_TCAL_INFO);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
template<typename __data_src_t>
void LAND_CAMAC_TCAL_INFO::__unpack(__data_src_t &__buffer)
{
  // UINT32 info;
  READ_FROM_BUFFER(651,uint32 ,info);
  // select several

    // rtcal = RANDOM_TCAL(id=231);
    // ntp = NTP_MESSAGE(id=239);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: RANDOM_TCAL rtcal: (s32) => (0xfff00000,0xe7000000)
    // optimized match 2: NTP_MESSAGE ntp: (s32) => (0xfffe0000,0xef000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(656,uint32,__match_peek);
    // differ = 08000000 : 27
    uint32 __match_index = 0 | /* 27,27 */ ((__match_peek >> 27) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(654,RANDOM_TCAL,rtcal,/*id*/231);
        break;
      case 2:
        UNPACK_DECL(655,NTP_MESSAGE,ntp,/*id*/239);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_TCAL_INFO::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_CAMAC_TCAL_INFO.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_CAMAC_TCAL_INFO)
template<typename __data_dest_t>
void PACKER_LAND_CAMAC_TCAL_INFO::__packer(__data_dest_t &__buffer)
{
  // UINT32 info;
  // select several

    // rtcal = RANDOM_TCAL(id=231);
    // ntp = NTP_MESSAGE(id=239);
  {
    PACK_DECL(654,RANDOM_TCAL,rtcal,/*id*/231);
    PACK_DECL(655,NTP_MESSAGE,ntp,/*id*/239);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_CAMAC_TCAL_INFO::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_FASTBUS1
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_FASTBUS1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS1)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_FASTBUS1
class LAND_FASTBUS1
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_FASTBUS1
class PACKER_LAND_FASTBUS1
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 zero NOENCODE
  // {
    //  0_31: 0;
  // }
  // select several

    // T87044 = FASTBUS_LECROY_1875(geom=4,channels=64);
    // T87024 = FASTBUS_LECROY_1875(geom=5,channels=64);
    // T81800 = FASTBUS_LECROY_1875(geom=6,channels=64);
    // Q47342 = FASTBUS_LECROY_1885(geom=7,channels=96);
    // Q11111 = FASTBUS_LECROY_1885(geom=8,channels=96);
    // Q47264 = FASTBUS_LECROY_1885(geom=9,channels=96);
    // Q46848 = FASTBUS_LECROY_1885(geom=10,channels=96);
    // T81855 = FASTBUS_LECROY_1875(geom=12,channels=64);
    // Q17320 = FASTBUS_LECROY_1885(geom=13,channels=96);
    // Q47315 = FASTBUS_LECROY_1885(geom=14,channels=96);
    // Q15372 = FASTBUS_LECROY_1885(geom=15,channels=96);
    // Q46962 = FASTBUS_LECROY_1885(geom=16,channels=96);
    // Q15358 = FASTBUS_LECROY_1885(geom=17,channels=96);
    // Q46993 = FASTBUS_LECROY_1885(geom=18,channels=96);
    // T87047 = FASTBUS_LECROY_1875(geom=19,channels=64);
    // T48854 = FASTBUS_LECROY_1875(geom=20,channels=64);
    // T81808 = FASTBUS_LECROY_1875(geom=21,channels=64);
    // T81859 = FASTBUS_LECROY_1875(geom=22,channels=64);
    // T81795 = FASTBUS_LECROY_1875(geom=23,channels=64);
    // T81806 = FASTBUS_LECROY_1875(geom=24,channels=64);
    // T48834 = FASTBUS_LECROY_1875(geom=25,channels=64);
  SINGLE(FASTBUS_LECROY_1875,T87044);
  SINGLE(FASTBUS_LECROY_1875,T81800);
  SINGLE(FASTBUS_LECROY_1875,T87024);
  SINGLE(FASTBUS_LECROY_1885,Q47342);
  SINGLE(FASTBUS_LECROY_1885,Q11111);
  SINGLE(FASTBUS_LECROY_1885,Q47264);
  SINGLE(FASTBUS_LECROY_1885,Q46848);
  SINGLE(FASTBUS_LECROY_1875,T81855);
  SINGLE(FASTBUS_LECROY_1885,Q17320);
  SINGLE(FASTBUS_LECROY_1885,Q47315);
  SINGLE(FASTBUS_LECROY_1885,Q15372);
  SINGLE(FASTBUS_LECROY_1885,Q46962);
  SINGLE(FASTBUS_LECROY_1885,Q15358);
  SINGLE(FASTBUS_LECROY_1885,Q46993);
  SINGLE(FASTBUS_LECROY_1875,T87047);
  SINGLE(FASTBUS_LECROY_1875,T48854);
  SINGLE(FASTBUS_LECROY_1875,T81808);
  SINGLE(FASTBUS_LECROY_1875,T81859);
  SINGLE(FASTBUS_LECROY_1875,T81795);
  SINGLE(FASTBUS_LECROY_1875,T81806);
  SINGLE(FASTBUS_LECROY_1875,T48834);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_FASTBUS1);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_FASTBUS1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS1)
template<typename __data_src_t>
void LAND_FASTBUS1::__unpack(__data_src_t &__buffer)
{
  // UINT32 zero NOENCODE
  // {
    //  0_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } zero;
  READ_FROM_BUFFER_FULL(664,uint32 ,zero,zero.u32);
  CHECK_BITS_EQUAL(663,zero.unnamed_0_31,0);
  // select several

    // T87044 = FASTBUS_LECROY_1875(geom=4,channels=64);
    // T87024 = FASTBUS_LECROY_1875(geom=5,channels=64);
    // T81800 = FASTBUS_LECROY_1875(geom=6,channels=64);
    // Q47342 = FASTBUS_LECROY_1885(geom=7,channels=96);
    // Q11111 = FASTBUS_LECROY_1885(geom=8,channels=96);
    // Q47264 = FASTBUS_LECROY_1885(geom=9,channels=96);
    // Q46848 = FASTBUS_LECROY_1885(geom=10,channels=96);
    // T81855 = FASTBUS_LECROY_1875(geom=12,channels=64);
    // Q17320 = FASTBUS_LECROY_1885(geom=13,channels=96);
    // Q47315 = FASTBUS_LECROY_1885(geom=14,channels=96);
    // Q15372 = FASTBUS_LECROY_1885(geom=15,channels=96);
    // Q46962 = FASTBUS_LECROY_1885(geom=16,channels=96);
    // Q15358 = FASTBUS_LECROY_1885(geom=17,channels=96);
    // Q46993 = FASTBUS_LECROY_1885(geom=18,channels=96);
    // T87047 = FASTBUS_LECROY_1875(geom=19,channels=64);
    // T48854 = FASTBUS_LECROY_1875(geom=20,channels=64);
    // T81808 = FASTBUS_LECROY_1875(geom=21,channels=64);
    // T81859 = FASTBUS_LECROY_1875(geom=22,channels=64);
    // T81795 = FASTBUS_LECROY_1875(geom=23,channels=64);
    // T81806 = FASTBUS_LECROY_1875(geom=24,channels=64);
    // T48834 = FASTBUS_LECROY_1875(geom=25,channels=64);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FASTBUS_LECROY_1875 T87044: (s32) => (0xff40f000,0x20000000)
    // optimized match 2: FASTBUS_LECROY_1875 T87024: (s32) => (0xff40f000,0x28000000)
    // optimized match 3: FASTBUS_LECROY_1875 T81800: (s32) => (0xff40f000,0x30000000)
    // optimized match 4: FASTBUS_LECROY_1885 Q47342: (s32) => (0xff00f000,0x38000000)
    // optimized match 5: FASTBUS_LECROY_1885 Q11111: (s32) => (0xff00f000,0x40000000)
    // optimized match 6: FASTBUS_LECROY_1885 Q47264: (s32) => (0xff00f000,0x48000000)
    // optimized match 7: FASTBUS_LECROY_1885 Q46848: (s32) => (0xff00f000,0x50000000)
    // optimized match 8: FASTBUS_LECROY_1875 T81855: (s32) => (0xff40f000,0x60000000)
    // optimized match 9: FASTBUS_LECROY_1885 Q17320: (s32) => (0xff00f000,0x68000000)
    // optimized match 10: FASTBUS_LECROY_1885 Q47315: (s32) => (0xff00f000,0x70000000)
    // optimized match 11: FASTBUS_LECROY_1885 Q15372: (s32) => (0xff00f000,0x78000000)
    // optimized match 12: FASTBUS_LECROY_1885 Q46962: (s32) => (0xff00f000,0x80000000)
    // optimized match 13: FASTBUS_LECROY_1885 Q15358: (s32) => (0xff00f000,0x88000000)
    // optimized match 14: FASTBUS_LECROY_1885 Q46993: (s32) => (0xff00f000,0x90000000)
    // optimized match 15: FASTBUS_LECROY_1875 T87047: (s32) => (0xff40f000,0x98000000)
    // optimized match 16: FASTBUS_LECROY_1875 T48854: (s32) => (0xff40f000,0xa0000000)
    // optimized match 17: FASTBUS_LECROY_1875 T81808: (s32) => (0xff40f000,0xa8000000)
    // optimized match 18: FASTBUS_LECROY_1875 T81859: (s32) => (0xff40f000,0xb0000000)
    // optimized match 19: FASTBUS_LECROY_1875 T81795: (s32) => (0xff40f000,0xb8000000)
    // optimized match 20: FASTBUS_LECROY_1875 T81806: (s32) => (0xff40f000,0xc0000000)
    // optimized match 21: FASTBUS_LECROY_1875 T48834: (s32) => (0xff40f000,0xc8000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(688,uint32,__match_peek);
    // differ = f8000000 : 27 28 29 30 31
    uint32 __match_index = 0 | /* 27,31 */ ((__match_peek >> 27) & 0x0000001f);
    static const sint8 __match_index_array[32] = { 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 0, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 0, 0, 0, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(667,FASTBUS_LECROY_1875,T87044,/*geom*/4,/*channels*/64);
        break;
      case 2:
        UNPACK_DECL(668,FASTBUS_LECROY_1875,T87024,/*geom*/5,/*channels*/64);
        break;
      case 3:
        UNPACK_DECL(669,FASTBUS_LECROY_1875,T81800,/*geom*/6,/*channels*/64);
        break;
      case 4:
        UNPACK_DECL(670,FASTBUS_LECROY_1885,Q47342,/*geom*/7,/*channels*/96);
        break;
      case 5:
        UNPACK_DECL(671,FASTBUS_LECROY_1885,Q11111,/*geom*/8,/*channels*/96);
        break;
      case 6:
        UNPACK_DECL(672,FASTBUS_LECROY_1885,Q47264,/*geom*/9,/*channels*/96);
        break;
      case 7:
        UNPACK_DECL(673,FASTBUS_LECROY_1885,Q46848,/*geom*/10,/*channels*/96);
        break;
      case 8:
        UNPACK_DECL(674,FASTBUS_LECROY_1875,T81855,/*geom*/12,/*channels*/64);
        break;
      case 9:
        UNPACK_DECL(675,FASTBUS_LECROY_1885,Q17320,/*geom*/13,/*channels*/96);
        break;
      case 10:
        UNPACK_DECL(676,FASTBUS_LECROY_1885,Q47315,/*geom*/14,/*channels*/96);
        break;
      case 11:
        UNPACK_DECL(677,FASTBUS_LECROY_1885,Q15372,/*geom*/15,/*channels*/96);
        break;
      case 12:
        UNPACK_DECL(678,FASTBUS_LECROY_1885,Q46962,/*geom*/16,/*channels*/96);
        break;
      case 13:
        UNPACK_DECL(679,FASTBUS_LECROY_1885,Q15358,/*geom*/17,/*channels*/96);
        break;
      case 14:
        UNPACK_DECL(680,FASTBUS_LECROY_1885,Q46993,/*geom*/18,/*channels*/96);
        break;
      case 15:
        UNPACK_DECL(681,FASTBUS_LECROY_1875,T87047,/*geom*/19,/*channels*/64);
        break;
      case 16:
        UNPACK_DECL(682,FASTBUS_LECROY_1875,T48854,/*geom*/20,/*channels*/64);
        break;
      case 17:
        UNPACK_DECL(683,FASTBUS_LECROY_1875,T81808,/*geom*/21,/*channels*/64);
        break;
      case 18:
        UNPACK_DECL(684,FASTBUS_LECROY_1875,T81859,/*geom*/22,/*channels*/64);
        break;
      case 19:
        UNPACK_DECL(685,FASTBUS_LECROY_1875,T81795,/*geom*/23,/*channels*/64);
        break;
      case 20:
        UNPACK_DECL(686,FASTBUS_LECROY_1875,T81806,/*geom*/24,/*channels*/64);
        break;
      case 21:
        UNPACK_DECL(687,FASTBUS_LECROY_1875,T48834,/*geom*/25,/*channels*/64);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_FASTBUS1::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_FASTBUS1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS1)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_FASTBUS1.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS1)
template<typename __data_dest_t>
void PACKER_LAND_FASTBUS1::__packer(__data_dest_t &__buffer)
{
  // UINT32 zero NOENCODE
  // {
    //  0_31: 0;
  // }
  // select several

    // T87044 = FASTBUS_LECROY_1875(geom=4,channels=64);
    // T87024 = FASTBUS_LECROY_1875(geom=5,channels=64);
    // T81800 = FASTBUS_LECROY_1875(geom=6,channels=64);
    // Q47342 = FASTBUS_LECROY_1885(geom=7,channels=96);
    // Q11111 = FASTBUS_LECROY_1885(geom=8,channels=96);
    // Q47264 = FASTBUS_LECROY_1885(geom=9,channels=96);
    // Q46848 = FASTBUS_LECROY_1885(geom=10,channels=96);
    // T81855 = FASTBUS_LECROY_1875(geom=12,channels=64);
    // Q17320 = FASTBUS_LECROY_1885(geom=13,channels=96);
    // Q47315 = FASTBUS_LECROY_1885(geom=14,channels=96);
    // Q15372 = FASTBUS_LECROY_1885(geom=15,channels=96);
    // Q46962 = FASTBUS_LECROY_1885(geom=16,channels=96);
    // Q15358 = FASTBUS_LECROY_1885(geom=17,channels=96);
    // Q46993 = FASTBUS_LECROY_1885(geom=18,channels=96);
    // T87047 = FASTBUS_LECROY_1875(geom=19,channels=64);
    // T48854 = FASTBUS_LECROY_1875(geom=20,channels=64);
    // T81808 = FASTBUS_LECROY_1875(geom=21,channels=64);
    // T81859 = FASTBUS_LECROY_1875(geom=22,channels=64);
    // T81795 = FASTBUS_LECROY_1875(geom=23,channels=64);
    // T81806 = FASTBUS_LECROY_1875(geom=24,channels=64);
    // T48834 = FASTBUS_LECROY_1875(geom=25,channels=64);
  {
    PACK_DECL(667,FASTBUS_LECROY_1875,T87044,/*geom*/4,/*channels*/64);
    PACK_DECL(668,FASTBUS_LECROY_1875,T87024,/*geom*/5,/*channels*/64);
    PACK_DECL(669,FASTBUS_LECROY_1875,T81800,/*geom*/6,/*channels*/64);
    PACK_DECL(670,FASTBUS_LECROY_1885,Q47342,/*geom*/7,/*channels*/96);
    PACK_DECL(671,FASTBUS_LECROY_1885,Q11111,/*geom*/8,/*channels*/96);
    PACK_DECL(672,FASTBUS_LECROY_1885,Q47264,/*geom*/9,/*channels*/96);
    PACK_DECL(673,FASTBUS_LECROY_1885,Q46848,/*geom*/10,/*channels*/96);
    PACK_DECL(674,FASTBUS_LECROY_1875,T81855,/*geom*/12,/*channels*/64);
    PACK_DECL(675,FASTBUS_LECROY_1885,Q17320,/*geom*/13,/*channels*/96);
    PACK_DECL(676,FASTBUS_LECROY_1885,Q47315,/*geom*/14,/*channels*/96);
    PACK_DECL(677,FASTBUS_LECROY_1885,Q15372,/*geom*/15,/*channels*/96);
    PACK_DECL(678,FASTBUS_LECROY_1885,Q46962,/*geom*/16,/*channels*/96);
    PACK_DECL(679,FASTBUS_LECROY_1885,Q15358,/*geom*/17,/*channels*/96);
    PACK_DECL(680,FASTBUS_LECROY_1885,Q46993,/*geom*/18,/*channels*/96);
    PACK_DECL(681,FASTBUS_LECROY_1875,T87047,/*geom*/19,/*channels*/64);
    PACK_DECL(682,FASTBUS_LECROY_1875,T48854,/*geom*/20,/*channels*/64);
    PACK_DECL(683,FASTBUS_LECROY_1875,T81808,/*geom*/21,/*channels*/64);
    PACK_DECL(684,FASTBUS_LECROY_1875,T81859,/*geom*/22,/*channels*/64);
    PACK_DECL(685,FASTBUS_LECROY_1875,T81795,/*geom*/23,/*channels*/64);
    PACK_DECL(686,FASTBUS_LECROY_1875,T81806,/*geom*/24,/*channels*/64);
    PACK_DECL(687,FASTBUS_LECROY_1875,T48834,/*geom*/25,/*channels*/64);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_FASTBUS1::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_FASTBUS_ERROR
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_FASTBUS_ERROR.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_FASTBUS_ERROR
class LAND_FASTBUS_ERROR
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_FASTBUS_ERROR
class PACKER_LAND_FASTBUS_ERROR
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 error_code
  // {
    //     0: timeout_waiting_smi;
    //     1: illegal_block_transfer;
    //     2: fifa_address_overflow;
    //     3: fifa_register_error;
    //    16: init_error;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 timeout_waiting_smi : 1; // 0
      uint32 illegal_block_transfer : 1; // 1
      uint32 fifa_address_overflow : 1; // 2
      uint32 fifa_register_error : 1; // 3
      uint32 dummy_4_15 : 12;
      uint32 init_error : 1; // 16
      uint32 dummy_17_31 : 15;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 dummy_17_31 : 15;
      uint32 init_error : 1; // 16
      uint32 dummy_4_15 : 12;
      uint32 fifa_register_error : 1; // 3
      uint32 fifa_address_overflow : 1; // 2
      uint32 illegal_block_transfer : 1; // 1
      uint32 timeout_waiting_smi : 1; // 0
#endif
    };
    uint32  u32;
  } error_code;
  // UINT32 error_num;
  uint32  error_num;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_FASTBUS_ERROR);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_FASTBUS_ERROR.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR)
template<typename __data_src_t>
void LAND_FASTBUS_ERROR::__unpack(__data_src_t &__buffer)
{
  // UINT32 error_code
  // {
    //     0: timeout_waiting_smi;
    //     1: illegal_block_transfer;
    //     2: fifa_address_overflow;
    //     3: fifa_register_error;
    //    16: init_error;
  // }
  READ_FROM_BUFFER_FULL(700,uint32 ,error_code,error_code.u32);
  CHECK_UNNAMED_BITS_ZERO(700,error_code.u32,0xfffefff0);
  // UINT32 error_num;
  READ_FROM_BUFFER(701,uint32 ,error_num);
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_FASTBUS_ERROR::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_FASTBUS_ERROR.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_FASTBUS_ERROR.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR)
template<typename __data_dest_t>
void PACKER_LAND_FASTBUS_ERROR::__packer(__data_dest_t &__buffer)
{
  // UINT32 error_code
  // {
    //     0: timeout_waiting_smi;
    //     1: illegal_block_transfer;
    //     2: fifa_address_overflow;
    //     3: fifa_register_error;
    //    16: init_error;
  // }
  // UINT32 error_num;
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_FASTBUS_ERROR::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_FASTBUS_ERROR_NGF
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_FASTBUS_ERROR_NGF.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR_NGF)
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_FASTBUS_ERROR_NGF
class LAND_FASTBUS_ERROR_NGF
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_FASTBUS_ERROR_NGF
class PACKER_LAND_FASTBUS_ERROR_NGF
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // UINT32 magic
  // {
    //  0_31: 0x10000000;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } magic;
  // UINT32 error_code
  // {
    //     0: error;
    //     1: uninitialized;
    //     2: ss1;
    //     3: wc;
    //     4: mid;
    //     5: fifo_empty;
    //     6: fifo_not_empty;
    //     7: not_finished;
    //     8: bad_end_addr;
    //     9: word_lost;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 error : 1; // 0
      uint32 uninitialized : 1; // 1
      uint32 ss1 : 1; // 2
      uint32 wc : 1; // 3
      uint32 mid : 1; // 4
      uint32 fifo_empty : 1; // 5
      uint32 fifo_not_empty : 1; // 6
      uint32 not_finished : 1; // 7
      uint32 bad_end_addr : 1; // 8
      uint32 word_lost : 1; // 9
      uint32 dummy_10_31 : 22;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 dummy_10_31 : 22;
      uint32 word_lost : 1; // 9
      uint32 bad_end_addr : 1; // 8
      uint32 not_finished : 1; // 7
      uint32 fifo_not_empty : 1; // 6
      uint32 fifo_empty : 1; // 5
      uint32 mid : 1; // 4
      uint32 wc : 1; // 3
      uint32 ss1 : 1; // 2
      uint32 uninitialized : 1; // 1
      uint32 error : 1; // 0
#endif
    };
    uint32  u32;
  } error_code;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_FASTBUS_ERROR_NGF);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_FASTBUS_ERROR_NGF.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR_NGF)
template<typename __data_src_t>
void LAND_FASTBUS_ERROR_NGF::__unpack(__data_src_t &__buffer)
{
  // UINT32 magic
  // {
    //  0_31: 0x10000000;
  // }
  READ_FROM_BUFFER_FULL(709,uint32 ,magic,magic.u32);
  CHECK_BITS_EQUAL(708,magic.unnamed_0_31,0x10000000);
  // UINT32 error_code
  // {
    //     0: error;
    //     1: uninitialized;
    //     2: ss1;
    //     3: wc;
    //     4: mid;
    //     5: fifo_empty;
    //     6: fifo_not_empty;
    //     7: not_finished;
    //     8: bad_end_addr;
    //     9: word_lost;
  // }
  READ_FROM_BUFFER_FULL(722,uint32 ,error_code,error_code.u32);
  CHECK_UNNAMED_BITS_ZERO(722,error_code.u32,0xfffffc00);
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_FASTBUS_ERROR_NGF::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_FASTBUS_ERROR_NGF.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR_NGF)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_FASTBUS_ERROR_NGF.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(LAND_FASTBUS_ERROR_NGF)
template<typename __data_dest_t>
void PACKER_LAND_FASTBUS_ERROR_NGF::__packer(__data_dest_t &__buffer)
{
  // UINT32 magic
  // {
    //  0_31: 0x10000000;
  // }
  // UINT32 error_code
  // {
    //     0: error;
    //     1: uninitialized;
    //     2: ss1;
    //     3: wc;
    //     4: mid;
    //     5: fifo_empty;
    //     6: fifo_not_empty;
    //     7: not_finished;
    //     8: bad_end_addr;
    //     9: word_lost;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_FASTBUS_ERROR_NGF::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // fastbus_error = LAND_FASTBUS_ERROR(type=31,subtype=0xc1c);
  // fastbus1 = LAND_FASTBUS1(type=32,subtype=0xc1c);
SINGLE(LAND_CAMAC_CONVERTER,camac);
SINGLE(LAND_FASTBUS_ERROR,fastbus_error);
SINGLE(LAND_CAMAC_SCALER,camac_scalers);
SINGLE(LAND_FASTBUS1,fastbus1);
public:
#ifndef __PSDC__
  bitsone<4> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // fastbus_error = LAND_FASTBUS_ERROR(type=31,subtype=0xc1c);
  // fastbus1 = LAND_FASTBUS1(type=32,subtype=0xc1c);
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(731,__match_no,1,((VES10_1_type==34)&&(VES10_1_subtype==0xc80)),camac);
  MATCH_SUBEVENT_DECL(732,__match_no,2,((VES10_1_type==34)&&(VES10_1_subtype==0xc1c)),camac_scalers);
  MATCH_SUBEVENT_DECL(733,__match_no,3,((VES10_1_type==31)&&(VES10_1_subtype==0xc1c)),fastbus_error);
  MATCH_SUBEVENT_DECL(734,__match_no,4,((VES10_1_type==32)&&(VES10_1_subtype==0xc1c)),fastbus1);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(731,LAND_CAMAC_CONVERTER,camac,0);
      UNPACK_SUBEVENT_DECL(731,0,LAND_CAMAC_CONVERTER,camac);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(732,LAND_CAMAC_SCALER,camac_scalers,1);
      UNPACK_SUBEVENT_DECL(732,0,LAND_CAMAC_SCALER,camac_scalers);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(733,LAND_FASTBUS_ERROR,fastbus_error,2);
      UNPACK_SUBEVENT_DECL(733,0,LAND_FASTBUS_ERROR,fastbus_error);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(734,LAND_FASTBUS1,fastbus1,3);
      UNPACK_SUBEVENT_DECL(734,0,LAND_FASTBUS1,fastbus1);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // fastbus_error = LAND_FASTBUS_ERROR(type=31,subtype=0xc1c);
  // fastbus1 = LAND_FASTBUS1(type=32,subtype=0xc1c);
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // camac = LAND_CAMAC_CONVERTER(type=34,subtype=0xc80);
  // camac_scalers = LAND_CAMAC_SCALER(type=34,subtype=0xc1c);
  // fastbus_error = LAND_FASTBUS_ERROR(type=31,subtype=0xc1c);
  // fastbus1 = LAND_FASTBUS1(type=32,subtype=0xc1c);
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(731,__match_no,1,((VES10_1_type==34)&&(VES10_1_subtype==0xc80)),camac);
  MATCH_SUBEVENT_DECL(732,__match_no,2,((VES10_1_type==34)&&(VES10_1_subtype==0xc1c)),camac_scalers);
  MATCH_SUBEVENT_DECL(733,__match_no,3,((VES10_1_type==31)&&(VES10_1_subtype==0xc1c)),fastbus_error);
  MATCH_SUBEVENT_DECL(734,__match_no,4,((VES10_1_type==32)&&(VES10_1_subtype==0xc1c)),fastbus1);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(731,LAND_CAMAC_CONVERTER,camac,0);
      REVOKE_SUBEVENT_DECL(731,0,LAND_CAMAC_CONVERTER,camac);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(732,LAND_CAMAC_SCALER,camac_scalers,1);
      REVOKE_SUBEVENT_DECL(732,0,LAND_CAMAC_SCALER,camac_scalers);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(733,LAND_FASTBUS_ERROR,fastbus_error,2);
      REVOKE_SUBEVENT_DECL(733,0,LAND_FASTBUS_ERROR,fastbus_error);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(734,LAND_FASTBUS1,fastbus1,3);
      REVOKE_SUBEVENT_DECL(734,0,LAND_FASTBUS1,fastbus1);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "camac", "type=34:subtype=0xc80" },
{ "camac_scalers", "type=34:subtype=0xc1c" },
{ "fastbus_error", "type=31:subtype=0xc1c" },
{ "fastbus1", "type=32:subtype=0xc1c" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

//DUMPY: 155 0
//DUMPY: 1 1
class raw_event_CS
{
public:
  DATA12 E;
  DATA12 T;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_CS);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
//DUMPY: 155 0
//DUMPY: 1 1
  raw_array_zero_suppress<raw_event_CS,raw_event_CS,1>
  /* {
  public:
    DATA12 E;
    DATA12 T;
  } */ CS[155];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA12,CS001_1_E,fastbus1.Q11111.data[0],CS[0][0].E);/*,ZERO_SUPPRESS_ITEM(CS[0],0)*/
SIGNAL_MAPPING(DATA12,CS001_1_T,fastbus1.T81800.data[0],CS[0][0].T);/*,ZERO_SUPPRESS_ITEM(CS[0],0)*/
SIGNAL_MAPPING(DATA12,CS002_1_E,fastbus1.Q11111.data[2],CS[1][0].E);/*,ZERO_SUPPRESS_ITEM(CS[1],0)*/
SIGNAL_MAPPING(DATA12,CS002_1_T,fastbus1.T81800.data[2],CS[1][0].T);/*,ZERO_SUPPRESS_ITEM(CS[1],0)*/
SIGNAL_MAPPING(DATA12,CS003_1_E,fastbus1.Q11111.data[4],CS[2][0].E);/*,ZERO_SUPPRESS_ITEM(CS[2],0)*/
SIGNAL_MAPPING(DATA12,CS003_1_T,fastbus1.T81800.data[4],CS[2][0].T);/*,ZERO_SUPPRESS_ITEM(CS[2],0)*/
SIGNAL_MAPPING(DATA12,CS004_1_E,fastbus1.Q11111.data[65],CS[3][0].E);/*,ZERO_SUPPRESS_ITEM(CS[3],0)*/
SIGNAL_MAPPING(DATA12,CS004_1_T,fastbus1.T87024.data[1],CS[3][0].T);/*,ZERO_SUPPRESS_ITEM(CS[3],0)*/
SIGNAL_MAPPING(DATA12,CS005_1_E,fastbus1.Q11111.data[67],CS[4][0].E);/*,ZERO_SUPPRESS_ITEM(CS[4],0)*/
SIGNAL_MAPPING(DATA12,CS005_1_T,fastbus1.T87024.data[3],CS[4][0].T);/*,ZERO_SUPPRESS_ITEM(CS[4],0)*/
SIGNAL_MAPPING(DATA12,CS006_1_E,fastbus1.Q11111.data[69],CS[5][0].E);/*,ZERO_SUPPRESS_ITEM(CS[5],0)*/
SIGNAL_MAPPING(DATA12,CS006_1_T,fastbus1.T87024.data[5],CS[5][0].T);/*,ZERO_SUPPRESS_ITEM(CS[5],0)*/
SIGNAL_MAPPING(DATA12,CS007_1_E,fastbus1.Q11111.data[71],CS[6][0].E);/*,ZERO_SUPPRESS_ITEM(CS[6],0)*/
SIGNAL_MAPPING(DATA12,CS007_1_T,fastbus1.T87024.data[7],CS[6][0].T);/*,ZERO_SUPPRESS_ITEM(CS[6],0)*/
SIGNAL_MAPPING(DATA12,CS008_1_E,fastbus1.Q11111.data[73],CS[7][0].E);/*,ZERO_SUPPRESS_ITEM(CS[7],0)*/
SIGNAL_MAPPING(DATA12,CS008_1_T,fastbus1.T87024.data[9],CS[7][0].T);/*,ZERO_SUPPRESS_ITEM(CS[7],0)*/
SIGNAL_MAPPING(DATA12,CS009_1_E,fastbus1.Q11111.data[75],CS[8][0].E);/*,ZERO_SUPPRESS_ITEM(CS[8],0)*/
SIGNAL_MAPPING(DATA12,CS009_1_T,fastbus1.T87024.data[11],CS[8][0].T);/*,ZERO_SUPPRESS_ITEM(CS[8],0)*/
SIGNAL_MAPPING(DATA12,CS010_1_E,fastbus1.Q11111.data[6],CS[9][0].E);/*,ZERO_SUPPRESS_ITEM(CS[9],0)*/
SIGNAL_MAPPING(DATA12,CS010_1_T,fastbus1.T81800.data[6],CS[9][0].T);/*,ZERO_SUPPRESS_ITEM(CS[9],0)*/
SIGNAL_MAPPING(DATA12,CS011_1_E,fastbus1.Q11111.data[8],CS[10][0].E);/*,ZERO_SUPPRESS_ITEM(CS[10],0)*/
SIGNAL_MAPPING(DATA12,CS011_1_T,fastbus1.T81800.data[8],CS[10][0].T);/*,ZERO_SUPPRESS_ITEM(CS[10],0)*/
SIGNAL_MAPPING(DATA12,CS012_1_E,fastbus1.Q11111.data[10],CS[11][0].E);/*,ZERO_SUPPRESS_ITEM(CS[11],0)*/
SIGNAL_MAPPING(DATA12,CS012_1_T,fastbus1.T81800.data[10],CS[11][0].T);/*,ZERO_SUPPRESS_ITEM(CS[11],0)*/
SIGNAL_MAPPING(DATA12,CS013_1_E,fastbus1.Q11111.data[12],CS[12][0].E);/*,ZERO_SUPPRESS_ITEM(CS[12],0)*/
SIGNAL_MAPPING(DATA12,CS013_1_T,fastbus1.T81800.data[12],CS[12][0].T);/*,ZERO_SUPPRESS_ITEM(CS[12],0)*/
SIGNAL_MAPPING(DATA12,CS014_1_E,fastbus1.Q11111.data[14],CS[13][0].E);/*,ZERO_SUPPRESS_ITEM(CS[13],0)*/
SIGNAL_MAPPING(DATA12,CS014_1_T,fastbus1.T81800.data[14],CS[13][0].T);/*,ZERO_SUPPRESS_ITEM(CS[13],0)*/
SIGNAL_MAPPING(DATA12,CS015_1_E,fastbus1.Q11111.data[1],CS[14][0].E);/*,ZERO_SUPPRESS_ITEM(CS[14],0)*/
SIGNAL_MAPPING(DATA12,CS015_1_T,fastbus1.T81800.data[1],CS[14][0].T);/*,ZERO_SUPPRESS_ITEM(CS[14],0)*/
SIGNAL_MAPPING(DATA12,CS016_1_E,fastbus1.Q11111.data[77],CS[15][0].E);/*,ZERO_SUPPRESS_ITEM(CS[15],0)*/
SIGNAL_MAPPING(DATA12,CS016_1_T,fastbus1.T87024.data[13],CS[15][0].T);/*,ZERO_SUPPRESS_ITEM(CS[15],0)*/
SIGNAL_MAPPING(DATA12,CS017_1_E,fastbus1.Q11111.data[79],CS[16][0].E);/*,ZERO_SUPPRESS_ITEM(CS[16],0)*/
SIGNAL_MAPPING(DATA12,CS017_1_T,fastbus1.T87024.data[15],CS[16][0].T);/*,ZERO_SUPPRESS_ITEM(CS[16],0)*/
SIGNAL_MAPPING(DATA12,CS018_1_E,fastbus1.Q11111.data[80],CS[17][0].E);/*,ZERO_SUPPRESS_ITEM(CS[17],0)*/
SIGNAL_MAPPING(DATA12,CS018_1_T,fastbus1.T87024.data[16],CS[17][0].T);/*,ZERO_SUPPRESS_ITEM(CS[17],0)*/
SIGNAL_MAPPING(DATA12,CS019_1_E,fastbus1.Q11111.data[82],CS[18][0].E);/*,ZERO_SUPPRESS_ITEM(CS[18],0)*/
SIGNAL_MAPPING(DATA12,CS019_1_T,fastbus1.T87024.data[18],CS[18][0].T);/*,ZERO_SUPPRESS_ITEM(CS[18],0)*/
SIGNAL_MAPPING(DATA12,CS020_1_E,fastbus1.Q11111.data[84],CS[19][0].E);/*,ZERO_SUPPRESS_ITEM(CS[19],0)*/
SIGNAL_MAPPING(DATA12,CS020_1_T,fastbus1.T87024.data[20],CS[19][0].T);/*,ZERO_SUPPRESS_ITEM(CS[19],0)*/
SIGNAL_MAPPING(DATA12,CS021_1_E,fastbus1.Q11111.data[86],CS[20][0].E);/*,ZERO_SUPPRESS_ITEM(CS[20],0)*/
SIGNAL_MAPPING(DATA12,CS021_1_T,fastbus1.T87024.data[22],CS[20][0].T);/*,ZERO_SUPPRESS_ITEM(CS[20],0)*/
SIGNAL_MAPPING(DATA12,CS022_1_E,fastbus1.Q11111.data[3],CS[21][0].E);/*,ZERO_SUPPRESS_ITEM(CS[21],0)*/
SIGNAL_MAPPING(DATA12,CS022_1_T,fastbus1.T81800.data[3],CS[21][0].T);/*,ZERO_SUPPRESS_ITEM(CS[21],0)*/
SIGNAL_MAPPING(DATA12,CS023_1_E,fastbus1.Q11111.data[5],CS[22][0].E);/*,ZERO_SUPPRESS_ITEM(CS[22],0)*/
SIGNAL_MAPPING(DATA12,CS023_1_T,fastbus1.T81800.data[5],CS[22][0].T);/*,ZERO_SUPPRESS_ITEM(CS[22],0)*/
SIGNAL_MAPPING(DATA12,CS024_1_E,fastbus1.Q11111.data[7],CS[23][0].E);/*,ZERO_SUPPRESS_ITEM(CS[23],0)*/
SIGNAL_MAPPING(DATA12,CS024_1_T,fastbus1.T81800.data[7],CS[23][0].T);/*,ZERO_SUPPRESS_ITEM(CS[23],0)*/
SIGNAL_MAPPING(DATA12,CS025_1_E,fastbus1.Q11111.data[9],CS[24][0].E);/*,ZERO_SUPPRESS_ITEM(CS[24],0)*/
SIGNAL_MAPPING(DATA12,CS025_1_T,fastbus1.T81800.data[9],CS[24][0].T);/*,ZERO_SUPPRESS_ITEM(CS[24],0)*/
SIGNAL_MAPPING(DATA12,CS026_1_E,fastbus1.Q11111.data[11],CS[25][0].E);/*,ZERO_SUPPRESS_ITEM(CS[25],0)*/
SIGNAL_MAPPING(DATA12,CS026_1_T,fastbus1.T81800.data[11],CS[25][0].T);/*,ZERO_SUPPRESS_ITEM(CS[25],0)*/
SIGNAL_MAPPING(DATA12,CS027_1_E,fastbus1.Q11111.data[13],CS[26][0].E);/*,ZERO_SUPPRESS_ITEM(CS[26],0)*/
SIGNAL_MAPPING(DATA12,CS027_1_T,fastbus1.T81800.data[13],CS[26][0].T);/*,ZERO_SUPPRESS_ITEM(CS[26],0)*/
SIGNAL_MAPPING(DATA12,CS028_1_E,fastbus1.Q11111.data[88],CS[27][0].E);/*,ZERO_SUPPRESS_ITEM(CS[27],0)*/
SIGNAL_MAPPING(DATA12,CS028_1_T,fastbus1.T87024.data[24],CS[27][0].T);/*,ZERO_SUPPRESS_ITEM(CS[27],0)*/
SIGNAL_MAPPING(DATA12,CS029_1_E,fastbus1.Q11111.data[90],CS[28][0].E);/*,ZERO_SUPPRESS_ITEM(CS[28],0)*/
SIGNAL_MAPPING(DATA12,CS029_1_T,fastbus1.T87024.data[26],CS[28][0].T);/*,ZERO_SUPPRESS_ITEM(CS[28],0)*/
SIGNAL_MAPPING(DATA12,CS030_1_E,fastbus1.Q11111.data[92],CS[29][0].E);/*,ZERO_SUPPRESS_ITEM(CS[29],0)*/
SIGNAL_MAPPING(DATA12,CS030_1_T,fastbus1.T87024.data[28],CS[29][0].T);/*,ZERO_SUPPRESS_ITEM(CS[29],0)*/
SIGNAL_MAPPING(DATA12,CS031_1_E,fastbus1.Q11111.data[94],CS[30][0].E);/*,ZERO_SUPPRESS_ITEM(CS[30],0)*/
SIGNAL_MAPPING(DATA12,CS031_1_T,fastbus1.T87024.data[30],CS[30][0].T);/*,ZERO_SUPPRESS_ITEM(CS[30],0)*/
SIGNAL_MAPPING(DATA12,CS032_1_E,fastbus1.Q11111.data[81],CS[31][0].E);/*,ZERO_SUPPRESS_ITEM(CS[31],0)*/
SIGNAL_MAPPING(DATA12,CS032_1_T,fastbus1.T87024.data[17],CS[31][0].T);/*,ZERO_SUPPRESS_ITEM(CS[31],0)*/
SIGNAL_MAPPING(DATA12,CS033_1_E,fastbus1.Q11111.data[83],CS[32][0].E);/*,ZERO_SUPPRESS_ITEM(CS[32],0)*/
SIGNAL_MAPPING(DATA12,CS033_1_T,fastbus1.T87024.data[19],CS[32][0].T);/*,ZERO_SUPPRESS_ITEM(CS[32],0)*/
SIGNAL_MAPPING(DATA12,CS034_1_E,fastbus1.Q11111.data[15],CS[33][0].E);/*,ZERO_SUPPRESS_ITEM(CS[33],0)*/
SIGNAL_MAPPING(DATA12,CS034_1_T,fastbus1.T81800.data[15],CS[33][0].T);/*,ZERO_SUPPRESS_ITEM(CS[33],0)*/
SIGNAL_MAPPING(DATA12,CS035_1_E,fastbus1.Q11111.data[16],CS[34][0].E);/*,ZERO_SUPPRESS_ITEM(CS[34],0)*/
SIGNAL_MAPPING(DATA12,CS035_1_T,fastbus1.T81800.data[16],CS[34][0].T);/*,ZERO_SUPPRESS_ITEM(CS[34],0)*/
SIGNAL_MAPPING(DATA12,CS036_1_E,fastbus1.Q11111.data[18],CS[35][0].E);/*,ZERO_SUPPRESS_ITEM(CS[35],0)*/
SIGNAL_MAPPING(DATA12,CS036_1_T,fastbus1.T81800.data[18],CS[35][0].T);/*,ZERO_SUPPRESS_ITEM(CS[35],0)*/
SIGNAL_MAPPING(DATA12,CS037_1_E,fastbus1.Q11111.data[20],CS[36][0].E);/*,ZERO_SUPPRESS_ITEM(CS[36],0)*/
SIGNAL_MAPPING(DATA12,CS037_1_T,fastbus1.T81800.data[20],CS[36][0].T);/*,ZERO_SUPPRESS_ITEM(CS[36],0)*/
SIGNAL_MAPPING(DATA12,CS038_1_E,fastbus1.Q11111.data[22],CS[37][0].E);/*,ZERO_SUPPRESS_ITEM(CS[37],0)*/
SIGNAL_MAPPING(DATA12,CS038_1_T,fastbus1.T81800.data[22],CS[37][0].T);/*,ZERO_SUPPRESS_ITEM(CS[37],0)*/
SIGNAL_MAPPING(DATA12,CS039_1_E,fastbus1.Q11111.data[24],CS[38][0].E);/*,ZERO_SUPPRESS_ITEM(CS[38],0)*/
SIGNAL_MAPPING(DATA12,CS039_1_T,fastbus1.T81800.data[24],CS[38][0].T);/*,ZERO_SUPPRESS_ITEM(CS[38],0)*/
SIGNAL_MAPPING(DATA12,CS040_1_E,fastbus1.Q11111.data[85],CS[39][0].E);/*,ZERO_SUPPRESS_ITEM(CS[39],0)*/
SIGNAL_MAPPING(DATA12,CS040_1_T,fastbus1.T87024.data[21],CS[39][0].T);/*,ZERO_SUPPRESS_ITEM(CS[39],0)*/
SIGNAL_MAPPING(DATA12,CS041_1_E,fastbus1.Q11111.data[87],CS[40][0].E);/*,ZERO_SUPPRESS_ITEM(CS[40],0)*/
SIGNAL_MAPPING(DATA12,CS041_1_T,fastbus1.T87024.data[23],CS[40][0].T);/*,ZERO_SUPPRESS_ITEM(CS[40],0)*/
SIGNAL_MAPPING(DATA12,CS042_1_E,fastbus1.Q11111.data[89],CS[41][0].E);/*,ZERO_SUPPRESS_ITEM(CS[41],0)*/
SIGNAL_MAPPING(DATA12,CS042_1_T,fastbus1.T87024.data[25],CS[41][0].T);/*,ZERO_SUPPRESS_ITEM(CS[41],0)*/
SIGNAL_MAPPING(DATA12,CS043_1_E,fastbus1.Q11111.data[91],CS[42][0].E);/*,ZERO_SUPPRESS_ITEM(CS[42],0)*/
SIGNAL_MAPPING(DATA12,CS043_1_T,fastbus1.T87024.data[27],CS[42][0].T);/*,ZERO_SUPPRESS_ITEM(CS[42],0)*/
SIGNAL_MAPPING(DATA12,CS044_1_E,fastbus1.Q11111.data[93],CS[43][0].E);/*,ZERO_SUPPRESS_ITEM(CS[43],0)*/
SIGNAL_MAPPING(DATA12,CS044_1_T,fastbus1.T87024.data[29],CS[43][0].T);/*,ZERO_SUPPRESS_ITEM(CS[43],0)*/
SIGNAL_MAPPING(DATA12,CS045_1_E,fastbus1.Q11111.data[95],CS[44][0].E);/*,ZERO_SUPPRESS_ITEM(CS[44],0)*/
SIGNAL_MAPPING(DATA12,CS045_1_T,fastbus1.T87024.data[31],CS[44][0].T);/*,ZERO_SUPPRESS_ITEM(CS[44],0)*/
SIGNAL_MAPPING(DATA12,CS046_1_E,fastbus1.Q11111.data[26],CS[45][0].E);/*,ZERO_SUPPRESS_ITEM(CS[45],0)*/
SIGNAL_MAPPING(DATA12,CS046_1_T,fastbus1.T81800.data[26],CS[45][0].T);/*,ZERO_SUPPRESS_ITEM(CS[45],0)*/
SIGNAL_MAPPING(DATA12,CS047_1_E,fastbus1.Q11111.data[28],CS[46][0].E);/*,ZERO_SUPPRESS_ITEM(CS[46],0)*/
SIGNAL_MAPPING(DATA12,CS047_1_T,fastbus1.T81800.data[28],CS[46][0].T);/*,ZERO_SUPPRESS_ITEM(CS[46],0)*/
SIGNAL_MAPPING(DATA12,CS048_1_E,fastbus1.Q11111.data[30],CS[47][0].E);/*,ZERO_SUPPRESS_ITEM(CS[47],0)*/
SIGNAL_MAPPING(DATA12,CS048_1_T,fastbus1.T81800.data[30],CS[47][0].T);/*,ZERO_SUPPRESS_ITEM(CS[47],0)*/
SIGNAL_MAPPING(DATA12,CS049_1_E,fastbus1.Q11111.data[17],CS[48][0].E);/*,ZERO_SUPPRESS_ITEM(CS[48],0)*/
SIGNAL_MAPPING(DATA12,CS049_1_T,fastbus1.T81800.data[17],CS[48][0].T);/*,ZERO_SUPPRESS_ITEM(CS[48],0)*/
SIGNAL_MAPPING(DATA12,CS050_1_E,fastbus1.Q11111.data[19],CS[49][0].E);/*,ZERO_SUPPRESS_ITEM(CS[49],0)*/
SIGNAL_MAPPING(DATA12,CS050_1_T,fastbus1.T81800.data[19],CS[49][0].T);/*,ZERO_SUPPRESS_ITEM(CS[49],0)*/
SIGNAL_MAPPING(DATA12,CS051_1_E,fastbus1.Q11111.data[21],CS[50][0].E);/*,ZERO_SUPPRESS_ITEM(CS[50],0)*/
SIGNAL_MAPPING(DATA12,CS051_1_T,fastbus1.T81800.data[21],CS[50][0].T);/*,ZERO_SUPPRESS_ITEM(CS[50],0)*/
SIGNAL_MAPPING(DATA12,CS052_1_E,fastbus1.Q47342.data[0],CS[51][0].E);/*,ZERO_SUPPRESS_ITEM(CS[51],0)*/
SIGNAL_MAPPING(DATA12,CS052_1_T,fastbus1.T87044.data[16],CS[51][0].T);/*,ZERO_SUPPRESS_ITEM(CS[51],0)*/
SIGNAL_MAPPING(DATA12,CS053_1_E,fastbus1.Q47342.data[2],CS[52][0].E);/*,ZERO_SUPPRESS_ITEM(CS[52],0)*/
SIGNAL_MAPPING(DATA12,CS053_1_T,fastbus1.T87044.data[18],CS[52][0].T);/*,ZERO_SUPPRESS_ITEM(CS[52],0)*/
SIGNAL_MAPPING(DATA12,CS054_1_E,fastbus1.Q47342.data[4],CS[53][0].E);/*,ZERO_SUPPRESS_ITEM(CS[53],0)*/
SIGNAL_MAPPING(DATA12,CS054_1_T,fastbus1.T87044.data[20],CS[53][0].T);/*,ZERO_SUPPRESS_ITEM(CS[53],0)*/
SIGNAL_MAPPING(DATA12,CS055_1_E,fastbus1.Q47342.data[6],CS[54][0].E);/*,ZERO_SUPPRESS_ITEM(CS[54],0)*/
SIGNAL_MAPPING(DATA12,CS055_1_T,fastbus1.T87044.data[22],CS[54][0].T);/*,ZERO_SUPPRESS_ITEM(CS[54],0)*/
SIGNAL_MAPPING(DATA12,CS056_1_E,fastbus1.Q47342.data[8],CS[55][0].E);/*,ZERO_SUPPRESS_ITEM(CS[55],0)*/
SIGNAL_MAPPING(DATA12,CS056_1_T,fastbus1.T87044.data[24],CS[55][0].T);/*,ZERO_SUPPRESS_ITEM(CS[55],0)*/
SIGNAL_MAPPING(DATA12,CS057_1_E,fastbus1.Q47342.data[10],CS[56][0].E);/*,ZERO_SUPPRESS_ITEM(CS[56],0)*/
SIGNAL_MAPPING(DATA12,CS057_1_T,fastbus1.T87044.data[26],CS[56][0].T);/*,ZERO_SUPPRESS_ITEM(CS[56],0)*/
SIGNAL_MAPPING(DATA12,CS058_1_E,fastbus1.Q11111.data[23],CS[57][0].E);/*,ZERO_SUPPRESS_ITEM(CS[57],0)*/
SIGNAL_MAPPING(DATA12,CS058_1_T,fastbus1.T81800.data[23],CS[57][0].T);/*,ZERO_SUPPRESS_ITEM(CS[57],0)*/
SIGNAL_MAPPING(DATA12,CS059_1_E,fastbus1.Q11111.data[25],CS[58][0].E);/*,ZERO_SUPPRESS_ITEM(CS[58],0)*/
SIGNAL_MAPPING(DATA12,CS059_1_T,fastbus1.T81800.data[25],CS[58][0].T);/*,ZERO_SUPPRESS_ITEM(CS[58],0)*/
SIGNAL_MAPPING(DATA12,CS060_1_E,fastbus1.Q11111.data[27],CS[59][0].E);/*,ZERO_SUPPRESS_ITEM(CS[59],0)*/
SIGNAL_MAPPING(DATA12,CS060_1_T,fastbus1.T81800.data[27],CS[59][0].T);/*,ZERO_SUPPRESS_ITEM(CS[59],0)*/
SIGNAL_MAPPING(DATA12,CS061_1_E,fastbus1.Q11111.data[29],CS[60][0].E);/*,ZERO_SUPPRESS_ITEM(CS[60],0)*/
SIGNAL_MAPPING(DATA12,CS061_1_T,fastbus1.T81800.data[29],CS[60][0].T);/*,ZERO_SUPPRESS_ITEM(CS[60],0)*/
SIGNAL_MAPPING(DATA12,CS062_1_E,fastbus1.Q11111.data[31],CS[61][0].E);/*,ZERO_SUPPRESS_ITEM(CS[61],0)*/
SIGNAL_MAPPING(DATA12,CS062_1_T,fastbus1.T81800.data[31],CS[61][0].T);/*,ZERO_SUPPRESS_ITEM(CS[61],0)*/
SIGNAL_MAPPING(DATA12,CS063_1_E,fastbus1.Q11111.data[32],CS[62][0].E);/*,ZERO_SUPPRESS_ITEM(CS[62],0)*/
SIGNAL_MAPPING(DATA12,CS063_1_T,fastbus1.T81800.data[32],CS[62][0].T);/*,ZERO_SUPPRESS_ITEM(CS[62],0)*/
SIGNAL_MAPPING(DATA12,CS064_1_E,fastbus1.Q47342.data[12],CS[63][0].E);/*,ZERO_SUPPRESS_ITEM(CS[63],0)*/
SIGNAL_MAPPING(DATA12,CS064_1_T,fastbus1.T87044.data[28],CS[63][0].T);/*,ZERO_SUPPRESS_ITEM(CS[63],0)*/
SIGNAL_MAPPING(DATA12,CS065_1_E,fastbus1.Q47342.data[14],CS[64][0].E);/*,ZERO_SUPPRESS_ITEM(CS[64],0)*/
SIGNAL_MAPPING(DATA12,CS065_1_T,fastbus1.T87044.data[30],CS[64][0].T);/*,ZERO_SUPPRESS_ITEM(CS[64],0)*/
SIGNAL_MAPPING(DATA12,CS066_1_E,fastbus1.Q47342.data[1],CS[65][0].E);/*,ZERO_SUPPRESS_ITEM(CS[65],0)*/
SIGNAL_MAPPING(DATA12,CS066_1_T,fastbus1.T87044.data[17],CS[65][0].T);/*,ZERO_SUPPRESS_ITEM(CS[65],0)*/
SIGNAL_MAPPING(DATA12,CS067_1_E,fastbus1.Q47342.data[3],CS[66][0].E);/*,ZERO_SUPPRESS_ITEM(CS[66],0)*/
SIGNAL_MAPPING(DATA12,CS067_1_T,fastbus1.T87044.data[19],CS[66][0].T);/*,ZERO_SUPPRESS_ITEM(CS[66],0)*/
SIGNAL_MAPPING(DATA12,CS068_1_E,fastbus1.Q47342.data[5],CS[67][0].E);/*,ZERO_SUPPRESS_ITEM(CS[67],0)*/
SIGNAL_MAPPING(DATA12,CS068_1_T,fastbus1.T87044.data[21],CS[67][0].T);/*,ZERO_SUPPRESS_ITEM(CS[67],0)*/
SIGNAL_MAPPING(DATA12,CS069_1_E,fastbus1.Q47342.data[7],CS[68][0].E);/*,ZERO_SUPPRESS_ITEM(CS[68],0)*/
SIGNAL_MAPPING(DATA12,CS069_1_T,fastbus1.T87044.data[23],CS[68][0].T);/*,ZERO_SUPPRESS_ITEM(CS[68],0)*/
SIGNAL_MAPPING(DATA12,CS070_1_E,fastbus1.Q11111.data[34],CS[69][0].E);/*,ZERO_SUPPRESS_ITEM(CS[69],0)*/
SIGNAL_MAPPING(DATA12,CS070_1_T,fastbus1.T81800.data[34],CS[69][0].T);/*,ZERO_SUPPRESS_ITEM(CS[69],0)*/
SIGNAL_MAPPING(DATA12,CS071_1_E,fastbus1.Q11111.data[36],CS[70][0].E);/*,ZERO_SUPPRESS_ITEM(CS[70],0)*/
SIGNAL_MAPPING(DATA12,CS071_1_T,fastbus1.T81800.data[36],CS[70][0].T);/*,ZERO_SUPPRESS_ITEM(CS[70],0)*/
SIGNAL_MAPPING(DATA12,CS072_1_E,fastbus1.Q11111.data[38],CS[71][0].E);/*,ZERO_SUPPRESS_ITEM(CS[71],0)*/
SIGNAL_MAPPING(DATA12,CS072_1_T,fastbus1.T81800.data[38],CS[71][0].T);/*,ZERO_SUPPRESS_ITEM(CS[71],0)*/
SIGNAL_MAPPING(DATA12,CS073_1_E,fastbus1.Q11111.data[40],CS[72][0].E);/*,ZERO_SUPPRESS_ITEM(CS[72],0)*/
SIGNAL_MAPPING(DATA12,CS073_1_T,fastbus1.T81800.data[40],CS[72][0].T);/*,ZERO_SUPPRESS_ITEM(CS[72],0)*/
SIGNAL_MAPPING(DATA12,CS074_1_E,fastbus1.Q11111.data[42],CS[73][0].E);/*,ZERO_SUPPRESS_ITEM(CS[73],0)*/
SIGNAL_MAPPING(DATA12,CS074_1_T,fastbus1.T81800.data[42],CS[73][0].T);/*,ZERO_SUPPRESS_ITEM(CS[73],0)*/
SIGNAL_MAPPING(DATA12,CS075_1_E,fastbus1.Q11111.data[44],CS[74][0].E);/*,ZERO_SUPPRESS_ITEM(CS[74],0)*/
SIGNAL_MAPPING(DATA12,CS075_1_T,fastbus1.T81800.data[44],CS[74][0].T);/*,ZERO_SUPPRESS_ITEM(CS[74],0)*/
SIGNAL_MAPPING(DATA12,CS076_1_E,fastbus1.Q47342.data[9],CS[75][0].E);/*,ZERO_SUPPRESS_ITEM(CS[75],0)*/
SIGNAL_MAPPING(DATA12,CS076_1_T,fastbus1.T87044.data[25],CS[75][0].T);/*,ZERO_SUPPRESS_ITEM(CS[75],0)*/
SIGNAL_MAPPING(DATA12,CS077_1_E,fastbus1.Q47342.data[11],CS[76][0].E);/*,ZERO_SUPPRESS_ITEM(CS[76],0)*/
SIGNAL_MAPPING(DATA12,CS077_1_T,fastbus1.T87044.data[27],CS[76][0].T);/*,ZERO_SUPPRESS_ITEM(CS[76],0)*/
SIGNAL_MAPPING(DATA12,CS078_1_E,fastbus1.Q47342.data[13],CS[77][0].E);/*,ZERO_SUPPRESS_ITEM(CS[77],0)*/
SIGNAL_MAPPING(DATA12,CS078_1_T,fastbus1.T87044.data[29],CS[77][0].T);/*,ZERO_SUPPRESS_ITEM(CS[77],0)*/
SIGNAL_MAPPING(DATA12,CS079_1_E,fastbus1.Q47342.data[15],CS[78][0].E);/*,ZERO_SUPPRESS_ITEM(CS[78],0)*/
SIGNAL_MAPPING(DATA12,CS079_1_T,fastbus1.T87044.data[31],CS[78][0].T);/*,ZERO_SUPPRESS_ITEM(CS[78],0)*/
SIGNAL_MAPPING(DATA12,CS080_1_E,fastbus1.Q47342.data[16],CS[79][0].E);/*,ZERO_SUPPRESS_ITEM(CS[79],0)*/
SIGNAL_MAPPING(DATA12,CS080_1_T,fastbus1.T87024.data[48],CS[79][0].T);/*,ZERO_SUPPRESS_ITEM(CS[79],0)*/
SIGNAL_MAPPING(DATA12,CS081_1_E,fastbus1.Q47342.data[18],CS[80][0].E);/*,ZERO_SUPPRESS_ITEM(CS[80],0)*/
SIGNAL_MAPPING(DATA12,CS081_1_T,fastbus1.T87024.data[50],CS[80][0].T);/*,ZERO_SUPPRESS_ITEM(CS[80],0)*/
SIGNAL_MAPPING(DATA12,CS082_1_E,fastbus1.Q11111.data[46],CS[81][0].E);/*,ZERO_SUPPRESS_ITEM(CS[81],0)*/
SIGNAL_MAPPING(DATA12,CS082_1_T,fastbus1.T81800.data[46],CS[81][0].T);/*,ZERO_SUPPRESS_ITEM(CS[81],0)*/
SIGNAL_MAPPING(DATA12,CS083_1_E,fastbus1.Q11111.data[33],CS[82][0].E);/*,ZERO_SUPPRESS_ITEM(CS[82],0)*/
SIGNAL_MAPPING(DATA12,CS083_1_T,fastbus1.T81800.data[33],CS[82][0].T);/*,ZERO_SUPPRESS_ITEM(CS[82],0)*/
SIGNAL_MAPPING(DATA12,CS084_1_E,fastbus1.Q11111.data[35],CS[83][0].E);/*,ZERO_SUPPRESS_ITEM(CS[83],0)*/
SIGNAL_MAPPING(DATA12,CS084_1_T,fastbus1.T81800.data[35],CS[83][0].T);/*,ZERO_SUPPRESS_ITEM(CS[83],0)*/
SIGNAL_MAPPING(DATA12,CS085_1_E,fastbus1.Q11111.data[37],CS[84][0].E);/*,ZERO_SUPPRESS_ITEM(CS[84],0)*/
SIGNAL_MAPPING(DATA12,CS085_1_T,fastbus1.T81800.data[37],CS[84][0].T);/*,ZERO_SUPPRESS_ITEM(CS[84],0)*/
SIGNAL_MAPPING(DATA12,CS086_1_E,fastbus1.Q11111.data[39],CS[85][0].E);/*,ZERO_SUPPRESS_ITEM(CS[85],0)*/
SIGNAL_MAPPING(DATA12,CS086_1_T,fastbus1.T81800.data[39],CS[85][0].T);/*,ZERO_SUPPRESS_ITEM(CS[85],0)*/
SIGNAL_MAPPING(DATA12,CS087_1_E,fastbus1.Q11111.data[41],CS[86][0].E);/*,ZERO_SUPPRESS_ITEM(CS[86],0)*/
SIGNAL_MAPPING(DATA12,CS087_1_T,fastbus1.T81800.data[41],CS[86][0].T);/*,ZERO_SUPPRESS_ITEM(CS[86],0)*/
SIGNAL_MAPPING(DATA12,CS088_1_E,fastbus1.Q47342.data[20],CS[87][0].E);/*,ZERO_SUPPRESS_ITEM(CS[87],0)*/
SIGNAL_MAPPING(DATA12,CS088_1_T,fastbus1.T87024.data[52],CS[87][0].T);/*,ZERO_SUPPRESS_ITEM(CS[87],0)*/
SIGNAL_MAPPING(DATA12,CS089_1_E,fastbus1.Q47342.data[22],CS[88][0].E);/*,ZERO_SUPPRESS_ITEM(CS[88],0)*/
SIGNAL_MAPPING(DATA12,CS089_1_T,fastbus1.T87024.data[54],CS[88][0].T);/*,ZERO_SUPPRESS_ITEM(CS[88],0)*/
SIGNAL_MAPPING(DATA12,CS090_1_E,fastbus1.Q47342.data[24],CS[89][0].E);/*,ZERO_SUPPRESS_ITEM(CS[89],0)*/
SIGNAL_MAPPING(DATA12,CS090_1_T,fastbus1.T87024.data[56],CS[89][0].T);/*,ZERO_SUPPRESS_ITEM(CS[89],0)*/
SIGNAL_MAPPING(DATA12,CS091_1_E,fastbus1.Q47342.data[26],CS[90][0].E);/*,ZERO_SUPPRESS_ITEM(CS[90],0)*/
SIGNAL_MAPPING(DATA12,CS091_1_T,fastbus1.T87024.data[58],CS[90][0].T);/*,ZERO_SUPPRESS_ITEM(CS[90],0)*/
SIGNAL_MAPPING(DATA12,CS092_1_E,fastbus1.Q47342.data[28],CS[91][0].E);/*,ZERO_SUPPRESS_ITEM(CS[91],0)*/
SIGNAL_MAPPING(DATA12,CS092_1_T,fastbus1.T87024.data[60],CS[91][0].T);/*,ZERO_SUPPRESS_ITEM(CS[91],0)*/
SIGNAL_MAPPING(DATA12,CS093_1_E,fastbus1.Q47342.data[30],CS[92][0].E);/*,ZERO_SUPPRESS_ITEM(CS[92],0)*/
SIGNAL_MAPPING(DATA12,CS093_1_T,fastbus1.T87024.data[62],CS[92][0].T);/*,ZERO_SUPPRESS_ITEM(CS[92],0)*/
SIGNAL_MAPPING(DATA12,CS094_1_E,fastbus1.Q11111.data[43],CS[93][0].E);/*,ZERO_SUPPRESS_ITEM(CS[93],0)*/
SIGNAL_MAPPING(DATA12,CS094_1_T,fastbus1.T81800.data[43],CS[93][0].T);/*,ZERO_SUPPRESS_ITEM(CS[93],0)*/
SIGNAL_MAPPING(DATA12,CS095_1_E,fastbus1.Q11111.data[45],CS[94][0].E);/*,ZERO_SUPPRESS_ITEM(CS[94],0)*/
SIGNAL_MAPPING(DATA12,CS095_1_T,fastbus1.T81800.data[45],CS[94][0].T);/*,ZERO_SUPPRESS_ITEM(CS[94],0)*/
SIGNAL_MAPPING(DATA12,CS096_1_E,fastbus1.Q11111.data[47],CS[95][0].E);/*,ZERO_SUPPRESS_ITEM(CS[95],0)*/
SIGNAL_MAPPING(DATA12,CS096_1_T,fastbus1.T81800.data[47],CS[95][0].T);/*,ZERO_SUPPRESS_ITEM(CS[95],0)*/
SIGNAL_MAPPING(DATA12,CS097_1_E,fastbus1.Q11111.data[48],CS[96][0].E);/*,ZERO_SUPPRESS_ITEM(CS[96],0)*/
SIGNAL_MAPPING(DATA12,CS097_1_T,fastbus1.T81800.data[48],CS[96][0].T);/*,ZERO_SUPPRESS_ITEM(CS[96],0)*/
SIGNAL_MAPPING(DATA12,CS098_1_E,fastbus1.Q11111.data[50],CS[97][0].E);/*,ZERO_SUPPRESS_ITEM(CS[97],0)*/
SIGNAL_MAPPING(DATA12,CS098_1_T,fastbus1.T81800.data[50],CS[97][0].T);/*,ZERO_SUPPRESS_ITEM(CS[97],0)*/
SIGNAL_MAPPING(DATA12,CS099_1_E,fastbus1.Q11111.data[52],CS[98][0].E);/*,ZERO_SUPPRESS_ITEM(CS[98],0)*/
SIGNAL_MAPPING(DATA12,CS099_1_T,fastbus1.T81800.data[52],CS[98][0].T);/*,ZERO_SUPPRESS_ITEM(CS[98],0)*/
SIGNAL_MAPPING(DATA12,CS100_1_E,fastbus1.Q47342.data[17],CS[99][0].E);/*,ZERO_SUPPRESS_ITEM(CS[99],0)*/
SIGNAL_MAPPING(DATA12,CS100_1_T,fastbus1.T87024.data[49],CS[99][0].T);/*,ZERO_SUPPRESS_ITEM(CS[99],0)*/
SIGNAL_MAPPING(DATA12,CS101_1_E,fastbus1.Q47342.data[19],CS[100][0].E);/*,ZERO_SUPPRESS_ITEM(CS[100],0)*/
SIGNAL_MAPPING(DATA12,CS101_1_T,fastbus1.T87024.data[51],CS[100][0].T);/*,ZERO_SUPPRESS_ITEM(CS[100],0)*/
SIGNAL_MAPPING(DATA12,CS102_1_E,fastbus1.Q47342.data[21],CS[101][0].E);/*,ZERO_SUPPRESS_ITEM(CS[101],0)*/
SIGNAL_MAPPING(DATA12,CS102_1_T,fastbus1.T87024.data[53],CS[101][0].T);/*,ZERO_SUPPRESS_ITEM(CS[101],0)*/
SIGNAL_MAPPING(DATA12,CS103_1_E,fastbus1.Q47342.data[23],CS[102][0].E);/*,ZERO_SUPPRESS_ITEM(CS[102],0)*/
SIGNAL_MAPPING(DATA12,CS103_1_T,fastbus1.T87024.data[55],CS[102][0].T);/*,ZERO_SUPPRESS_ITEM(CS[102],0)*/
SIGNAL_MAPPING(DATA12,CS104_1_E,fastbus1.Q47342.data[25],CS[103][0].E);/*,ZERO_SUPPRESS_ITEM(CS[103],0)*/
SIGNAL_MAPPING(DATA12,CS104_1_T,fastbus1.T87024.data[57],CS[103][0].T);/*,ZERO_SUPPRESS_ITEM(CS[103],0)*/
SIGNAL_MAPPING(DATA12,CS105_1_E,fastbus1.Q47342.data[27],CS[104][0].E);/*,ZERO_SUPPRESS_ITEM(CS[104],0)*/
SIGNAL_MAPPING(DATA12,CS105_1_T,fastbus1.T87024.data[59],CS[104][0].T);/*,ZERO_SUPPRESS_ITEM(CS[104],0)*/
SIGNAL_MAPPING(DATA12,CS106_1_E,fastbus1.Q11111.data[54],CS[105][0].E);/*,ZERO_SUPPRESS_ITEM(CS[105],0)*/
SIGNAL_MAPPING(DATA12,CS106_1_T,fastbus1.T81800.data[54],CS[105][0].T);/*,ZERO_SUPPRESS_ITEM(CS[105],0)*/
SIGNAL_MAPPING(DATA12,CS107_1_E,fastbus1.Q11111.data[56],CS[106][0].E);/*,ZERO_SUPPRESS_ITEM(CS[106],0)*/
SIGNAL_MAPPING(DATA12,CS107_1_T,fastbus1.T81800.data[56],CS[106][0].T);/*,ZERO_SUPPRESS_ITEM(CS[106],0)*/
SIGNAL_MAPPING(DATA12,CS108_1_E,fastbus1.Q11111.data[58],CS[107][0].E);/*,ZERO_SUPPRESS_ITEM(CS[107],0)*/
SIGNAL_MAPPING(DATA12,CS108_1_T,fastbus1.T81800.data[58],CS[107][0].T);/*,ZERO_SUPPRESS_ITEM(CS[107],0)*/
SIGNAL_MAPPING(DATA12,CS109_1_E,fastbus1.Q11111.data[60],CS[108][0].E);/*,ZERO_SUPPRESS_ITEM(CS[108],0)*/
SIGNAL_MAPPING(DATA12,CS109_1_T,fastbus1.T81800.data[60],CS[108][0].T);/*,ZERO_SUPPRESS_ITEM(CS[108],0)*/
SIGNAL_MAPPING(DATA12,CS110_1_E,fastbus1.Q11111.data[62],CS[109][0].E);/*,ZERO_SUPPRESS_ITEM(CS[109],0)*/
SIGNAL_MAPPING(DATA12,CS110_1_T,fastbus1.T81800.data[62],CS[109][0].T);/*,ZERO_SUPPRESS_ITEM(CS[109],0)*/
SIGNAL_MAPPING(DATA12,CS111_1_E,fastbus1.Q11111.data[49],CS[110][0].E);/*,ZERO_SUPPRESS_ITEM(CS[110],0)*/
SIGNAL_MAPPING(DATA12,CS111_1_T,fastbus1.T81800.data[49],CS[110][0].T);/*,ZERO_SUPPRESS_ITEM(CS[110],0)*/
SIGNAL_MAPPING(DATA12,CS112_1_E,fastbus1.Q47342.data[29],CS[111][0].E);/*,ZERO_SUPPRESS_ITEM(CS[111],0)*/
SIGNAL_MAPPING(DATA12,CS112_1_T,fastbus1.T87024.data[61],CS[111][0].T);/*,ZERO_SUPPRESS_ITEM(CS[111],0)*/
SIGNAL_MAPPING(DATA12,CS113_1_E,fastbus1.Q47342.data[31],CS[112][0].E);/*,ZERO_SUPPRESS_ITEM(CS[112],0)*/
SIGNAL_MAPPING(DATA12,CS113_1_T,fastbus1.T87024.data[63],CS[112][0].T);/*,ZERO_SUPPRESS_ITEM(CS[112],0)*/
SIGNAL_MAPPING(DATA12,CS114_1_E,fastbus1.Q47342.data[32],CS[113][0].E);/*,ZERO_SUPPRESS_ITEM(CS[113],0)*/
SIGNAL_MAPPING(DATA12,CS114_1_T,fastbus1.T87044.data[0],CS[113][0].T);/*,ZERO_SUPPRESS_ITEM(CS[113],0)*/
SIGNAL_MAPPING(DATA12,CS115_1_E,fastbus1.Q47342.data[34],CS[114][0].E);/*,ZERO_SUPPRESS_ITEM(CS[114],0)*/
SIGNAL_MAPPING(DATA12,CS115_1_T,fastbus1.T87044.data[2],CS[114][0].T);/*,ZERO_SUPPRESS_ITEM(CS[114],0)*/
SIGNAL_MAPPING(DATA12,CS116_1_E,fastbus1.Q47342.data[36],CS[115][0].E);/*,ZERO_SUPPRESS_ITEM(CS[115],0)*/
SIGNAL_MAPPING(DATA12,CS116_1_T,fastbus1.T87044.data[4],CS[115][0].T);/*,ZERO_SUPPRESS_ITEM(CS[115],0)*/
SIGNAL_MAPPING(DATA12,CS117_1_E,fastbus1.Q47342.data[38],CS[116][0].E);/*,ZERO_SUPPRESS_ITEM(CS[116],0)*/
SIGNAL_MAPPING(DATA12,CS117_1_T,fastbus1.T87044.data[6],CS[116][0].T);/*,ZERO_SUPPRESS_ITEM(CS[116],0)*/
SIGNAL_MAPPING(DATA12,CS118_1_E,fastbus1.Q11111.data[51],CS[117][0].E);/*,ZERO_SUPPRESS_ITEM(CS[117],0)*/
SIGNAL_MAPPING(DATA12,CS118_1_T,fastbus1.T81800.data[51],CS[117][0].T);/*,ZERO_SUPPRESS_ITEM(CS[117],0)*/
SIGNAL_MAPPING(DATA12,CS119_1_E,fastbus1.Q11111.data[53],CS[118][0].E);/*,ZERO_SUPPRESS_ITEM(CS[118],0)*/
SIGNAL_MAPPING(DATA12,CS119_1_T,fastbus1.T81800.data[53],CS[118][0].T);/*,ZERO_SUPPRESS_ITEM(CS[118],0)*/
SIGNAL_MAPPING(DATA12,CS120_1_E,fastbus1.Q11111.data[55],CS[119][0].E);/*,ZERO_SUPPRESS_ITEM(CS[119],0)*/
SIGNAL_MAPPING(DATA12,CS120_1_T,fastbus1.T81800.data[55],CS[119][0].T);/*,ZERO_SUPPRESS_ITEM(CS[119],0)*/
SIGNAL_MAPPING(DATA12,CS121_1_E,fastbus1.Q11111.data[57],CS[120][0].E);/*,ZERO_SUPPRESS_ITEM(CS[120],0)*/
SIGNAL_MAPPING(DATA12,CS121_1_T,fastbus1.T81800.data[57],CS[120][0].T);/*,ZERO_SUPPRESS_ITEM(CS[120],0)*/
SIGNAL_MAPPING(DATA12,CS122_1_E,fastbus1.Q11111.data[59],CS[121][0].E);/*,ZERO_SUPPRESS_ITEM(CS[121],0)*/
SIGNAL_MAPPING(DATA12,CS122_1_T,fastbus1.T81800.data[59],CS[121][0].T);/*,ZERO_SUPPRESS_ITEM(CS[121],0)*/
SIGNAL_MAPPING(DATA12,CS123_1_E,fastbus1.Q11111.data[61],CS[122][0].E);/*,ZERO_SUPPRESS_ITEM(CS[122],0)*/
SIGNAL_MAPPING(DATA12,CS123_1_T,fastbus1.T81800.data[61],CS[122][0].T);/*,ZERO_SUPPRESS_ITEM(CS[122],0)*/
SIGNAL_MAPPING(DATA12,CS124_1_E,fastbus1.Q47342.data[40],CS[123][0].E);/*,ZERO_SUPPRESS_ITEM(CS[123],0)*/
SIGNAL_MAPPING(DATA12,CS124_1_T,fastbus1.T87044.data[8],CS[123][0].T);/*,ZERO_SUPPRESS_ITEM(CS[123],0)*/
SIGNAL_MAPPING(DATA12,CS125_1_E,fastbus1.Q47342.data[42],CS[124][0].E);/*,ZERO_SUPPRESS_ITEM(CS[124],0)*/
SIGNAL_MAPPING(DATA12,CS125_1_T,fastbus1.T87044.data[10],CS[124][0].T);/*,ZERO_SUPPRESS_ITEM(CS[124],0)*/
SIGNAL_MAPPING(DATA12,CS126_1_E,fastbus1.Q47342.data[44],CS[125][0].E);/*,ZERO_SUPPRESS_ITEM(CS[125],0)*/
SIGNAL_MAPPING(DATA12,CS126_1_T,fastbus1.T87044.data[12],CS[125][0].T);/*,ZERO_SUPPRESS_ITEM(CS[125],0)*/
SIGNAL_MAPPING(DATA12,CS127_1_E,fastbus1.Q47342.data[46],CS[126][0].E);/*,ZERO_SUPPRESS_ITEM(CS[126],0)*/
SIGNAL_MAPPING(DATA12,CS127_1_T,fastbus1.T87044.data[14],CS[126][0].T);/*,ZERO_SUPPRESS_ITEM(CS[126],0)*/
SIGNAL_MAPPING(DATA12,CS128_1_E,fastbus1.Q47342.data[33],CS[127][0].E);/*,ZERO_SUPPRESS_ITEM(CS[127],0)*/
SIGNAL_MAPPING(DATA12,CS128_1_T,fastbus1.T87044.data[1],CS[127][0].T);/*,ZERO_SUPPRESS_ITEM(CS[127],0)*/
SIGNAL_MAPPING(DATA12,CS129_1_E,fastbus1.Q47342.data[35],CS[128][0].E);/*,ZERO_SUPPRESS_ITEM(CS[128],0)*/
SIGNAL_MAPPING(DATA12,CS129_1_T,fastbus1.T87044.data[3],CS[128][0].T);/*,ZERO_SUPPRESS_ITEM(CS[128],0)*/
SIGNAL_MAPPING(DATA12,CS130_1_E,fastbus1.Q11111.data[63],CS[129][0].E);/*,ZERO_SUPPRESS_ITEM(CS[129],0)*/
SIGNAL_MAPPING(DATA12,CS130_1_T,fastbus1.T81800.data[63],CS[129][0].T);/*,ZERO_SUPPRESS_ITEM(CS[129],0)*/
SIGNAL_MAPPING(DATA12,CS131_1_E,fastbus1.Q11111.data[64],CS[130][0].E);/*,ZERO_SUPPRESS_ITEM(CS[130],0)*/
SIGNAL_MAPPING(DATA12,CS131_1_T,fastbus1.T87024.data[0],CS[130][0].T);/*,ZERO_SUPPRESS_ITEM(CS[130],0)*/
SIGNAL_MAPPING(DATA12,CS132_1_E,fastbus1.Q11111.data[66],CS[131][0].E);/*,ZERO_SUPPRESS_ITEM(CS[131],0)*/
SIGNAL_MAPPING(DATA12,CS132_1_T,fastbus1.T87024.data[2],CS[131][0].T);/*,ZERO_SUPPRESS_ITEM(CS[131],0)*/
SIGNAL_MAPPING(DATA12,CS133_1_E,fastbus1.Q11111.data[68],CS[132][0].E);/*,ZERO_SUPPRESS_ITEM(CS[132],0)*/
SIGNAL_MAPPING(DATA12,CS133_1_T,fastbus1.T87024.data[4],CS[132][0].T);/*,ZERO_SUPPRESS_ITEM(CS[132],0)*/
SIGNAL_MAPPING(DATA12,CS134_1_E,fastbus1.Q11111.data[70],CS[133][0].E);/*,ZERO_SUPPRESS_ITEM(CS[133],0)*/
SIGNAL_MAPPING(DATA12,CS134_1_T,fastbus1.T87024.data[6],CS[133][0].T);/*,ZERO_SUPPRESS_ITEM(CS[133],0)*/
SIGNAL_MAPPING(DATA12,CS135_1_E,fastbus1.Q11111.data[72],CS[134][0].E);/*,ZERO_SUPPRESS_ITEM(CS[134],0)*/
SIGNAL_MAPPING(DATA12,CS135_1_T,fastbus1.T87024.data[8],CS[134][0].T);/*,ZERO_SUPPRESS_ITEM(CS[134],0)*/
SIGNAL_MAPPING(DATA12,CS136_1_E,fastbus1.Q47342.data[37],CS[135][0].E);/*,ZERO_SUPPRESS_ITEM(CS[135],0)*/
SIGNAL_MAPPING(DATA12,CS136_1_T,fastbus1.T87044.data[5],CS[135][0].T);/*,ZERO_SUPPRESS_ITEM(CS[135],0)*/
SIGNAL_MAPPING(DATA12,CS137_1_E,fastbus1.Q47342.data[39],CS[136][0].E);/*,ZERO_SUPPRESS_ITEM(CS[136],0)*/
SIGNAL_MAPPING(DATA12,CS137_1_T,fastbus1.T87044.data[7],CS[136][0].T);/*,ZERO_SUPPRESS_ITEM(CS[136],0)*/
SIGNAL_MAPPING(DATA12,CS138_1_E,fastbus1.Q47342.data[41],CS[137][0].E);/*,ZERO_SUPPRESS_ITEM(CS[137],0)*/
SIGNAL_MAPPING(DATA12,CS138_1_T,fastbus1.T87044.data[9],CS[137][0].T);/*,ZERO_SUPPRESS_ITEM(CS[137],0)*/
SIGNAL_MAPPING(DATA12,CS139_1_E,fastbus1.Q47342.data[43],CS[138][0].E);/*,ZERO_SUPPRESS_ITEM(CS[138],0)*/
SIGNAL_MAPPING(DATA12,CS139_1_T,fastbus1.T87044.data[11],CS[138][0].T);/*,ZERO_SUPPRESS_ITEM(CS[138],0)*/
SIGNAL_MAPPING(DATA12,CS140_1_E,fastbus1.Q47342.data[45],CS[139][0].E);/*,ZERO_SUPPRESS_ITEM(CS[139],0)*/
SIGNAL_MAPPING(DATA12,CS140_1_T,fastbus1.T87044.data[13],CS[139][0].T);/*,ZERO_SUPPRESS_ITEM(CS[139],0)*/
SIGNAL_MAPPING(DATA12,CS141_1_E,fastbus1.Q47342.data[47],CS[140][0].E);/*,ZERO_SUPPRESS_ITEM(CS[140],0)*/
SIGNAL_MAPPING(DATA12,CS141_1_T,fastbus1.T87044.data[15],CS[140][0].T);/*,ZERO_SUPPRESS_ITEM(CS[140],0)*/
SIGNAL_MAPPING(DATA12,CS142_1_E,fastbus1.Q11111.data[74],CS[141][0].E);/*,ZERO_SUPPRESS_ITEM(CS[141],0)*/
SIGNAL_MAPPING(DATA12,CS142_1_T,fastbus1.T87024.data[10],CS[141][0].T);/*,ZERO_SUPPRESS_ITEM(CS[141],0)*/
SIGNAL_MAPPING(DATA12,CS143_1_E,fastbus1.Q11111.data[76],CS[142][0].E);/*,ZERO_SUPPRESS_ITEM(CS[142],0)*/
SIGNAL_MAPPING(DATA12,CS143_1_T,fastbus1.T87024.data[12],CS[142][0].T);/*,ZERO_SUPPRESS_ITEM(CS[142],0)*/
SIGNAL_MAPPING(DATA12,CS144_1_E,fastbus1.Q11111.data[78],CS[143][0].E);/*,ZERO_SUPPRESS_ITEM(CS[143],0)*/
SIGNAL_MAPPING(DATA12,CS144_1_T,fastbus1.T87024.data[14],CS[143][0].T);/*,ZERO_SUPPRESS_ITEM(CS[143],0)*/
SIGNAL_MAPPING(DATA12,CS145_1_E,fastbus1.Q47342.data[48],CS[144][0].E);/*,ZERO_SUPPRESS_ITEM(CS[144],0)*/
SIGNAL_MAPPING(DATA12,CS145_1_T,fastbus1.T87024.data[32],CS[144][0].T);/*,ZERO_SUPPRESS_ITEM(CS[144],0)*/
SIGNAL_MAPPING(DATA12,CS146_1_E,fastbus1.Q47342.data[50],CS[145][0].E);/*,ZERO_SUPPRESS_ITEM(CS[145],0)*/
SIGNAL_MAPPING(DATA12,CS146_1_T,fastbus1.T87024.data[34],CS[145][0].T);/*,ZERO_SUPPRESS_ITEM(CS[145],0)*/
SIGNAL_MAPPING(DATA12,CS147_1_E,fastbus1.Q47342.data[52],CS[146][0].E);/*,ZERO_SUPPRESS_ITEM(CS[146],0)*/
SIGNAL_MAPPING(DATA12,CS147_1_T,fastbus1.T87024.data[36],CS[146][0].T);/*,ZERO_SUPPRESS_ITEM(CS[146],0)*/
SIGNAL_MAPPING(DATA12,CS148_1_E,fastbus1.Q47342.data[54],CS[147][0].E);/*,ZERO_SUPPRESS_ITEM(CS[147],0)*/
SIGNAL_MAPPING(DATA12,CS148_1_T,fastbus1.T87024.data[38],CS[147][0].T);/*,ZERO_SUPPRESS_ITEM(CS[147],0)*/
SIGNAL_MAPPING(DATA12,CS149_1_E,fastbus1.Q47342.data[56],CS[148][0].E);/*,ZERO_SUPPRESS_ITEM(CS[148],0)*/
SIGNAL_MAPPING(DATA12,CS149_1_T,fastbus1.T87024.data[40],CS[148][0].T);/*,ZERO_SUPPRESS_ITEM(CS[148],0)*/
SIGNAL_MAPPING(DATA12,CS150_1_E,fastbus1.Q47342.data[58],CS[149][0].E);/*,ZERO_SUPPRESS_ITEM(CS[149],0)*/
SIGNAL_MAPPING(DATA12,CS150_1_T,fastbus1.T87024.data[42],CS[149][0].T);/*,ZERO_SUPPRESS_ITEM(CS[149],0)*/
SIGNAL_MAPPING(DATA12,CS151_1_E,fastbus1.Q47342.data[49],CS[150][0].E);/*,ZERO_SUPPRESS_ITEM(CS[150],0)*/
SIGNAL_MAPPING(DATA12,CS151_1_T,fastbus1.T87024.data[33],CS[150][0].T);/*,ZERO_SUPPRESS_ITEM(CS[150],0)*/
SIGNAL_MAPPING(DATA12,CS152_1_E,fastbus1.Q47342.data[51],CS[151][0].E);/*,ZERO_SUPPRESS_ITEM(CS[151],0)*/
SIGNAL_MAPPING(DATA12,CS152_1_T,fastbus1.T87024.data[35],CS[151][0].T);/*,ZERO_SUPPRESS_ITEM(CS[151],0)*/
SIGNAL_MAPPING(DATA12,CS153_1_E,fastbus1.Q47342.data[53],CS[152][0].E);/*,ZERO_SUPPRESS_ITEM(CS[152],0)*/
SIGNAL_MAPPING(DATA12,CS153_1_T,fastbus1.T87024.data[37],CS[152][0].T);/*,ZERO_SUPPRESS_ITEM(CS[152],0)*/
SIGNAL_MAPPING(DATA12,CS154_1_E,fastbus1.Q47342.data[55],CS[153][0].E);/*,ZERO_SUPPRESS_ITEM(CS[153],0)*/
SIGNAL_MAPPING(DATA12,CS154_1_T,fastbus1.T87024.data[39],CS[153][0].T);/*,ZERO_SUPPRESS_ITEM(CS[153],0)*/
SIGNAL_MAPPING(DATA12,CS155_1_E,fastbus1.Q47342.data[57],CS[154][0].E);/*,ZERO_SUPPRESS_ITEM(CS[154],0)*/
SIGNAL_MAPPING(DATA12,CS155_1_T,fastbus1.T87024.data[41],CS[154][0].T);/*,ZERO_SUPPRESS_ITEM(CS[154],0)*/

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gen_s232/reparse.uce" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gen_s232/reparse.uce" },
  { 8, 12, "gen_s232/reparse.uce" },
  { 737, 749, "gen_s232/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/

