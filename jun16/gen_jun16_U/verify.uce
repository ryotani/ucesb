
/** BEGIN_INPUT_DEFINITION *********************************************
 *
 * All specifications as seen by the parser.
 *
 * Do not edit - automatically generated.
 */

/**********************************************************
 * Dump of all structures:
 */

BARRIER()
{
  UINT32 barrier
  {
     0_31: 0xbabababa;
  }
}

FEBEX_BAD_EVENTHEADER()
{
  UINT32 badbad
  {
     0_31: 0xbad00bad;
  }
}

FEBEX_EVENTHEADER()
{
  select
  {
    good = FEBEX_GOOD_EVENTHEADER();
    bad = FEBEX_BAD_EVENTHEADER();
  }
}

FEBEX_GOOD_EVENTHEADER()
{
  UINT32 febexcards
  {
     0_07: n_febex_sfp0 = RANGE(0,64);
     8_15: n_febex_sfp1 = RANGE(0,64);
    16_23: n_febex_sfp2 = RANGE(0,64);
    24_31: n_febex_sfp3 = RANGE(0,64);
  }
  UINT32 trig_length
  {
     0_15: trace_length;
    16_31: trigger_delay;
  }
  UINT32 energy_filter
  {
     0_10: sum_b;
    11_20: gap;
    21_31: sum_a;
  }
  UINT32 polarity1
  {
     0_31: pola;
  }
  UINT32 polarity2
  {
     0_31: pola;
  }
  UINT32 polarity3
  {
     0_31: pola;
  }
  UINT32 polarity4
  {
     0_31: pola;
  }
}

FEBEX_NOTRACE(sfp,card)
{
  MEMBER(DATA8 n_hit[16]);
  MEMBER(DATA12 t[16] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA32 e[16] ZERO_SUPPRESS_MULTI(32));
  UINT32 indicator NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfp = MATCH(sfp);
    16_23: card = MATCH(card);
    24_31: 255;
  }
  UINT32 data_size NOENCODE
  {
     0_31: size;
  }
  UINT32 head NOENCODE
  {
     0_23: unused;
    24_31: 175;
  }
  UINT32 triggertime NOENCODE
  {
     0_31: trigger_time;
  }
  UINT32 time NOENCODE
  {
     0_31: time;
  }
  list(0<=i<((data_size.size - 16) >> 3))
  {
    UINT32 time NOENCODE
    {
       0_10: time;
      11_14: unused1;
         15: sign;
      16_19: unused2;
      20_23: multi_hit;
      24_27: n_hit;
      28_31: channel_id;
      ENCODE(t[channel_id],(value=((time | (sign << 11)) & 0xfff)));
      ENCODE(n_hit[channel_id],(value=n_hit));
    }
    UINT32 energy NOENCODE
    {
       0_21: energy;
         22: unused1;
         23: sign;
      24_27: unused2;
      28_31: channel_id;
      ENCODE(e[channel_id],(value=(energy | (sign << 23))));
    }
  }
  UINT32 trailer NOENCODE
  {
     0_23: unused;
    24_31: 191;
  }
}

FEBEX_PADDING()
{
  UINT32 pads_data NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

FEBEX_TRACE(sfp,card)
{
  MEMBER(DATA32 trace_length[16] ZERO_SUPPRESS);
  MEMBER(DATA16 trace[16][1000] ZERO_SUPPRESS);
  MEMBER(DATA32 filter[16][1000] ZERO_SUPPRESS);
  UINT32 header NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfp = MATCH(sfp);
    16_23: card = MATCH(card);
    24_31: channel_id = RANGE(0,254);
  }
  UINT32 trace_size NOENCODE
  {
     0_31: size;
    ENCODE(trace_length[header.channel_id],(value=((size / 2) - 4)));
  }
  UINT32 trace_header NOENCODE
  {
     0_17: notused1;
       18: filter_mode;
       19: filter_onoff;
    20_22: notused2;
       23: adc_type;
    24_31: 170;
  }
  if((trace_header.filter_onoff == 0))
  {
    list(0<=i<((trace_size.size / 4) - 2))
    {
      UINT32 channel_trace NOENCODE
      {
         0_13: data1;
        14_15: nik_knows;
        16_29: data2;
        30_31: nik_knows2;
        ENCODE(trace[header.channel_id][((2 * i) + 0)],(value=data1));
        ENCODE(trace[header.channel_id][((2 * i) + 1)],(value=data2));
      }
    }
  }
  else
  {
    list(0<=i<((trace_size.size / 8) - 1))
    {
      UINT32 channel_trace NOENCODE
      {
         0_13: data1;
        14_31: nik_knows;
        ENCODE(trace[header.channel_id][i],(value=data1));
      }
      UINT32 channel_filter NOENCODE
      {
         0_22: data1;
           23: sign;
        24_31: nik_knows2;
        ENCODE(filter[header.channel_id][i],(value=(data1 * (1 - (2 * sign)))));
      }
    }
  }
  UINT32 trace_trailer NOENCODE
  {
     0_23: notused;
    24_31: 187;
  }
}

LAND_STD_VME()
{
  UINT32 failure
  {
        0: fail_general;
        1: fail_data_corrupt;
        2: fail_data_missing;
        3: fail_data_too_much;
        4: fail_event_counter_mismatch;
        5: fail_readout_error_driver;
        6: fail_unexpected_trigger;
        7: fail_firmware_mismatch;
       22: has_multi_trlo_ii_counter0;
       23: has_clock_counter_stamp;
       24: has_continous_event_counter;
       25: has_update_qdc_iped_value;
       26: spurious_start_before_tcal;
       27: has_no_zero_suppression;
       28: has_multi_adctdc_counter0;
       29: has_multi_scaler_counter0;
       30: has_multi_event;
       31: has_time_stamp;
  }
  if(failure.has_continous_event_counter)
  {
    UINT32 continous_event_counter;
  }
  if(failure.has_time_stamp)
  {
    UINT32 time_stamp;
  }
  if(failure.has_clock_counter_stamp)
  {
    UINT32 clock_counter_stamp;
  }
  if(failure.has_update_qdc_iped_value)
  {
    UINT32 iped;
  }
  if(failure.has_multi_event)
  {
    UINT32 multi_events;
  }
  if(failure.has_multi_trlo_ii_counter0)
  {
    UINT32 multi_trlo_ii_counter0;
  }
  if(failure.has_multi_scaler_counter0)
  {
    UINT32 multi_scaler_counter0;
  }
  if(failure.has_multi_adctdc_counter0)
  {
    UINT32 multi_adctdc_counter0;
  }
}

SCALER()
{
  UINT32 scaler;
}

TAMEX3_HEADER()
{
  UINT32 trigger_window
  {
     0_15: post_trig_ns;
    16_31: pre_trig_ns;
  }
}

TAMEX3_PADDING()
{
  UINT32 padding NOENCODE
  {
     0_11: counter;
    12_19: index;
    20_31: 0xadd;
  }
}

TAMEX3_SFP(sfp,card)
{
  MEMBER(DATA16 time_coarse[34] ZERO_SUPPRESS_MULTI(200));
  MEMBER(DATA12 time_fine[34] ZERO_SUPPRESS_MULTI(200));
  UINT32 indicator NOENCODE
  {
     0_07: 52;
     8_11: trigger_type;
    12_15: sfp = MATCH(sfp);
    16_23: card = MATCH(card);
    24_31: 0;
  }
  MATCH_END;
  UINT32 data_size NOENCODE
  {
     0_31: bytes;
  }
  UINT32 tdc_header NOENCODE
  {
     0_15: lec;
       16: buf_no;
    17_19: reserved;
    20_23: trigger_type;
    24_31: 170;
  }
  list(0<=i<((data_size.bytes / 4) - 3))
  {
    UINT32 data NOENCODE
    {
       0_10: coarse;
         11: is_leading;
      12_21: fine;
      22_28: channel_index;
      29_31: type;
      ENCODE(time_coarse[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=coarse));
      ENCODE(time_fine[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=fine));
    }
  }
  UINT32 error_bits NOENCODE
  {
     0_23: bits;
    24_31: 238;
  }
  UINT32 trailer NOENCODE
  {
     0_23: unused;
    24_31: 187;
  }
}

TIMESTAMP_WHITERABBIT(id)
{
  MEMBER(DATA12 subsystem_id);
  MEMBER(DATA16 t1);
  MEMBER(DATA16 t2);
  MEMBER(DATA16 t3);
  MEMBER(DATA16 t4);
  UINT32 header NOENCODE
  {
     0_11: id = MATCH(id);
    12_15: 0;
       16: error_bit;
    17_31: 0;
    ENCODE(subsystem_id,(value=id));
  }
  UINT32 d1 NOENCODE
  {
     0_15: t1;
    16_31: 0x3e1;
    ENCODE(t1,(value=t1));
  }
  UINT32 d2 NOENCODE
  {
     0_15: t2;
    16_31: 0x4e1;
    ENCODE(t2,(value=t2));
  }
  UINT32 d3 NOENCODE
  {
     0_15: t3;
    16_31: 0x5e1;
    ENCODE(t3,(value=t3));
  }
  UINT32 d4 NOENCODE
  {
     0_15: t4;
    16_31: 0x6e1;
    ENCODE(t4,(value=t4));
  }
}

TRLOII_LMU_SCALERS(id)
{
  MEMBER(DATA32 before_lmu[63] ZERO_SUPPRESS);
  MEMBER(DATA32 before_lmu_mux[31] ZERO_SUPPRESS);
  MEMBER(DATA32 before_lmu_aux[31] ZERO_SUPPRESS);
  MEMBER(DATA32 before_dt[127] ZERO_SUPPRESS);
  MEMBER(DATA32 after_dt[127] ZERO_SUPPRESS);
  MEMBER(DATA32 after_reduction[127] ZERO_SUPPRESS);
  UINT32 header
  {
     0_05: before_lmu;
     6_10: before_lmu_mux;
    11_15: before_lmu_aux;
    16_23: after_lmu;
    24_31: id = MATCH(id);
  }
  list(0<=i<header.before_lmu)
  {
    UINT32 scaler NOENCODE
    {
       0_31: value;
      ENCODE(before_lmu[i],(value=value));
    }
  }
  list(0<=i<header.before_lmu_mux)
  {
    UINT32 scaler NOENCODE
    {
       0_31: value;
      ENCODE(before_lmu_mux[i],(value=value));
    }
  }
  list(0<=i<header.before_lmu_aux)
  {
    UINT32 scaler NOENCODE
    {
       0_31: value;
      ENCODE(before_lmu_aux[i],(value=value));
    }
  }
  list(0<=i<header.after_lmu)
  {
    UINT32 scaler_bdt NOENCODE
    {
       0_31: value;
      ENCODE(before_dt[i],(value=value));
    }
    UINT32 scaler_adt NOENCODE
    {
       0_31: value;
      ENCODE(after_dt[i],(value=value));
    }
    UINT32 scaler_ard NOENCODE
    {
       0_31: value;
      ENCODE(after_reduction[i],(value=value));
    }
  }
}

TRLOII_SAMPLER(mark)
{
  MEMBER(DATA32 sampler[512] ZERO_SUPPRESS);
  UINT32 header
  {
     0_09: word_num;
       10: overflow;
    16_31: mark = MATCH(mark);
  }
  list(0<=index<header.word_num)
  {
    UINT32 time_lo NOENCODE
    {
       0_29: time;
         30: dunno;
         31: overflow;
      ENCODE(sampler[index],(value=time));
    }
  }
}

TRLOII_SAMPLER_TWO(mark)
{
  MEMBER(DATA32 sampler_hi[512] ZERO_SUPPRESS);
  MEMBER(DATA32 sampler_lo[512] ZERO_SUPPRESS);
  UINT32 header
  {
     0_09: word_num;
       10: overflow;
    16_31: mark = MATCH(mark);
  }
  list(0<=index<(header.word_num / 2))
  {
    UINT32 time_lo NOENCODE
    {
       0_29: time;
         30: dunno;
         31: overflow;
      ENCODE(sampler_lo[index],(value=time));
    }
    UINT32 time_hi NOENCODE
    {
       0_29: time;
         30: dunno;
         31: overflow;
      ENCODE(sampler_hi[index],(value=time));
    }
  }
  if(((header.word_num % 2) == 1))
  {
    UINT32 last_word NOENCODE;
  }
}

TRLOII_TPAT(id)
{
  MEMBER(DATA32 n);
  MEMBER(DATA16 tpat[170] NO_INDEX_LIST);
  MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  UINT32 header NOENCODE
  {
     0_11: uint32_num;
    12_23: event_num;
    24_31: id = MATCH(id);
    ENCODE(n,(value=(uint32_num / 3)));
  }
  list(0<=index<(header.uint32_num / 3))
  {
    UINT32 time_lo NOENCODE
    {
       0_31: t;
      ENCODE(ts_lo APPEND_LIST,(value=t));
    }
    UINT32 time_hi NOENCODE
    {
       0_30: t;
         31: overflow;
      ENCODE(ts_hi APPEND_LIST,(value=t));
    }
    UINT32 trigger NOENCODE
    {
       0_15: tpat;
      16_23: dunno;
      24_27: encoded;
      28_31: lec;
      ENCODE(tpat APPEND_LIST,(value=tpat));
      ENCODE(trig APPEND_LIST,(value=encoded));
    }
  }
}

VFTX2_STATUS()
{
  UINT32 status;
}

VME_GSI_VFTX2(id)
{
  MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_trigger);
  UINT32 custom_header
  {
     0_04: id = MATCH(id);
     5_08: internal_status;
     9_17: count;
    24_31: 171;
  }
  if((0 < custom_header.count))
  {
    UINT32 event_header
    {
       0_07: 170;
      11_23: trigger_timestamp;
      29_30: 1;
         31: 1;
      ENCODE(time_trigger,(value=trigger_timestamp));
    }
  }
  list(1<=index<custom_header.count)
  {
    UINT32 event NOENCODE
    {
       0_10: time_fine;
      11_23: time_coarse;
         24: future;
      25_29: channel;
      ENCODE(time_fine[channel],(value=time_fine));
      ENCODE(time_coarse[channel],(value=time_coarse));
    }
  }
}

VME_GSI_VFTX2_7PS(id)
{
  MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_trigger);
  UINT32 custom_header
  {
     0_04: id = MATCH(id);
     5_08: internal_status;
     9_17: count;
    24_31: 171;
  }
  if((0 < custom_header.count))
  {
    UINT32 event_header NOENCODE
    {
       0_07: 170;
      11_23: trigger_timestamp;
      29_30: 1;
         31: 1;
      ENCODE(time_trigger,(value=trigger_timestamp));
    }
  }
  list(1<=index<custom_header.count)
  {
    UINT32 event NOENCODE
    {
       0_10: time_fine;
      11_23: time_coarse;
         24: future;
      25_29: channel;
      ENCODE(time_fine[channel],(value=time_fine));
      ENCODE(time_coarse[channel],(value=time_coarse));
    }
  }
}

VME_GSI_VFTX2_LT(id)
{
  MEMBER(DATA12 time_fine[64] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_coarse[64] ZERO_SUPPRESS_MULTI(100));
  MEMBER(DATA16 time_trigger);
  UINT32 custom_header
  {
     0_04: id = MATCH(id);
     5_08: internal_status;
     9_17: count;
    24_31: 171;
  }
  if((0 < custom_header.count))
  {
    UINT32 event_header
    {
       0_07: 170;
      11_23: trigger_timestamp;
      29_30: 1;
         31: 1;
      ENCODE(time_trigger,(value=trigger_timestamp));
    }
  }
  list(1<=index<custom_header.count)
  {
    UINT32 event NOENCODE
    {
       0_10: time_fine;
      11_23: time_coarse;
         24: future;
      25_30: channel;
      ENCODE(time_fine[channel],(value=time_fine));
      ENCODE(time_coarse[channel],(value=time_coarse));
    }
  }
}

VME_GSI_VFTX2_STRAW(id)
{
  MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(32));
  MEMBER(DATA16 time_trigger);
  UINT32 status
  {
     0_03: internal;
     4_12: count;
  }
  UINT32 custom_header
  {
     0_15: count;
    16_23: id = MATCH(id);
    24_31: 171;
  }
  UINT32 event_header
  {
     0_07: 170;
    11_23: trigger_timestamp;
    29_30: 1;
       31: 1;
    ENCODE(time_trigger,(value=trigger_timestamp));
  }
  list(0<=index<custom_header.count)
  {
    UINT32 event NOENCODE
    {
       0_10: time_fine;
      11_23: time_coarse;
         24: future;
      25_30: channel;
         31: bluppidupp;
      ENCODE(time_fine[channel],(value=time_fine));
      ENCODE(time_coarse[channel],(value=time_coarse));
    }
  }
}

VME_MESYTEC_MADC32(geom)
{
  MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  MARK_COUNT(start);
  UINT32 header NOENCODE
  {
     0_11: word_number;
    12_14: adc_resol;
       15: out_form;
    16_23: geom = MATCH(geom);
    24_29: 0;
    30_31: 1;
  }
  several UINT32 ch_data NOENCODE
  {
     0_12: value;
       14: outofrange;
    16_20: channel;
    21_29: 32;
    30_31: 0;
    ENCODE(data[channel],(value=value,overflow=outofrange));
  }
  optional UINT32 filler NOENCODE
  {
     0_31: 0;
  }
  UINT32 end_of_event
  {
     0_29: counter;
    30_31: 3;
  }
  MARK_COUNT(end);
  CHECK_COUNT(header.word_number,start,end,( - 4),4)
}

WR_MULTI()
{
  MEMBER(DATA32 time_hi);
  MEMBER(DATA32 time_lo);
  UINT32 hi NOENCODE
  {
     0_31: time;
    ENCODE(time_hi,(value=time));
  }
  UINT32 lo NOENCODE
  {
     0_31: time;
    ENCODE(time_lo,(value=time));
  }
}

SUBEVENT(empty_subev)
{
  ;
}

SUBEVENT(fitest_febex_subev)
{
  header = FEBEX_EVENTHEADER();
  select several
  {
    padding = FEBEX_PADDING();
  }
  select several
  {
    febex[0] = FEBEX_NOTRACE(sfp=3,card=0);
    febex[1] = FEBEX_NOTRACE(sfp=3,card=1);
    febex[2] = FEBEX_NOTRACE(sfp=3,card=2);
    febex[3] = FEBEX_NOTRACE(sfp=3,card=3);
    febex[4] = FEBEX_NOTRACE(sfp=3,card=4);
    febex[5] = FEBEX_NOTRACE(sfp=3,card=5);
    febex[6] = FEBEX_NOTRACE(sfp=3,card=6);
    febex[7] = FEBEX_NOTRACE(sfp=3,card=7);
    febextrace[0] = FEBEX_TRACE(sfp=3,card=0);
    febextrace[1] = FEBEX_TRACE(sfp=3,card=1);
    febextrace[2] = FEBEX_TRACE(sfp=3,card=2);
    febextrace[3] = FEBEX_TRACE(sfp=3,card=3);
    febextrace[4] = FEBEX_TRACE(sfp=3,card=4);
    febextrace[5] = FEBEX_TRACE(sfp=3,card=5);
    febextrace[6] = FEBEX_TRACE(sfp=3,card=6);
    febextrace[7] = FEBEX_TRACE(sfp=3,card=7);
  }
}

SUBEVENT(lmu_scalers_subev)
{
  scalers = TRLOII_LMU_SCALERS(id=199);
}

SUBEVENT(los_sampler_subev)
{
  land_vme = LAND_STD_VME();
  select several
  {
    sampler = TRLOII_SAMPLER(mark=0x1050);
  }
}

SUBEVENT(los_scalers_subev)
{
  select several
  {
    scaler = SCALER();
  }
}

SUBEVENT(los_subev)
{
  land_vme = LAND_STD_VME();
  barrier1 = BARRIER();
  barrier2 = BARRIER();
  select several
  {
    vftx2 = VME_GSI_VFTX2_7PS(id=2);
  }
}

SUBEVENT(master_subev)
{
  land_vme = LAND_STD_VME();
  barrier = BARRIER();
}

SUBEVENT(straw_vme_subev)
{
  select several
  {
    vftx2 = VME_GSI_VFTX2_STRAW(id=0);
  }
}

SUBEVENT(tbm_subev)
{
  land_vme = LAND_STD_VME();
}

SUBEVENT(tofd_tamex_subev)
{
  header = TAMEX3_HEADER();
  select several
  {
    padding1 = TAMEX3_PADDING();
  }
  select several
  {
    tamex_1 = TAMEX3_SFP(sfp=2,card=0);
    tamex_2 = TAMEX3_SFP(sfp=2,card=1);
  }
  select several
  {
    padding2 = TAMEX3_PADDING();
  }
  select several
  {
    tamex_3 = TAMEX3_SFP(sfp=3,card=0);
    tamex_4 = TAMEX3_SFP(sfp=3,card=1);
  }
}

SUBEVENT(tofd_vme_subev)
{
  land_vme = LAND_STD_VME();
  barrier = BARRIER();
  select several
  {
    vftx2_1 = VME_GSI_VFTX2_7PS(id=1);
    vftx2_2 = VME_GSI_VFTX2_7PS(id=2);
    vftx2_3 = VME_GSI_VFTX2_7PS(id=3);
  }
}

SUBEVENT(tpat_subev)
{
  tpat = TRLOII_TPAT(id=207);
}

SUBEVENT(tracking_febex_subev)
{
  header0 = FEBEX_EVENTHEADER();
  select several
  {
    febex_0[0] = FEBEX_NOTRACE(sfp=0,card=0);
    febex_0[1] = FEBEX_NOTRACE(sfp=0,card=1);
    febex_0[2] = FEBEX_NOTRACE(sfp=0,card=2);
    febex_0[3] = FEBEX_NOTRACE(sfp=0,card=3);
    febex_0[4] = FEBEX_NOTRACE(sfp=0,card=4);
    febex_0[5] = FEBEX_NOTRACE(sfp=0,card=5);
    febex_0[6] = FEBEX_NOTRACE(sfp=0,card=6);
    febex_0[7] = FEBEX_NOTRACE(sfp=0,card=7);
    febex_0[8] = FEBEX_NOTRACE(sfp=0,card=8);
    febex_0[9] = FEBEX_NOTRACE(sfp=0,card=9);
  }
  header2 = FEBEX_EVENTHEADER();
  select several
  {
    febex_2[0] = FEBEX_NOTRACE(sfp=2,card=0);
    febex_2[1] = FEBEX_NOTRACE(sfp=2,card=1);
    febex_2[2] = FEBEX_NOTRACE(sfp=2,card=2);
    febex_2[3] = FEBEX_NOTRACE(sfp=2,card=3);
    febex_2[4] = FEBEX_NOTRACE(sfp=2,card=4);
    febex_2[5] = FEBEX_NOTRACE(sfp=2,card=5);
    febex_2[6] = FEBEX_NOTRACE(sfp=2,card=6);
    febex_2[7] = FEBEX_NOTRACE(sfp=2,card=7);
    febex_2[8] = FEBEX_NOTRACE(sfp=2,card=8);
    febex_2[9] = FEBEX_NOTRACE(sfp=2,card=9);
    febex_2[10] = FEBEX_NOTRACE(sfp=2,card=10);
    febex_2[11] = FEBEX_NOTRACE(sfp=2,card=11);
  }
}

SUBEVENT(wr_100)
{
  ts100 = TIMESTAMP_WHITERABBIT(id=0x100);
  multi_ = WR_MULTI();
}

SUBEVENT(wr_200)
{
  ts200 = TIMESTAMP_WHITERABBIT(id=0x200);
  multi_ = WR_MULTI();
}

SUBEVENT(wr_400)
{
  ts400 = TIMESTAMP_WHITERABBIT(id=0x400);
}

/**********************************************************
 * The event definition:
 */

EVENT
{
  master_ts = wr_100(type=10,subtype=1,control=0);
  master_tpat = tpat_subev(type=36,subtype=0xe10,control=0);
  master_lmu_scalers = lmu_scalers_subev(type=37,subtype=0xe74,control=0);
  master_vme = master_subev(type=88,subtype=0x2260,control=0);
  los = los_subev(type=88,subtype=0x2260,control=1);
  los_scalers = los_scalers_subev(type=38,subtype=0xed8,control=1);
  los_sampler = los_sampler_subev(type=39,subtype=0xf3c,control=1);
  tofd_vme = tofd_vme_subev(type=88,subtype=0x2260,control=2);
  tbm_ts = wr_200(type=10,subtype=1,control=3);
  tbm_tpat = tpat_subev(type=36,subtype=0xe10,control=3);
  tbm_vme = tbm_subev(type=88,subtype=0x2260,control=3);
  tofd_tamex = tofd_tamex_subev(type=102,subtype=0x27d8,control=4);
  tracking_febex = tracking_febex_subev(type=100,subtype=0x2710,control=5);
  los_empty = empty_subev(type=10,subtype=1,control=1);
  tofd_empty = empty_subev(type=10,subtype=1,control=2);
}

/**********************************************************
 * The sticky_event definition:
 */

/**********************************************************
 * Signal name mappings:
 */

SIGNAL(TIMESTAMP_MASTER_HI,master_ts.multi_.time_hi,DATA32);
SIGNAL(TIMESTAMP_MASTER_ID,master_ts.ts100.subsystem_id,DATA12);
SIGNAL(TIMESTAMP_MASTER_LO,master_ts.multi_.time_lo,DATA32);
SIGNAL(TIMESTAMP_MASTER_WR_T1,master_ts.ts100.t1,DATA16);
SIGNAL(TIMESTAMP_MASTER_WR_T2,master_ts.ts100.t2,DATA16);
SIGNAL(TIMESTAMP_MASTER_WR_T3,master_ts.ts100.t3,DATA16);
SIGNAL(TIMESTAMP_MASTER_WR_T4,master_ts.ts100.t4,DATA16);
SIGNAL(TOFD_P1T1_TCL1,tofd_vme.vftx2_1.time_coarse[0],DATA16);
SIGNAL(TOFD_P1T1_TCL2,tofd_vme.vftx2_1.time_coarse[4],DATA16);
SIGNAL(TOFD_P1T1_TCL3,tofd_vme.vftx2_1.time_coarse[8],DATA16);
SIGNAL(TOFD_P1T1_TCL4,tofd_vme.vftx2_1.time_coarse[12],DATA16);
SIGNAL(TOFD_P1T1_TCL5,tofd_vme.vftx2_2.time_coarse[0],DATA16);
SIGNAL(TOFD_P1T1_TCL6,tofd_vme.vftx2_2.time_coarse[4],DATA16);
SIGNAL(TOFD_P1T1_TCT1,tofd_vme.vftx2_1.time_coarse[1],DATA16);
SIGNAL(TOFD_P1T1_TCT2,tofd_vme.vftx2_1.time_coarse[5],DATA16);
SIGNAL(TOFD_P1T1_TCT3,tofd_vme.vftx2_1.time_coarse[9],DATA16);
SIGNAL(TOFD_P1T1_TCT4,tofd_vme.vftx2_1.time_coarse[13],DATA16);
SIGNAL(TOFD_P1T1_TCT5,tofd_vme.vftx2_2.time_coarse[1],DATA16);
SIGNAL(TOFD_P1T1_TCT6,tofd_vme.vftx2_2.time_coarse[5],DATA16);
SIGNAL(TOFD_P1T1_TFL1,tofd_vme.vftx2_1.time_fine[0],DATA12);
SIGNAL(TOFD_P1T1_TFL2,tofd_vme.vftx2_1.time_fine[4],DATA12);
SIGNAL(TOFD_P1T1_TFL3,tofd_vme.vftx2_1.time_fine[8],DATA12);
SIGNAL(TOFD_P1T1_TFL4,tofd_vme.vftx2_1.time_fine[12],DATA12);
SIGNAL(TOFD_P1T1_TFL5,tofd_vme.vftx2_2.time_fine[0],DATA12);
SIGNAL(TOFD_P1T1_TFL6,tofd_vme.vftx2_2.time_fine[4],DATA12);
SIGNAL(TOFD_P1T1_TFT1,tofd_vme.vftx2_1.time_fine[1],DATA12);
SIGNAL(TOFD_P1T1_TFT2,tofd_vme.vftx2_1.time_fine[5],DATA12);
SIGNAL(TOFD_P1T1_TFT3,tofd_vme.vftx2_1.time_fine[9],DATA12);
SIGNAL(TOFD_P1T1_TFT4,tofd_vme.vftx2_1.time_fine[13],DATA12);
SIGNAL(TOFD_P1T1_TFT5,tofd_vme.vftx2_2.time_fine[1],DATA12);
SIGNAL(TOFD_P1T1_TFT6,tofd_vme.vftx2_2.time_fine[5],DATA12);
SIGNAL(TOFD_P1T2_TCL1,tofd_vme.vftx2_1.time_coarse[2],DATA16);
SIGNAL(TOFD_P1T2_TCL2,tofd_vme.vftx2_1.time_coarse[6],DATA16);
SIGNAL(TOFD_P1T2_TCL3,tofd_vme.vftx2_1.time_coarse[10],DATA16);
SIGNAL(TOFD_P1T2_TCL4,tofd_vme.vftx2_1.time_coarse[14],DATA16);
SIGNAL(TOFD_P1T2_TCL5,tofd_vme.vftx2_2.time_coarse[2],DATA16);
SIGNAL(TOFD_P1T2_TCL6,tofd_vme.vftx2_2.time_coarse[6],DATA16);
SIGNAL(TOFD_P1T2_TCT1,tofd_vme.vftx2_1.time_coarse[3],DATA16);
SIGNAL(TOFD_P1T2_TCT2,tofd_vme.vftx2_1.time_coarse[7],DATA16);
SIGNAL(TOFD_P1T2_TCT3,tofd_vme.vftx2_1.time_coarse[11],DATA16);
SIGNAL(TOFD_P1T2_TCT4,tofd_vme.vftx2_1.time_coarse[15],DATA16);
SIGNAL(TOFD_P1T2_TCT5,tofd_vme.vftx2_2.time_coarse[3],DATA16);
SIGNAL(TOFD_P1T2_TCT6,tofd_vme.vftx2_2.time_coarse[7],DATA16);
SIGNAL(TOFD_P1T2_TFL1,tofd_vme.vftx2_1.time_fine[2],DATA12);
SIGNAL(TOFD_P1T2_TFL2,tofd_vme.vftx2_1.time_fine[6],DATA12);
SIGNAL(TOFD_P1T2_TFL3,tofd_vme.vftx2_1.time_fine[10],DATA12);
SIGNAL(TOFD_P1T2_TFL4,tofd_vme.vftx2_1.time_fine[14],DATA12);
SIGNAL(TOFD_P1T2_TFL5,tofd_vme.vftx2_2.time_fine[2],DATA12);
SIGNAL(TOFD_P1T2_TFL6,tofd_vme.vftx2_2.time_fine[6],DATA12);
SIGNAL(TOFD_P1T2_TFT1,tofd_vme.vftx2_1.time_fine[3],DATA12);
SIGNAL(TOFD_P1T2_TFT2,tofd_vme.vftx2_1.time_fine[7],DATA12);
SIGNAL(TOFD_P1T2_TFT3,tofd_vme.vftx2_1.time_fine[11],DATA12);
SIGNAL(TOFD_P1T2_TFT4,tofd_vme.vftx2_1.time_fine[15],DATA12);
SIGNAL(TOFD_P1T2_TFT5,tofd_vme.vftx2_2.time_fine[3],DATA12);
SIGNAL(TOFD_P1T2_TFT6,tofd_vme.vftx2_2.time_fine[7],DATA12);
SIGNAL(TOFD_P2T1_TCL1,tofd_vme.vftx2_2.time_coarse[8],DATA16);
SIGNAL(TOFD_P2T1_TCL2,tofd_vme.vftx2_2.time_coarse[12],DATA16);
SIGNAL(TOFD_P2T1_TCL3,tofd_vme.vftx2_3.time_coarse[0],DATA16);
SIGNAL(TOFD_P2T1_TCL4,tofd_vme.vftx2_3.time_coarse[4],DATA16);
SIGNAL(TOFD_P2T1_TCL5,tofd_vme.vftx2_3.time_coarse[8],DATA16);
SIGNAL(TOFD_P2T1_TCL6,tofd_vme.vftx2_3.time_coarse[12],DATA16);
SIGNAL(TOFD_P2T1_TCT1,tofd_vme.vftx2_2.time_coarse[9],DATA16);
SIGNAL(TOFD_P2T1_TCT2,tofd_vme.vftx2_2.time_coarse[13],DATA16);
SIGNAL(TOFD_P2T1_TCT3,tofd_vme.vftx2_3.time_coarse[1],DATA16);
SIGNAL(TOFD_P2T1_TCT4,tofd_vme.vftx2_3.time_coarse[5],DATA16);
SIGNAL(TOFD_P2T1_TCT5,tofd_vme.vftx2_3.time_coarse[9],DATA16);
SIGNAL(TOFD_P2T1_TCT6,tofd_vme.vftx2_3.time_coarse[13],DATA16);
SIGNAL(TOFD_P2T1_TFL1,tofd_vme.vftx2_2.time_fine[8],DATA12);
SIGNAL(TOFD_P2T1_TFL2,tofd_vme.vftx2_2.time_fine[12],DATA12);
SIGNAL(TOFD_P2T1_TFL3,tofd_vme.vftx2_3.time_fine[0],DATA12);
SIGNAL(TOFD_P2T1_TFL4,tofd_vme.vftx2_3.time_fine[4],DATA12);
SIGNAL(TOFD_P2T1_TFL5,tofd_vme.vftx2_3.time_fine[8],DATA12);
SIGNAL(TOFD_P2T1_TFL6,tofd_vme.vftx2_3.time_fine[12],DATA12);
SIGNAL(TOFD_P2T1_TFT1,tofd_vme.vftx2_2.time_fine[9],DATA12);
SIGNAL(TOFD_P2T1_TFT2,tofd_vme.vftx2_2.time_fine[13],DATA12);
SIGNAL(TOFD_P2T1_TFT3,tofd_vme.vftx2_3.time_fine[1],DATA12);
SIGNAL(TOFD_P2T1_TFT4,tofd_vme.vftx2_3.time_fine[5],DATA12);
SIGNAL(TOFD_P2T1_TFT5,tofd_vme.vftx2_3.time_fine[9],DATA12);
SIGNAL(TOFD_P2T1_TFT6,tofd_vme.vftx2_3.time_fine[13],DATA12);
SIGNAL(TOFD_P2T2_TCL1,tofd_vme.vftx2_2.time_coarse[10],DATA16);
SIGNAL(TOFD_P2T2_TCL2,tofd_vme.vftx2_2.time_coarse[14],DATA16);
SIGNAL(TOFD_P2T2_TCL3,tofd_vme.vftx2_3.time_coarse[2],DATA16);
SIGNAL(TOFD_P2T2_TCL4,tofd_vme.vftx2_3.time_coarse[6],DATA16);
SIGNAL(TOFD_P2T2_TCL5,tofd_vme.vftx2_3.time_coarse[10],DATA16);
SIGNAL(TOFD_P2T2_TCL6,tofd_vme.vftx2_3.time_coarse[14],DATA16);
SIGNAL(TOFD_P2T2_TCT1,tofd_vme.vftx2_2.time_coarse[11],DATA16);
SIGNAL(TOFD_P2T2_TCT2,tofd_vme.vftx2_2.time_coarse[15],DATA16);
SIGNAL(TOFD_P2T2_TCT3,tofd_vme.vftx2_3.time_coarse[3],DATA16);
SIGNAL(TOFD_P2T2_TCT4,tofd_vme.vftx2_3.time_coarse[7],DATA16);
SIGNAL(TOFD_P2T2_TCT5,tofd_vme.vftx2_3.time_coarse[11],DATA16);
SIGNAL(TOFD_P2T2_TCT6,tofd_vme.vftx2_3.time_coarse[15],DATA16);
SIGNAL(TOFD_P2T2_TFL1,tofd_vme.vftx2_2.time_fine[10],DATA12);
SIGNAL(TOFD_P2T2_TFL2,tofd_vme.vftx2_2.time_fine[14],DATA12);
SIGNAL(TOFD_P2T2_TFL3,tofd_vme.vftx2_3.time_fine[2],DATA12);
SIGNAL(TOFD_P2T2_TFL4,tofd_vme.vftx2_3.time_fine[6],DATA12);
SIGNAL(TOFD_P2T2_TFL5,tofd_vme.vftx2_3.time_fine[10],DATA12);
SIGNAL(TOFD_P2T2_TFL6,tofd_vme.vftx2_3.time_fine[14],DATA12);
SIGNAL(TOFD_P2T2_TFT1,tofd_vme.vftx2_2.time_fine[11],DATA12);
SIGNAL(TOFD_P2T2_TFT2,tofd_vme.vftx2_2.time_fine[15],DATA12);
SIGNAL(TOFD_P2T2_TFT3,tofd_vme.vftx2_3.time_fine[3],DATA12);
SIGNAL(TOFD_P2T2_TFT4,tofd_vme.vftx2_3.time_fine[7],DATA12);
SIGNAL(TOFD_P2T2_TFT5,tofd_vme.vftx2_3.time_fine[11],DATA12);
SIGNAL(TOFD_P2T2_TFT6,tofd_vme.vftx2_3.time_fine[15],DATA12);
SIGNAL(TOFD_P3T1_TCL1,tofd_tamex.tamex_1.time_coarse[1],DATA16);
SIGNAL(TOFD_P3T1_TCL2,tofd_tamex.tamex_1.time_coarse[5],DATA16);
SIGNAL(TOFD_P3T1_TCL3,tofd_tamex.tamex_1.time_coarse[9],DATA16);
SIGNAL(TOFD_P3T1_TCL4,tofd_tamex.tamex_1.time_coarse[13],DATA16);
SIGNAL(TOFD_P3T1_TCL5,tofd_tamex.tamex_1.time_coarse[17],DATA16);
SIGNAL(TOFD_P3T1_TCL6,tofd_tamex.tamex_1.time_coarse[21],DATA16);
SIGNAL(TOFD_P3T1_TCT1,tofd_tamex.tamex_1.time_coarse[2],DATA16);
SIGNAL(TOFD_P3T1_TCT2,tofd_tamex.tamex_1.time_coarse[6],DATA16);
SIGNAL(TOFD_P3T1_TCT3,tofd_tamex.tamex_1.time_coarse[10],DATA16);
SIGNAL(TOFD_P3T1_TCT4,tofd_tamex.tamex_1.time_coarse[14],DATA16);
SIGNAL(TOFD_P3T1_TCT5,tofd_tamex.tamex_1.time_coarse[18],DATA16);
SIGNAL(TOFD_P3T1_TCT6,tofd_tamex.tamex_1.time_coarse[22],DATA16);
SIGNAL(TOFD_P3T1_TFL1,tofd_tamex.tamex_1.time_fine[1],DATA12);
SIGNAL(TOFD_P3T1_TFL2,tofd_tamex.tamex_1.time_fine[5],DATA12);
SIGNAL(TOFD_P3T1_TFL3,tofd_tamex.tamex_1.time_fine[9],DATA12);
SIGNAL(TOFD_P3T1_TFL4,tofd_tamex.tamex_1.time_fine[13],DATA12);
SIGNAL(TOFD_P3T1_TFL5,tofd_tamex.tamex_1.time_fine[17],DATA12);
SIGNAL(TOFD_P3T1_TFL6,tofd_tamex.tamex_1.time_fine[21],DATA12);
SIGNAL(TOFD_P3T1_TFT1,tofd_tamex.tamex_1.time_fine[2],DATA12);
SIGNAL(TOFD_P3T1_TFT2,tofd_tamex.tamex_1.time_fine[6],DATA12);
SIGNAL(TOFD_P3T1_TFT3,tofd_tamex.tamex_1.time_fine[10],DATA12);
SIGNAL(TOFD_P3T1_TFT4,tofd_tamex.tamex_1.time_fine[14],DATA12);
SIGNAL(TOFD_P3T1_TFT5,tofd_tamex.tamex_1.time_fine[18],DATA12);
SIGNAL(TOFD_P3T1_TFT6,tofd_tamex.tamex_1.time_fine[22],DATA12);
SIGNAL(TOFD_P3T2_TCL1,tofd_tamex.tamex_1.time_coarse[3],DATA16);
SIGNAL(TOFD_P3T2_TCL2,tofd_tamex.tamex_1.time_coarse[7],DATA16);
SIGNAL(TOFD_P3T2_TCL3,tofd_tamex.tamex_1.time_coarse[11],DATA16);
SIGNAL(TOFD_P3T2_TCL4,tofd_tamex.tamex_1.time_coarse[15],DATA16);
SIGNAL(TOFD_P3T2_TCL5,tofd_tamex.tamex_1.time_coarse[19],DATA16);
SIGNAL(TOFD_P3T2_TCL6,tofd_tamex.tamex_1.time_coarse[23],DATA16);
SIGNAL(TOFD_P3T2_TCT1,tofd_tamex.tamex_1.time_coarse[4],DATA16);
SIGNAL(TOFD_P3T2_TCT2,tofd_tamex.tamex_1.time_coarse[8],DATA16);
SIGNAL(TOFD_P3T2_TCT3,tofd_tamex.tamex_1.time_coarse[12],DATA16);
SIGNAL(TOFD_P3T2_TCT4,tofd_tamex.tamex_1.time_coarse[16],DATA16);
SIGNAL(TOFD_P3T2_TCT5,tofd_tamex.tamex_1.time_coarse[20],DATA16);
SIGNAL(TOFD_P3T2_TCT6,tofd_tamex.tamex_1.time_coarse[24],DATA16);
SIGNAL(TOFD_P3T2_TFL1,tofd_tamex.tamex_1.time_fine[3],DATA12);
SIGNAL(TOFD_P3T2_TFL2,tofd_tamex.tamex_1.time_fine[7],DATA12);
SIGNAL(TOFD_P3T2_TFL3,tofd_tamex.tamex_1.time_fine[11],DATA12);
SIGNAL(TOFD_P3T2_TFL4,tofd_tamex.tamex_1.time_fine[15],DATA12);
SIGNAL(TOFD_P3T2_TFL5,tofd_tamex.tamex_1.time_fine[19],DATA12);
SIGNAL(TOFD_P3T2_TFL6,tofd_tamex.tamex_1.time_fine[23],DATA12);
SIGNAL(TOFD_P3T2_TFT1,tofd_tamex.tamex_1.time_fine[4],DATA12);
SIGNAL(TOFD_P3T2_TFT2,tofd_tamex.tamex_1.time_fine[8],DATA12);
SIGNAL(TOFD_P3T2_TFT3,tofd_tamex.tamex_1.time_fine[12],DATA12);
SIGNAL(TOFD_P3T2_TFT4,tofd_tamex.tamex_1.time_fine[16],DATA12);
SIGNAL(TOFD_P3T2_TFT5,tofd_tamex.tamex_1.time_fine[20],DATA12);
SIGNAL(TOFD_P3T2_TFT6,tofd_tamex.tamex_1.time_fine[24],DATA12);
SIGNAL(TOFD_P4T1_TCL1,tofd_tamex.tamex_2.time_coarse[1],DATA16);
SIGNAL(TOFD_P4T1_TCL2,tofd_tamex.tamex_2.time_coarse[5],DATA16);
SIGNAL(TOFD_P4T1_TCL3,tofd_tamex.tamex_2.time_coarse[9],DATA16);
SIGNAL(TOFD_P4T1_TCL4,tofd_tamex.tamex_2.time_coarse[13],DATA16);
SIGNAL(TOFD_P4T1_TCL5,tofd_tamex.tamex_2.time_coarse[17],DATA16);
SIGNAL(TOFD_P4T1_TCL6,tofd_tamex.tamex_2.time_coarse[21],DATA16);
SIGNAL(TOFD_P4T1_TCT1,tofd_tamex.tamex_2.time_coarse[2],DATA16);
SIGNAL(TOFD_P4T1_TCT2,tofd_tamex.tamex_2.time_coarse[6],DATA16);
SIGNAL(TOFD_P4T1_TCT3,tofd_tamex.tamex_2.time_coarse[10],DATA16);
SIGNAL(TOFD_P4T1_TCT4,tofd_tamex.tamex_2.time_coarse[14],DATA16);
SIGNAL(TOFD_P4T1_TCT5,tofd_tamex.tamex_2.time_coarse[18],DATA16);
SIGNAL(TOFD_P4T1_TCT6,tofd_tamex.tamex_2.time_coarse[22],DATA16);
SIGNAL(TOFD_P4T1_TFL1,tofd_tamex.tamex_2.time_fine[1],DATA12);
SIGNAL(TOFD_P4T1_TFL2,tofd_tamex.tamex_2.time_fine[5],DATA12);
SIGNAL(TOFD_P4T1_TFL3,tofd_tamex.tamex_2.time_fine[9],DATA12);
SIGNAL(TOFD_P4T1_TFL4,tofd_tamex.tamex_2.time_fine[13],DATA12);
SIGNAL(TOFD_P4T1_TFL5,tofd_tamex.tamex_2.time_fine[17],DATA12);
SIGNAL(TOFD_P4T1_TFL6,tofd_tamex.tamex_2.time_fine[21],DATA12);
SIGNAL(TOFD_P4T1_TFT1,tofd_tamex.tamex_2.time_fine[2],DATA12);
SIGNAL(TOFD_P4T1_TFT2,tofd_tamex.tamex_2.time_fine[6],DATA12);
SIGNAL(TOFD_P4T1_TFT3,tofd_tamex.tamex_2.time_fine[10],DATA12);
SIGNAL(TOFD_P4T1_TFT4,tofd_tamex.tamex_2.time_fine[14],DATA12);
SIGNAL(TOFD_P4T1_TFT5,tofd_tamex.tamex_2.time_fine[18],DATA12);
SIGNAL(TOFD_P4T1_TFT6,tofd_tamex.tamex_2.time_fine[22],DATA12);
SIGNAL(TOFD_P4T2_TCL1,tofd_tamex.tamex_2.time_coarse[3],DATA16);
SIGNAL(TOFD_P4T2_TCL2,tofd_tamex.tamex_2.time_coarse[7],DATA16);
SIGNAL(TOFD_P4T2_TCL3,tofd_tamex.tamex_2.time_coarse[11],DATA16);
SIGNAL(TOFD_P4T2_TCL4,tofd_tamex.tamex_2.time_coarse[15],DATA16);
SIGNAL(TOFD_P4T2_TCL5,tofd_tamex.tamex_2.time_coarse[19],DATA16);
SIGNAL(TOFD_P4T2_TCL6,tofd_tamex.tamex_2.time_coarse[23],DATA16);
SIGNAL(TOFD_P4T2_TCT1,tofd_tamex.tamex_2.time_coarse[4],DATA16);
SIGNAL(TOFD_P4T2_TCT2,tofd_tamex.tamex_2.time_coarse[8],DATA16);
SIGNAL(TOFD_P4T2_TCT3,tofd_tamex.tamex_2.time_coarse[12],DATA16);
SIGNAL(TOFD_P4T2_TCT4,tofd_tamex.tamex_2.time_coarse[16],DATA16);
SIGNAL(TOFD_P4T2_TCT5,tofd_tamex.tamex_2.time_coarse[20],DATA16);
SIGNAL(TOFD_P4T2_TCT6,tofd_tamex.tamex_2.time_coarse[24],DATA16);
SIGNAL(TOFD_P4T2_TFL1,tofd_tamex.tamex_2.time_fine[3],DATA12);
SIGNAL(TOFD_P4T2_TFL2,tofd_tamex.tamex_2.time_fine[7],DATA12);
SIGNAL(TOFD_P4T2_TFL3,tofd_tamex.tamex_2.time_fine[11],DATA12);
SIGNAL(TOFD_P4T2_TFL4,tofd_tamex.tamex_2.time_fine[15],DATA12);
SIGNAL(TOFD_P4T2_TFL5,tofd_tamex.tamex_2.time_fine[19],DATA12);
SIGNAL(TOFD_P4T2_TFL6,tofd_tamex.tamex_2.time_fine[23],DATA12);
SIGNAL(TOFD_P4T2_TFT1,tofd_tamex.tamex_2.time_fine[4],DATA12);
SIGNAL(TOFD_P4T2_TFT2,tofd_tamex.tamex_2.time_fine[8],DATA12);
SIGNAL(TOFD_P4T2_TFT3,tofd_tamex.tamex_2.time_fine[12],DATA12);
SIGNAL(TOFD_P4T2_TFT4,tofd_tamex.tamex_2.time_fine[16],DATA12);
SIGNAL(TOFD_P4T2_TFT5,tofd_tamex.tamex_2.time_fine[20],DATA12);
SIGNAL(TOFD_P4T2_TFT6,tofd_tamex.tamex_2.time_fine[24],DATA12);
SIGNAL(TOFD_P5T1_TCL1,tofd_tamex.tamex_3.time_coarse[1],DATA16);
SIGNAL(TOFD_P5T1_TCL2,tofd_tamex.tamex_3.time_coarse[5],DATA16);
SIGNAL(TOFD_P5T1_TCL3,tofd_tamex.tamex_3.time_coarse[9],DATA16);
SIGNAL(TOFD_P5T1_TCL4,tofd_tamex.tamex_3.time_coarse[13],DATA16);
SIGNAL(TOFD_P5T1_TCL5,tofd_tamex.tamex_3.time_coarse[17],DATA16);
SIGNAL(TOFD_P5T1_TCL6,tofd_tamex.tamex_3.time_coarse[21],DATA16);
SIGNAL(TOFD_P5T1_TCT1,tofd_tamex.tamex_3.time_coarse[2],DATA16);
SIGNAL(TOFD_P5T1_TCT2,tofd_tamex.tamex_3.time_coarse[6],DATA16);
SIGNAL(TOFD_P5T1_TCT3,tofd_tamex.tamex_3.time_coarse[10],DATA16);
SIGNAL(TOFD_P5T1_TCT4,tofd_tamex.tamex_3.time_coarse[14],DATA16);
SIGNAL(TOFD_P5T1_TCT5,tofd_tamex.tamex_3.time_coarse[18],DATA16);
SIGNAL(TOFD_P5T1_TCT6,tofd_tamex.tamex_3.time_coarse[22],DATA16);
SIGNAL(TOFD_P5T1_TFL1,tofd_tamex.tamex_3.time_fine[1],DATA12);
SIGNAL(TOFD_P5T1_TFL2,tofd_tamex.tamex_3.time_fine[5],DATA12);
SIGNAL(TOFD_P5T1_TFL3,tofd_tamex.tamex_3.time_fine[9],DATA12);
SIGNAL(TOFD_P5T1_TFL4,tofd_tamex.tamex_3.time_fine[13],DATA12);
SIGNAL(TOFD_P5T1_TFL5,tofd_tamex.tamex_3.time_fine[17],DATA12);
SIGNAL(TOFD_P5T1_TFL6,tofd_tamex.tamex_3.time_fine[21],DATA12);
SIGNAL(TOFD_P5T1_TFT1,tofd_tamex.tamex_3.time_fine[2],DATA12);
SIGNAL(TOFD_P5T1_TFT2,tofd_tamex.tamex_3.time_fine[6],DATA12);
SIGNAL(TOFD_P5T1_TFT3,tofd_tamex.tamex_3.time_fine[10],DATA12);
SIGNAL(TOFD_P5T1_TFT4,tofd_tamex.tamex_3.time_fine[14],DATA12);
SIGNAL(TOFD_P5T1_TFT5,tofd_tamex.tamex_3.time_fine[18],DATA12);
SIGNAL(TOFD_P5T1_TFT6,tofd_tamex.tamex_3.time_fine[22],DATA12);
SIGNAL(TOFD_P5T2_TCL1,tofd_tamex.tamex_3.time_coarse[3],DATA16);
SIGNAL(TOFD_P5T2_TCL2,tofd_tamex.tamex_3.time_coarse[7],DATA16);
SIGNAL(TOFD_P5T2_TCL3,tofd_tamex.tamex_3.time_coarse[11],DATA16);
SIGNAL(TOFD_P5T2_TCL4,tofd_tamex.tamex_3.time_coarse[15],DATA16);
SIGNAL(TOFD_P5T2_TCL5,tofd_tamex.tamex_3.time_coarse[19],DATA16);
SIGNAL(TOFD_P5T2_TCL6,tofd_tamex.tamex_3.time_coarse[23],DATA16);
SIGNAL(TOFD_P5T2_TCT1,tofd_tamex.tamex_3.time_coarse[4],DATA16);
SIGNAL(TOFD_P5T2_TCT2,tofd_tamex.tamex_3.time_coarse[8],DATA16);
SIGNAL(TOFD_P5T2_TCT3,tofd_tamex.tamex_3.time_coarse[12],DATA16);
SIGNAL(TOFD_P5T2_TCT4,tofd_tamex.tamex_3.time_coarse[16],DATA16);
SIGNAL(TOFD_P5T2_TCT5,tofd_tamex.tamex_3.time_coarse[20],DATA16);
SIGNAL(TOFD_P5T2_TCT6,tofd_tamex.tamex_3.time_coarse[24],DATA16);
SIGNAL(TOFD_P5T2_TFL1,tofd_tamex.tamex_3.time_fine[3],DATA12);
SIGNAL(TOFD_P5T2_TFL2,tofd_tamex.tamex_3.time_fine[7],DATA12);
SIGNAL(TOFD_P5T2_TFL3,tofd_tamex.tamex_3.time_fine[11],DATA12);
SIGNAL(TOFD_P5T2_TFL4,tofd_tamex.tamex_3.time_fine[15],DATA12);
SIGNAL(TOFD_P5T2_TFL5,tofd_tamex.tamex_3.time_fine[19],DATA12);
SIGNAL(TOFD_P5T2_TFL6,tofd_tamex.tamex_3.time_fine[23],DATA12);
SIGNAL(TOFD_P5T2_TFT1,tofd_tamex.tamex_3.time_fine[4],DATA12);
SIGNAL(TOFD_P5T2_TFT2,tofd_tamex.tamex_3.time_fine[8],DATA12);
SIGNAL(TOFD_P5T2_TFT3,tofd_tamex.tamex_3.time_fine[12],DATA12);
SIGNAL(TOFD_P5T2_TFT4,tofd_tamex.tamex_3.time_fine[16],DATA12);
SIGNAL(TOFD_P5T2_TFT5,tofd_tamex.tamex_3.time_fine[20],DATA12);
SIGNAL(TOFD_P5T2_TFT6,tofd_tamex.tamex_3.time_fine[24],DATA12);
SIGNAL(TOFD_P6T1_TCL1,tofd_tamex.tamex_4.time_coarse[1],DATA16);
SIGNAL(TOFD_P6T1_TCL2,tofd_tamex.tamex_4.time_coarse[5],DATA16);
SIGNAL(TOFD_P6T1_TCL3,tofd_tamex.tamex_4.time_coarse[9],DATA16);
SIGNAL(TOFD_P6T1_TCL4,tofd_tamex.tamex_4.time_coarse[13],DATA16);
SIGNAL(TOFD_P6T1_TCL5,tofd_tamex.tamex_4.time_coarse[17],DATA16);
SIGNAL(TOFD_P6T1_TCL6,tofd_tamex.tamex_4.time_coarse[21],DATA16);
SIGNAL(TOFD_P6T1_TCT1,tofd_tamex.tamex_4.time_coarse[2],DATA16);
SIGNAL(TOFD_P6T1_TCT2,tofd_tamex.tamex_4.time_coarse[6],DATA16);
SIGNAL(TOFD_P6T1_TCT3,tofd_tamex.tamex_4.time_coarse[10],DATA16);
SIGNAL(TOFD_P6T1_TCT4,tofd_tamex.tamex_4.time_coarse[14],DATA16);
SIGNAL(TOFD_P6T1_TCT5,tofd_tamex.tamex_4.time_coarse[18],DATA16);
SIGNAL(TOFD_P6T1_TCT6,tofd_tamex.tamex_4.time_coarse[22],DATA16);
SIGNAL(TOFD_P6T1_TFL1,tofd_tamex.tamex_4.time_fine[1],DATA12);
SIGNAL(TOFD_P6T1_TFL2,tofd_tamex.tamex_4.time_fine[5],DATA12);
SIGNAL(TOFD_P6T1_TFL3,tofd_tamex.tamex_4.time_fine[9],DATA12);
SIGNAL(TOFD_P6T1_TFL4,tofd_tamex.tamex_4.time_fine[13],DATA12);
SIGNAL(TOFD_P6T1_TFL5,tofd_tamex.tamex_4.time_fine[17],DATA12);
SIGNAL(TOFD_P6T1_TFL6,tofd_tamex.tamex_4.time_fine[21],DATA12);
SIGNAL(TOFD_P6T1_TFT1,tofd_tamex.tamex_4.time_fine[2],DATA12);
SIGNAL(TOFD_P6T1_TFT2,tofd_tamex.tamex_4.time_fine[6],DATA12);
SIGNAL(TOFD_P6T1_TFT3,tofd_tamex.tamex_4.time_fine[10],DATA12);
SIGNAL(TOFD_P6T1_TFT4,tofd_tamex.tamex_4.time_fine[14],DATA12);
SIGNAL(TOFD_P6T1_TFT5,tofd_tamex.tamex_4.time_fine[18],DATA12);
SIGNAL(TOFD_P6T1_TFT6,tofd_tamex.tamex_4.time_fine[22],DATA12);
SIGNAL(TOFD_P6T2_TCL1,tofd_tamex.tamex_4.time_coarse[3],DATA16);
SIGNAL(TOFD_P6T2_TCL2,tofd_tamex.tamex_4.time_coarse[7],DATA16);
SIGNAL(TOFD_P6T2_TCL3,tofd_tamex.tamex_4.time_coarse[11],DATA16);
SIGNAL(TOFD_P6T2_TCL4,tofd_tamex.tamex_4.time_coarse[15],DATA16);
SIGNAL(TOFD_P6T2_TCL5,tofd_tamex.tamex_4.time_coarse[19],DATA16);
SIGNAL(TOFD_P6T2_TCL6,tofd_tamex.tamex_4.time_coarse[23],DATA16);
SIGNAL(TOFD_P6T2_TCT1,tofd_tamex.tamex_4.time_coarse[4],DATA16);
SIGNAL(TOFD_P6T2_TCT2,tofd_tamex.tamex_4.time_coarse[8],DATA16);
SIGNAL(TOFD_P6T2_TCT3,tofd_tamex.tamex_4.time_coarse[12],DATA16);
SIGNAL(TOFD_P6T2_TCT4,tofd_tamex.tamex_4.time_coarse[16],DATA16);
SIGNAL(TOFD_P6T2_TCT5,tofd_tamex.tamex_4.time_coarse[20],DATA16);
SIGNAL(TOFD_P6T2_TCT6,tofd_tamex.tamex_4.time_coarse[24],DATA16);
SIGNAL(TOFD_P6T2_TFL1,tofd_tamex.tamex_4.time_fine[3],DATA12);
SIGNAL(TOFD_P6T2_TFL2,tofd_tamex.tamex_4.time_fine[7],DATA12);
SIGNAL(TOFD_P6T2_TFL3,tofd_tamex.tamex_4.time_fine[11],DATA12);
SIGNAL(TOFD_P6T2_TFL4,tofd_tamex.tamex_4.time_fine[15],DATA12);
SIGNAL(TOFD_P6T2_TFL5,tofd_tamex.tamex_4.time_fine[19],DATA12);
SIGNAL(TOFD_P6T2_TFL6,tofd_tamex.tamex_4.time_fine[23],DATA12);
SIGNAL(TOFD_P6T2_TFT1,tofd_tamex.tamex_4.time_fine[4],DATA12);
SIGNAL(TOFD_P6T2_TFT2,tofd_tamex.tamex_4.time_fine[8],DATA12);
SIGNAL(TOFD_P6T2_TFT3,tofd_tamex.tamex_4.time_fine[12],DATA12);
SIGNAL(TOFD_P6T2_TFT4,tofd_tamex.tamex_4.time_fine[16],DATA12);
SIGNAL(TOFD_P6T2_TFT5,tofd_tamex.tamex_4.time_fine[20],DATA12);
SIGNAL(TOFD_P6T2_TFT6,tofd_tamex.tamex_4.time_fine[24],DATA12);
SIGNAL(TOFD_VFTX2_T1,tofd_vme.vftx2_1.time_trigger,DATA16);
SIGNAL(TOFD_VFTX2_T2,tofd_vme.vftx2_2.time_trigger,DATA16);
SIGNAL(TOFD_VFTX2_T3,tofd_vme.vftx2_3.time_trigger,DATA16);
SIGNAL(TRLO_SAMPLER_S1,los_sampler.sampler.sampler[0],DATA32);
SIGNAL(TRLO_SAMPLER_S10,los_sampler.sampler.sampler[9],DATA32);
SIGNAL(TRLO_SAMPLER_S100,los_sampler.sampler.sampler[99],DATA32);
SIGNAL(TRLO_SAMPLER_S101,los_sampler.sampler.sampler[100],DATA32);
SIGNAL(TRLO_SAMPLER_S102,los_sampler.sampler.sampler[101],DATA32);
SIGNAL(TRLO_SAMPLER_S103,los_sampler.sampler.sampler[102],DATA32);
SIGNAL(TRLO_SAMPLER_S104,los_sampler.sampler.sampler[103],DATA32);
SIGNAL(TRLO_SAMPLER_S105,los_sampler.sampler.sampler[104],DATA32);
SIGNAL(TRLO_SAMPLER_S106,los_sampler.sampler.sampler[105],DATA32);
SIGNAL(TRLO_SAMPLER_S107,los_sampler.sampler.sampler[106],DATA32);
SIGNAL(TRLO_SAMPLER_S108,los_sampler.sampler.sampler[107],DATA32);
SIGNAL(TRLO_SAMPLER_S109,los_sampler.sampler.sampler[108],DATA32);
SIGNAL(TRLO_SAMPLER_S11,los_sampler.sampler.sampler[10],DATA32);
SIGNAL(TRLO_SAMPLER_S110,los_sampler.sampler.sampler[109],DATA32);
SIGNAL(TRLO_SAMPLER_S111,los_sampler.sampler.sampler[110],DATA32);
SIGNAL(TRLO_SAMPLER_S112,los_sampler.sampler.sampler[111],DATA32);
SIGNAL(TRLO_SAMPLER_S113,los_sampler.sampler.sampler[112],DATA32);
SIGNAL(TRLO_SAMPLER_S114,los_sampler.sampler.sampler[113],DATA32);
SIGNAL(TRLO_SAMPLER_S115,los_sampler.sampler.sampler[114],DATA32);
SIGNAL(TRLO_SAMPLER_S116,los_sampler.sampler.sampler[115],DATA32);
SIGNAL(TRLO_SAMPLER_S117,los_sampler.sampler.sampler[116],DATA32);
SIGNAL(TRLO_SAMPLER_S118,los_sampler.sampler.sampler[117],DATA32);
SIGNAL(TRLO_SAMPLER_S119,los_sampler.sampler.sampler[118],DATA32);
SIGNAL(TRLO_SAMPLER_S12,los_sampler.sampler.sampler[11],DATA32);
SIGNAL(TRLO_SAMPLER_S120,los_sampler.sampler.sampler[119],DATA32);
SIGNAL(TRLO_SAMPLER_S121,los_sampler.sampler.sampler[120],DATA32);
SIGNAL(TRLO_SAMPLER_S122,los_sampler.sampler.sampler[121],DATA32);
SIGNAL(TRLO_SAMPLER_S123,los_sampler.sampler.sampler[122],DATA32);
SIGNAL(TRLO_SAMPLER_S124,los_sampler.sampler.sampler[123],DATA32);
SIGNAL(TRLO_SAMPLER_S125,los_sampler.sampler.sampler[124],DATA32);
SIGNAL(TRLO_SAMPLER_S126,los_sampler.sampler.sampler[125],DATA32);
SIGNAL(TRLO_SAMPLER_S127,los_sampler.sampler.sampler[126],DATA32);
SIGNAL(TRLO_SAMPLER_S128,los_sampler.sampler.sampler[127],DATA32);
SIGNAL(TRLO_SAMPLER_S129,los_sampler.sampler.sampler[128],DATA32);
SIGNAL(TRLO_SAMPLER_S13,los_sampler.sampler.sampler[12],DATA32);
SIGNAL(TRLO_SAMPLER_S130,los_sampler.sampler.sampler[129],DATA32);
SIGNAL(TRLO_SAMPLER_S131,los_sampler.sampler.sampler[130],DATA32);
SIGNAL(TRLO_SAMPLER_S132,los_sampler.sampler.sampler[131],DATA32);
SIGNAL(TRLO_SAMPLER_S133,los_sampler.sampler.sampler[132],DATA32);
SIGNAL(TRLO_SAMPLER_S134,los_sampler.sampler.sampler[133],DATA32);
SIGNAL(TRLO_SAMPLER_S135,los_sampler.sampler.sampler[134],DATA32);
SIGNAL(TRLO_SAMPLER_S136,los_sampler.sampler.sampler[135],DATA32);
SIGNAL(TRLO_SAMPLER_S137,los_sampler.sampler.sampler[136],DATA32);
SIGNAL(TRLO_SAMPLER_S138,los_sampler.sampler.sampler[137],DATA32);
SIGNAL(TRLO_SAMPLER_S139,los_sampler.sampler.sampler[138],DATA32);
SIGNAL(TRLO_SAMPLER_S14,los_sampler.sampler.sampler[13],DATA32);
SIGNAL(TRLO_SAMPLER_S140,los_sampler.sampler.sampler[139],DATA32);
SIGNAL(TRLO_SAMPLER_S141,los_sampler.sampler.sampler[140],DATA32);
SIGNAL(TRLO_SAMPLER_S142,los_sampler.sampler.sampler[141],DATA32);
SIGNAL(TRLO_SAMPLER_S143,los_sampler.sampler.sampler[142],DATA32);
SIGNAL(TRLO_SAMPLER_S144,los_sampler.sampler.sampler[143],DATA32);
SIGNAL(TRLO_SAMPLER_S145,los_sampler.sampler.sampler[144],DATA32);
SIGNAL(TRLO_SAMPLER_S146,los_sampler.sampler.sampler[145],DATA32);
SIGNAL(TRLO_SAMPLER_S147,los_sampler.sampler.sampler[146],DATA32);
SIGNAL(TRLO_SAMPLER_S148,los_sampler.sampler.sampler[147],DATA32);
SIGNAL(TRLO_SAMPLER_S149,los_sampler.sampler.sampler[148],DATA32);
SIGNAL(TRLO_SAMPLER_S15,los_sampler.sampler.sampler[14],DATA32);
SIGNAL(TRLO_SAMPLER_S150,los_sampler.sampler.sampler[149],DATA32);
SIGNAL(TRLO_SAMPLER_S151,los_sampler.sampler.sampler[150],DATA32);
SIGNAL(TRLO_SAMPLER_S152,los_sampler.sampler.sampler[151],DATA32);
SIGNAL(TRLO_SAMPLER_S153,los_sampler.sampler.sampler[152],DATA32);
SIGNAL(TRLO_SAMPLER_S154,los_sampler.sampler.sampler[153],DATA32);
SIGNAL(TRLO_SAMPLER_S155,los_sampler.sampler.sampler[154],DATA32);
SIGNAL(TRLO_SAMPLER_S156,los_sampler.sampler.sampler[155],DATA32);
SIGNAL(TRLO_SAMPLER_S157,los_sampler.sampler.sampler[156],DATA32);
SIGNAL(TRLO_SAMPLER_S158,los_sampler.sampler.sampler[157],DATA32);
SIGNAL(TRLO_SAMPLER_S159,los_sampler.sampler.sampler[158],DATA32);
SIGNAL(TRLO_SAMPLER_S16,los_sampler.sampler.sampler[15],DATA32);
SIGNAL(TRLO_SAMPLER_S160,los_sampler.sampler.sampler[159],DATA32);
SIGNAL(TRLO_SAMPLER_S161,los_sampler.sampler.sampler[160],DATA32);
SIGNAL(TRLO_SAMPLER_S162,los_sampler.sampler.sampler[161],DATA32);
SIGNAL(TRLO_SAMPLER_S163,los_sampler.sampler.sampler[162],DATA32);
SIGNAL(TRLO_SAMPLER_S164,los_sampler.sampler.sampler[163],DATA32);
SIGNAL(TRLO_SAMPLER_S165,los_sampler.sampler.sampler[164],DATA32);
SIGNAL(TRLO_SAMPLER_S166,los_sampler.sampler.sampler[165],DATA32);
SIGNAL(TRLO_SAMPLER_S167,los_sampler.sampler.sampler[166],DATA32);
SIGNAL(TRLO_SAMPLER_S168,los_sampler.sampler.sampler[167],DATA32);
SIGNAL(TRLO_SAMPLER_S169,los_sampler.sampler.sampler[168],DATA32);
SIGNAL(TRLO_SAMPLER_S17,los_sampler.sampler.sampler[16],DATA32);
SIGNAL(TRLO_SAMPLER_S170,los_sampler.sampler.sampler[169],DATA32);
SIGNAL(TRLO_SAMPLER_S171,los_sampler.sampler.sampler[170],DATA32);
SIGNAL(TRLO_SAMPLER_S172,los_sampler.sampler.sampler[171],DATA32);
SIGNAL(TRLO_SAMPLER_S173,los_sampler.sampler.sampler[172],DATA32);
SIGNAL(TRLO_SAMPLER_S174,los_sampler.sampler.sampler[173],DATA32);
SIGNAL(TRLO_SAMPLER_S175,los_sampler.sampler.sampler[174],DATA32);
SIGNAL(TRLO_SAMPLER_S176,los_sampler.sampler.sampler[175],DATA32);
SIGNAL(TRLO_SAMPLER_S177,los_sampler.sampler.sampler[176],DATA32);
SIGNAL(TRLO_SAMPLER_S178,los_sampler.sampler.sampler[177],DATA32);
SIGNAL(TRLO_SAMPLER_S179,los_sampler.sampler.sampler[178],DATA32);
SIGNAL(TRLO_SAMPLER_S18,los_sampler.sampler.sampler[17],DATA32);
SIGNAL(TRLO_SAMPLER_S180,los_sampler.sampler.sampler[179],DATA32);
SIGNAL(TRLO_SAMPLER_S181,los_sampler.sampler.sampler[180],DATA32);
SIGNAL(TRLO_SAMPLER_S182,los_sampler.sampler.sampler[181],DATA32);
SIGNAL(TRLO_SAMPLER_S183,los_sampler.sampler.sampler[182],DATA32);
SIGNAL(TRLO_SAMPLER_S184,los_sampler.sampler.sampler[183],DATA32);
SIGNAL(TRLO_SAMPLER_S185,los_sampler.sampler.sampler[184],DATA32);
SIGNAL(TRLO_SAMPLER_S186,los_sampler.sampler.sampler[185],DATA32);
SIGNAL(TRLO_SAMPLER_S187,los_sampler.sampler.sampler[186],DATA32);
SIGNAL(TRLO_SAMPLER_S188,los_sampler.sampler.sampler[187],DATA32);
SIGNAL(TRLO_SAMPLER_S189,los_sampler.sampler.sampler[188],DATA32);
SIGNAL(TRLO_SAMPLER_S19,los_sampler.sampler.sampler[18],DATA32);
SIGNAL(TRLO_SAMPLER_S190,los_sampler.sampler.sampler[189],DATA32);
SIGNAL(TRLO_SAMPLER_S191,los_sampler.sampler.sampler[190],DATA32);
SIGNAL(TRLO_SAMPLER_S192,los_sampler.sampler.sampler[191],DATA32);
SIGNAL(TRLO_SAMPLER_S193,los_sampler.sampler.sampler[192],DATA32);
SIGNAL(TRLO_SAMPLER_S194,los_sampler.sampler.sampler[193],DATA32);
SIGNAL(TRLO_SAMPLER_S195,los_sampler.sampler.sampler[194],DATA32);
SIGNAL(TRLO_SAMPLER_S196,los_sampler.sampler.sampler[195],DATA32);
SIGNAL(TRLO_SAMPLER_S197,los_sampler.sampler.sampler[196],DATA32);
SIGNAL(TRLO_SAMPLER_S198,los_sampler.sampler.sampler[197],DATA32);
SIGNAL(TRLO_SAMPLER_S199,los_sampler.sampler.sampler[198],DATA32);
SIGNAL(TRLO_SAMPLER_S2,los_sampler.sampler.sampler[1],DATA32);
SIGNAL(TRLO_SAMPLER_S20,los_sampler.sampler.sampler[19],DATA32);
SIGNAL(TRLO_SAMPLER_S200,los_sampler.sampler.sampler[199],DATA32);
SIGNAL(TRLO_SAMPLER_S201,los_sampler.sampler.sampler[200],DATA32);
SIGNAL(TRLO_SAMPLER_S202,los_sampler.sampler.sampler[201],DATA32);
SIGNAL(TRLO_SAMPLER_S203,los_sampler.sampler.sampler[202],DATA32);
SIGNAL(TRLO_SAMPLER_S204,los_sampler.sampler.sampler[203],DATA32);
SIGNAL(TRLO_SAMPLER_S205,los_sampler.sampler.sampler[204],DATA32);
SIGNAL(TRLO_SAMPLER_S206,los_sampler.sampler.sampler[205],DATA32);
SIGNAL(TRLO_SAMPLER_S207,los_sampler.sampler.sampler[206],DATA32);
SIGNAL(TRLO_SAMPLER_S208,los_sampler.sampler.sampler[207],DATA32);
SIGNAL(TRLO_SAMPLER_S209,los_sampler.sampler.sampler[208],DATA32);
SIGNAL(TRLO_SAMPLER_S21,los_sampler.sampler.sampler[20],DATA32);
SIGNAL(TRLO_SAMPLER_S210,los_sampler.sampler.sampler[209],DATA32);
SIGNAL(TRLO_SAMPLER_S211,los_sampler.sampler.sampler[210],DATA32);
SIGNAL(TRLO_SAMPLER_S212,los_sampler.sampler.sampler[211],DATA32);
SIGNAL(TRLO_SAMPLER_S213,los_sampler.sampler.sampler[212],DATA32);
SIGNAL(TRLO_SAMPLER_S214,los_sampler.sampler.sampler[213],DATA32);
SIGNAL(TRLO_SAMPLER_S215,los_sampler.sampler.sampler[214],DATA32);
SIGNAL(TRLO_SAMPLER_S216,los_sampler.sampler.sampler[215],DATA32);
SIGNAL(TRLO_SAMPLER_S217,los_sampler.sampler.sampler[216],DATA32);
SIGNAL(TRLO_SAMPLER_S218,los_sampler.sampler.sampler[217],DATA32);
SIGNAL(TRLO_SAMPLER_S219,los_sampler.sampler.sampler[218],DATA32);
SIGNAL(TRLO_SAMPLER_S22,los_sampler.sampler.sampler[21],DATA32);
SIGNAL(TRLO_SAMPLER_S220,los_sampler.sampler.sampler[219],DATA32);
SIGNAL(TRLO_SAMPLER_S221,los_sampler.sampler.sampler[220],DATA32);
SIGNAL(TRLO_SAMPLER_S222,los_sampler.sampler.sampler[221],DATA32);
SIGNAL(TRLO_SAMPLER_S223,los_sampler.sampler.sampler[222],DATA32);
SIGNAL(TRLO_SAMPLER_S224,los_sampler.sampler.sampler[223],DATA32);
SIGNAL(TRLO_SAMPLER_S225,los_sampler.sampler.sampler[224],DATA32);
SIGNAL(TRLO_SAMPLER_S226,los_sampler.sampler.sampler[225],DATA32);
SIGNAL(TRLO_SAMPLER_S227,los_sampler.sampler.sampler[226],DATA32);
SIGNAL(TRLO_SAMPLER_S228,los_sampler.sampler.sampler[227],DATA32);
SIGNAL(TRLO_SAMPLER_S229,los_sampler.sampler.sampler[228],DATA32);
SIGNAL(TRLO_SAMPLER_S23,los_sampler.sampler.sampler[22],DATA32);
SIGNAL(TRLO_SAMPLER_S230,los_sampler.sampler.sampler[229],DATA32);
SIGNAL(TRLO_SAMPLER_S231,los_sampler.sampler.sampler[230],DATA32);
SIGNAL(TRLO_SAMPLER_S232,los_sampler.sampler.sampler[231],DATA32);
SIGNAL(TRLO_SAMPLER_S233,los_sampler.sampler.sampler[232],DATA32);
SIGNAL(TRLO_SAMPLER_S234,los_sampler.sampler.sampler[233],DATA32);
SIGNAL(TRLO_SAMPLER_S235,los_sampler.sampler.sampler[234],DATA32);
SIGNAL(TRLO_SAMPLER_S236,los_sampler.sampler.sampler[235],DATA32);
SIGNAL(TRLO_SAMPLER_S237,los_sampler.sampler.sampler[236],DATA32);
SIGNAL(TRLO_SAMPLER_S238,los_sampler.sampler.sampler[237],DATA32);
SIGNAL(TRLO_SAMPLER_S239,los_sampler.sampler.sampler[238],DATA32);
SIGNAL(TRLO_SAMPLER_S24,los_sampler.sampler.sampler[23],DATA32);
SIGNAL(TRLO_SAMPLER_S240,los_sampler.sampler.sampler[239],DATA32);
SIGNAL(TRLO_SAMPLER_S241,los_sampler.sampler.sampler[240],DATA32);
SIGNAL(TRLO_SAMPLER_S242,los_sampler.sampler.sampler[241],DATA32);
SIGNAL(TRLO_SAMPLER_S243,los_sampler.sampler.sampler[242],DATA32);
SIGNAL(TRLO_SAMPLER_S244,los_sampler.sampler.sampler[243],DATA32);
SIGNAL(TRLO_SAMPLER_S245,los_sampler.sampler.sampler[244],DATA32);
SIGNAL(TRLO_SAMPLER_S246,los_sampler.sampler.sampler[245],DATA32);
SIGNAL(TRLO_SAMPLER_S247,los_sampler.sampler.sampler[246],DATA32);
SIGNAL(TRLO_SAMPLER_S248,los_sampler.sampler.sampler[247],DATA32);
SIGNAL(TRLO_SAMPLER_S249,los_sampler.sampler.sampler[248],DATA32);
SIGNAL(TRLO_SAMPLER_S25,los_sampler.sampler.sampler[24],DATA32);
SIGNAL(TRLO_SAMPLER_S250,los_sampler.sampler.sampler[249],DATA32);
SIGNAL(TRLO_SAMPLER_S251,los_sampler.sampler.sampler[250],DATA32);
SIGNAL(TRLO_SAMPLER_S252,los_sampler.sampler.sampler[251],DATA32);
SIGNAL(TRLO_SAMPLER_S253,los_sampler.sampler.sampler[252],DATA32);
SIGNAL(TRLO_SAMPLER_S254,los_sampler.sampler.sampler[253],DATA32);
SIGNAL(TRLO_SAMPLER_S255,los_sampler.sampler.sampler[254],DATA32);
SIGNAL(TRLO_SAMPLER_S256,los_sampler.sampler.sampler[255],DATA32);
SIGNAL(TRLO_SAMPLER_S257,los_sampler.sampler.sampler[256],DATA32);
SIGNAL(TRLO_SAMPLER_S258,los_sampler.sampler.sampler[257],DATA32);
SIGNAL(TRLO_SAMPLER_S259,los_sampler.sampler.sampler[258],DATA32);
SIGNAL(TRLO_SAMPLER_S26,los_sampler.sampler.sampler[25],DATA32);
SIGNAL(TRLO_SAMPLER_S260,los_sampler.sampler.sampler[259],DATA32);
SIGNAL(TRLO_SAMPLER_S261,los_sampler.sampler.sampler[260],DATA32);
SIGNAL(TRLO_SAMPLER_S262,los_sampler.sampler.sampler[261],DATA32);
SIGNAL(TRLO_SAMPLER_S263,los_sampler.sampler.sampler[262],DATA32);
SIGNAL(TRLO_SAMPLER_S264,los_sampler.sampler.sampler[263],DATA32);
SIGNAL(TRLO_SAMPLER_S265,los_sampler.sampler.sampler[264],DATA32);
SIGNAL(TRLO_SAMPLER_S266,los_sampler.sampler.sampler[265],DATA32);
SIGNAL(TRLO_SAMPLER_S267,los_sampler.sampler.sampler[266],DATA32);
SIGNAL(TRLO_SAMPLER_S268,los_sampler.sampler.sampler[267],DATA32);
SIGNAL(TRLO_SAMPLER_S269,los_sampler.sampler.sampler[268],DATA32);
SIGNAL(TRLO_SAMPLER_S27,los_sampler.sampler.sampler[26],DATA32);
SIGNAL(TRLO_SAMPLER_S270,los_sampler.sampler.sampler[269],DATA32);
SIGNAL(TRLO_SAMPLER_S271,los_sampler.sampler.sampler[270],DATA32);
SIGNAL(TRLO_SAMPLER_S272,los_sampler.sampler.sampler[271],DATA32);
SIGNAL(TRLO_SAMPLER_S273,los_sampler.sampler.sampler[272],DATA32);
SIGNAL(TRLO_SAMPLER_S274,los_sampler.sampler.sampler[273],DATA32);
SIGNAL(TRLO_SAMPLER_S275,los_sampler.sampler.sampler[274],DATA32);
SIGNAL(TRLO_SAMPLER_S276,los_sampler.sampler.sampler[275],DATA32);
SIGNAL(TRLO_SAMPLER_S277,los_sampler.sampler.sampler[276],DATA32);
SIGNAL(TRLO_SAMPLER_S278,los_sampler.sampler.sampler[277],DATA32);
SIGNAL(TRLO_SAMPLER_S279,los_sampler.sampler.sampler[278],DATA32);
SIGNAL(TRLO_SAMPLER_S28,los_sampler.sampler.sampler[27],DATA32);
SIGNAL(TRLO_SAMPLER_S280,los_sampler.sampler.sampler[279],DATA32);
SIGNAL(TRLO_SAMPLER_S281,los_sampler.sampler.sampler[280],DATA32);
SIGNAL(TRLO_SAMPLER_S282,los_sampler.sampler.sampler[281],DATA32);
SIGNAL(TRLO_SAMPLER_S283,los_sampler.sampler.sampler[282],DATA32);
SIGNAL(TRLO_SAMPLER_S284,los_sampler.sampler.sampler[283],DATA32);
SIGNAL(TRLO_SAMPLER_S285,los_sampler.sampler.sampler[284],DATA32);
SIGNAL(TRLO_SAMPLER_S286,los_sampler.sampler.sampler[285],DATA32);
SIGNAL(TRLO_SAMPLER_S287,los_sampler.sampler.sampler[286],DATA32);
SIGNAL(TRLO_SAMPLER_S288,los_sampler.sampler.sampler[287],DATA32);
SIGNAL(TRLO_SAMPLER_S289,los_sampler.sampler.sampler[288],DATA32);
SIGNAL(TRLO_SAMPLER_S29,los_sampler.sampler.sampler[28],DATA32);
SIGNAL(TRLO_SAMPLER_S290,los_sampler.sampler.sampler[289],DATA32);
SIGNAL(TRLO_SAMPLER_S291,los_sampler.sampler.sampler[290],DATA32);
SIGNAL(TRLO_SAMPLER_S292,los_sampler.sampler.sampler[291],DATA32);
SIGNAL(TRLO_SAMPLER_S293,los_sampler.sampler.sampler[292],DATA32);
SIGNAL(TRLO_SAMPLER_S294,los_sampler.sampler.sampler[293],DATA32);
SIGNAL(TRLO_SAMPLER_S295,los_sampler.sampler.sampler[294],DATA32);
SIGNAL(TRLO_SAMPLER_S296,los_sampler.sampler.sampler[295],DATA32);
SIGNAL(TRLO_SAMPLER_S297,los_sampler.sampler.sampler[296],DATA32);
SIGNAL(TRLO_SAMPLER_S298,los_sampler.sampler.sampler[297],DATA32);
SIGNAL(TRLO_SAMPLER_S299,los_sampler.sampler.sampler[298],DATA32);
SIGNAL(TRLO_SAMPLER_S3,los_sampler.sampler.sampler[2],DATA32);
SIGNAL(TRLO_SAMPLER_S30,los_sampler.sampler.sampler[29],DATA32);
SIGNAL(TRLO_SAMPLER_S300,los_sampler.sampler.sampler[299],DATA32);
SIGNAL(TRLO_SAMPLER_S301,los_sampler.sampler.sampler[300],DATA32);
SIGNAL(TRLO_SAMPLER_S302,los_sampler.sampler.sampler[301],DATA32);
SIGNAL(TRLO_SAMPLER_S303,los_sampler.sampler.sampler[302],DATA32);
SIGNAL(TRLO_SAMPLER_S304,los_sampler.sampler.sampler[303],DATA32);
SIGNAL(TRLO_SAMPLER_S305,los_sampler.sampler.sampler[304],DATA32);
SIGNAL(TRLO_SAMPLER_S306,los_sampler.sampler.sampler[305],DATA32);
SIGNAL(TRLO_SAMPLER_S307,los_sampler.sampler.sampler[306],DATA32);
SIGNAL(TRLO_SAMPLER_S308,los_sampler.sampler.sampler[307],DATA32);
SIGNAL(TRLO_SAMPLER_S309,los_sampler.sampler.sampler[308],DATA32);
SIGNAL(TRLO_SAMPLER_S31,los_sampler.sampler.sampler[30],DATA32);
SIGNAL(TRLO_SAMPLER_S310,los_sampler.sampler.sampler[309],DATA32);
SIGNAL(TRLO_SAMPLER_S311,los_sampler.sampler.sampler[310],DATA32);
SIGNAL(TRLO_SAMPLER_S312,los_sampler.sampler.sampler[311],DATA32);
SIGNAL(TRLO_SAMPLER_S313,los_sampler.sampler.sampler[312],DATA32);
SIGNAL(TRLO_SAMPLER_S314,los_sampler.sampler.sampler[313],DATA32);
SIGNAL(TRLO_SAMPLER_S315,los_sampler.sampler.sampler[314],DATA32);
SIGNAL(TRLO_SAMPLER_S316,los_sampler.sampler.sampler[315],DATA32);
SIGNAL(TRLO_SAMPLER_S317,los_sampler.sampler.sampler[316],DATA32);
SIGNAL(TRLO_SAMPLER_S318,los_sampler.sampler.sampler[317],DATA32);
SIGNAL(TRLO_SAMPLER_S319,los_sampler.sampler.sampler[318],DATA32);
SIGNAL(TRLO_SAMPLER_S32,los_sampler.sampler.sampler[31],DATA32);
SIGNAL(TRLO_SAMPLER_S320,los_sampler.sampler.sampler[319],DATA32);
SIGNAL(TRLO_SAMPLER_S321,los_sampler.sampler.sampler[320],DATA32);
SIGNAL(TRLO_SAMPLER_S322,los_sampler.sampler.sampler[321],DATA32);
SIGNAL(TRLO_SAMPLER_S323,los_sampler.sampler.sampler[322],DATA32);
SIGNAL(TRLO_SAMPLER_S324,los_sampler.sampler.sampler[323],DATA32);
SIGNAL(TRLO_SAMPLER_S325,los_sampler.sampler.sampler[324],DATA32);
SIGNAL(TRLO_SAMPLER_S326,los_sampler.sampler.sampler[325],DATA32);
SIGNAL(TRLO_SAMPLER_S327,los_sampler.sampler.sampler[326],DATA32);
SIGNAL(TRLO_SAMPLER_S328,los_sampler.sampler.sampler[327],DATA32);
SIGNAL(TRLO_SAMPLER_S329,los_sampler.sampler.sampler[328],DATA32);
SIGNAL(TRLO_SAMPLER_S33,los_sampler.sampler.sampler[32],DATA32);
SIGNAL(TRLO_SAMPLER_S330,los_sampler.sampler.sampler[329],DATA32);
SIGNAL(TRLO_SAMPLER_S331,los_sampler.sampler.sampler[330],DATA32);
SIGNAL(TRLO_SAMPLER_S332,los_sampler.sampler.sampler[331],DATA32);
SIGNAL(TRLO_SAMPLER_S333,los_sampler.sampler.sampler[332],DATA32);
SIGNAL(TRLO_SAMPLER_S334,los_sampler.sampler.sampler[333],DATA32);
SIGNAL(TRLO_SAMPLER_S335,los_sampler.sampler.sampler[334],DATA32);
SIGNAL(TRLO_SAMPLER_S336,los_sampler.sampler.sampler[335],DATA32);
SIGNAL(TRLO_SAMPLER_S337,los_sampler.sampler.sampler[336],DATA32);
SIGNAL(TRLO_SAMPLER_S338,los_sampler.sampler.sampler[337],DATA32);
SIGNAL(TRLO_SAMPLER_S339,los_sampler.sampler.sampler[338],DATA32);
SIGNAL(TRLO_SAMPLER_S34,los_sampler.sampler.sampler[33],DATA32);
SIGNAL(TRLO_SAMPLER_S340,los_sampler.sampler.sampler[339],DATA32);
SIGNAL(TRLO_SAMPLER_S341,los_sampler.sampler.sampler[340],DATA32);
SIGNAL(TRLO_SAMPLER_S342,los_sampler.sampler.sampler[341],DATA32);
SIGNAL(TRLO_SAMPLER_S343,los_sampler.sampler.sampler[342],DATA32);
SIGNAL(TRLO_SAMPLER_S344,los_sampler.sampler.sampler[343],DATA32);
SIGNAL(TRLO_SAMPLER_S345,los_sampler.sampler.sampler[344],DATA32);
SIGNAL(TRLO_SAMPLER_S346,los_sampler.sampler.sampler[345],DATA32);
SIGNAL(TRLO_SAMPLER_S347,los_sampler.sampler.sampler[346],DATA32);
SIGNAL(TRLO_SAMPLER_S348,los_sampler.sampler.sampler[347],DATA32);
SIGNAL(TRLO_SAMPLER_S349,los_sampler.sampler.sampler[348],DATA32);
SIGNAL(TRLO_SAMPLER_S35,los_sampler.sampler.sampler[34],DATA32);
SIGNAL(TRLO_SAMPLER_S350,los_sampler.sampler.sampler[349],DATA32);
SIGNAL(TRLO_SAMPLER_S351,los_sampler.sampler.sampler[350],DATA32);
SIGNAL(TRLO_SAMPLER_S352,los_sampler.sampler.sampler[351],DATA32);
SIGNAL(TRLO_SAMPLER_S353,los_sampler.sampler.sampler[352],DATA32);
SIGNAL(TRLO_SAMPLER_S354,los_sampler.sampler.sampler[353],DATA32);
SIGNAL(TRLO_SAMPLER_S355,los_sampler.sampler.sampler[354],DATA32);
SIGNAL(TRLO_SAMPLER_S356,los_sampler.sampler.sampler[355],DATA32);
SIGNAL(TRLO_SAMPLER_S357,los_sampler.sampler.sampler[356],DATA32);
SIGNAL(TRLO_SAMPLER_S358,los_sampler.sampler.sampler[357],DATA32);
SIGNAL(TRLO_SAMPLER_S359,los_sampler.sampler.sampler[358],DATA32);
SIGNAL(TRLO_SAMPLER_S36,los_sampler.sampler.sampler[35],DATA32);
SIGNAL(TRLO_SAMPLER_S360,los_sampler.sampler.sampler[359],DATA32);
SIGNAL(TRLO_SAMPLER_S361,los_sampler.sampler.sampler[360],DATA32);
SIGNAL(TRLO_SAMPLER_S362,los_sampler.sampler.sampler[361],DATA32);
SIGNAL(TRLO_SAMPLER_S363,los_sampler.sampler.sampler[362],DATA32);
SIGNAL(TRLO_SAMPLER_S364,los_sampler.sampler.sampler[363],DATA32);
SIGNAL(TRLO_SAMPLER_S365,los_sampler.sampler.sampler[364],DATA32);
SIGNAL(TRLO_SAMPLER_S366,los_sampler.sampler.sampler[365],DATA32);
SIGNAL(TRLO_SAMPLER_S367,los_sampler.sampler.sampler[366],DATA32);
SIGNAL(TRLO_SAMPLER_S368,los_sampler.sampler.sampler[367],DATA32);
SIGNAL(TRLO_SAMPLER_S369,los_sampler.sampler.sampler[368],DATA32);
SIGNAL(TRLO_SAMPLER_S37,los_sampler.sampler.sampler[36],DATA32);
SIGNAL(TRLO_SAMPLER_S370,los_sampler.sampler.sampler[369],DATA32);
SIGNAL(TRLO_SAMPLER_S371,los_sampler.sampler.sampler[370],DATA32);
SIGNAL(TRLO_SAMPLER_S372,los_sampler.sampler.sampler[371],DATA32);
SIGNAL(TRLO_SAMPLER_S373,los_sampler.sampler.sampler[372],DATA32);
SIGNAL(TRLO_SAMPLER_S374,los_sampler.sampler.sampler[373],DATA32);
SIGNAL(TRLO_SAMPLER_S375,los_sampler.sampler.sampler[374],DATA32);
SIGNAL(TRLO_SAMPLER_S376,los_sampler.sampler.sampler[375],DATA32);
SIGNAL(TRLO_SAMPLER_S377,los_sampler.sampler.sampler[376],DATA32);
SIGNAL(TRLO_SAMPLER_S378,los_sampler.sampler.sampler[377],DATA32);
SIGNAL(TRLO_SAMPLER_S379,los_sampler.sampler.sampler[378],DATA32);
SIGNAL(TRLO_SAMPLER_S38,los_sampler.sampler.sampler[37],DATA32);
SIGNAL(TRLO_SAMPLER_S380,los_sampler.sampler.sampler[379],DATA32);
SIGNAL(TRLO_SAMPLER_S381,los_sampler.sampler.sampler[380],DATA32);
SIGNAL(TRLO_SAMPLER_S382,los_sampler.sampler.sampler[381],DATA32);
SIGNAL(TRLO_SAMPLER_S383,los_sampler.sampler.sampler[382],DATA32);
SIGNAL(TRLO_SAMPLER_S384,los_sampler.sampler.sampler[383],DATA32);
SIGNAL(TRLO_SAMPLER_S385,los_sampler.sampler.sampler[384],DATA32);
SIGNAL(TRLO_SAMPLER_S386,los_sampler.sampler.sampler[385],DATA32);
SIGNAL(TRLO_SAMPLER_S387,los_sampler.sampler.sampler[386],DATA32);
SIGNAL(TRLO_SAMPLER_S388,los_sampler.sampler.sampler[387],DATA32);
SIGNAL(TRLO_SAMPLER_S389,los_sampler.sampler.sampler[388],DATA32);
SIGNAL(TRLO_SAMPLER_S39,los_sampler.sampler.sampler[38],DATA32);
SIGNAL(TRLO_SAMPLER_S390,los_sampler.sampler.sampler[389],DATA32);
SIGNAL(TRLO_SAMPLER_S391,los_sampler.sampler.sampler[390],DATA32);
SIGNAL(TRLO_SAMPLER_S392,los_sampler.sampler.sampler[391],DATA32);
SIGNAL(TRLO_SAMPLER_S393,los_sampler.sampler.sampler[392],DATA32);
SIGNAL(TRLO_SAMPLER_S394,los_sampler.sampler.sampler[393],DATA32);
SIGNAL(TRLO_SAMPLER_S395,los_sampler.sampler.sampler[394],DATA32);
SIGNAL(TRLO_SAMPLER_S396,los_sampler.sampler.sampler[395],DATA32);
SIGNAL(TRLO_SAMPLER_S397,los_sampler.sampler.sampler[396],DATA32);
SIGNAL(TRLO_SAMPLER_S398,los_sampler.sampler.sampler[397],DATA32);
SIGNAL(TRLO_SAMPLER_S399,los_sampler.sampler.sampler[398],DATA32);
SIGNAL(TRLO_SAMPLER_S4,los_sampler.sampler.sampler[3],DATA32);
SIGNAL(TRLO_SAMPLER_S40,los_sampler.sampler.sampler[39],DATA32);
SIGNAL(TRLO_SAMPLER_S400,los_sampler.sampler.sampler[399],DATA32);
SIGNAL(TRLO_SAMPLER_S401,los_sampler.sampler.sampler[400],DATA32);
SIGNAL(TRLO_SAMPLER_S402,los_sampler.sampler.sampler[401],DATA32);
SIGNAL(TRLO_SAMPLER_S403,los_sampler.sampler.sampler[402],DATA32);
SIGNAL(TRLO_SAMPLER_S404,los_sampler.sampler.sampler[403],DATA32);
SIGNAL(TRLO_SAMPLER_S405,los_sampler.sampler.sampler[404],DATA32);
SIGNAL(TRLO_SAMPLER_S406,los_sampler.sampler.sampler[405],DATA32);
SIGNAL(TRLO_SAMPLER_S407,los_sampler.sampler.sampler[406],DATA32);
SIGNAL(TRLO_SAMPLER_S408,los_sampler.sampler.sampler[407],DATA32);
SIGNAL(TRLO_SAMPLER_S409,los_sampler.sampler.sampler[408],DATA32);
SIGNAL(TRLO_SAMPLER_S41,los_sampler.sampler.sampler[40],DATA32);
SIGNAL(TRLO_SAMPLER_S410,los_sampler.sampler.sampler[409],DATA32);
SIGNAL(TRLO_SAMPLER_S411,los_sampler.sampler.sampler[410],DATA32);
SIGNAL(TRLO_SAMPLER_S412,los_sampler.sampler.sampler[411],DATA32);
SIGNAL(TRLO_SAMPLER_S413,los_sampler.sampler.sampler[412],DATA32);
SIGNAL(TRLO_SAMPLER_S414,los_sampler.sampler.sampler[413],DATA32);
SIGNAL(TRLO_SAMPLER_S415,los_sampler.sampler.sampler[414],DATA32);
SIGNAL(TRLO_SAMPLER_S416,los_sampler.sampler.sampler[415],DATA32);
SIGNAL(TRLO_SAMPLER_S417,los_sampler.sampler.sampler[416],DATA32);
SIGNAL(TRLO_SAMPLER_S418,los_sampler.sampler.sampler[417],DATA32);
SIGNAL(TRLO_SAMPLER_S419,los_sampler.sampler.sampler[418],DATA32);
SIGNAL(TRLO_SAMPLER_S42,los_sampler.sampler.sampler[41],DATA32);
SIGNAL(TRLO_SAMPLER_S420,los_sampler.sampler.sampler[419],DATA32);
SIGNAL(TRLO_SAMPLER_S421,los_sampler.sampler.sampler[420],DATA32);
SIGNAL(TRLO_SAMPLER_S422,los_sampler.sampler.sampler[421],DATA32);
SIGNAL(TRLO_SAMPLER_S423,los_sampler.sampler.sampler[422],DATA32);
SIGNAL(TRLO_SAMPLER_S424,los_sampler.sampler.sampler[423],DATA32);
SIGNAL(TRLO_SAMPLER_S425,los_sampler.sampler.sampler[424],DATA32);
SIGNAL(TRLO_SAMPLER_S426,los_sampler.sampler.sampler[425],DATA32);
SIGNAL(TRLO_SAMPLER_S427,los_sampler.sampler.sampler[426],DATA32);
SIGNAL(TRLO_SAMPLER_S428,los_sampler.sampler.sampler[427],DATA32);
SIGNAL(TRLO_SAMPLER_S429,los_sampler.sampler.sampler[428],DATA32);
SIGNAL(TRLO_SAMPLER_S43,los_sampler.sampler.sampler[42],DATA32);
SIGNAL(TRLO_SAMPLER_S430,los_sampler.sampler.sampler[429],DATA32);
SIGNAL(TRLO_SAMPLER_S431,los_sampler.sampler.sampler[430],DATA32);
SIGNAL(TRLO_SAMPLER_S432,los_sampler.sampler.sampler[431],DATA32);
SIGNAL(TRLO_SAMPLER_S433,los_sampler.sampler.sampler[432],DATA32);
SIGNAL(TRLO_SAMPLER_S434,los_sampler.sampler.sampler[433],DATA32);
SIGNAL(TRLO_SAMPLER_S435,los_sampler.sampler.sampler[434],DATA32);
SIGNAL(TRLO_SAMPLER_S436,los_sampler.sampler.sampler[435],DATA32);
SIGNAL(TRLO_SAMPLER_S437,los_sampler.sampler.sampler[436],DATA32);
SIGNAL(TRLO_SAMPLER_S438,los_sampler.sampler.sampler[437],DATA32);
SIGNAL(TRLO_SAMPLER_S439,los_sampler.sampler.sampler[438],DATA32);
SIGNAL(TRLO_SAMPLER_S44,los_sampler.sampler.sampler[43],DATA32);
SIGNAL(TRLO_SAMPLER_S440,los_sampler.sampler.sampler[439],DATA32);
SIGNAL(TRLO_SAMPLER_S441,los_sampler.sampler.sampler[440],DATA32);
SIGNAL(TRLO_SAMPLER_S442,los_sampler.sampler.sampler[441],DATA32);
SIGNAL(TRLO_SAMPLER_S443,los_sampler.sampler.sampler[442],DATA32);
SIGNAL(TRLO_SAMPLER_S444,los_sampler.sampler.sampler[443],DATA32);
SIGNAL(TRLO_SAMPLER_S445,los_sampler.sampler.sampler[444],DATA32);
SIGNAL(TRLO_SAMPLER_S446,los_sampler.sampler.sampler[445],DATA32);
SIGNAL(TRLO_SAMPLER_S447,los_sampler.sampler.sampler[446],DATA32);
SIGNAL(TRLO_SAMPLER_S448,los_sampler.sampler.sampler[447],DATA32);
SIGNAL(TRLO_SAMPLER_S449,los_sampler.sampler.sampler[448],DATA32);
SIGNAL(TRLO_SAMPLER_S45,los_sampler.sampler.sampler[44],DATA32);
SIGNAL(TRLO_SAMPLER_S450,los_sampler.sampler.sampler[449],DATA32);
SIGNAL(TRLO_SAMPLER_S451,los_sampler.sampler.sampler[450],DATA32);
SIGNAL(TRLO_SAMPLER_S452,los_sampler.sampler.sampler[451],DATA32);
SIGNAL(TRLO_SAMPLER_S453,los_sampler.sampler.sampler[452],DATA32);
SIGNAL(TRLO_SAMPLER_S454,los_sampler.sampler.sampler[453],DATA32);
SIGNAL(TRLO_SAMPLER_S455,los_sampler.sampler.sampler[454],DATA32);
SIGNAL(TRLO_SAMPLER_S456,los_sampler.sampler.sampler[455],DATA32);
SIGNAL(TRLO_SAMPLER_S457,los_sampler.sampler.sampler[456],DATA32);
SIGNAL(TRLO_SAMPLER_S458,los_sampler.sampler.sampler[457],DATA32);
SIGNAL(TRLO_SAMPLER_S459,los_sampler.sampler.sampler[458],DATA32);
SIGNAL(TRLO_SAMPLER_S46,los_sampler.sampler.sampler[45],DATA32);
SIGNAL(TRLO_SAMPLER_S460,los_sampler.sampler.sampler[459],DATA32);
SIGNAL(TRLO_SAMPLER_S461,los_sampler.sampler.sampler[460],DATA32);
SIGNAL(TRLO_SAMPLER_S462,los_sampler.sampler.sampler[461],DATA32);
SIGNAL(TRLO_SAMPLER_S463,los_sampler.sampler.sampler[462],DATA32);
SIGNAL(TRLO_SAMPLER_S464,los_sampler.sampler.sampler[463],DATA32);
SIGNAL(TRLO_SAMPLER_S465,los_sampler.sampler.sampler[464],DATA32);
SIGNAL(TRLO_SAMPLER_S466,los_sampler.sampler.sampler[465],DATA32);
SIGNAL(TRLO_SAMPLER_S467,los_sampler.sampler.sampler[466],DATA32);
SIGNAL(TRLO_SAMPLER_S468,los_sampler.sampler.sampler[467],DATA32);
SIGNAL(TRLO_SAMPLER_S469,los_sampler.sampler.sampler[468],DATA32);
SIGNAL(TRLO_SAMPLER_S47,los_sampler.sampler.sampler[46],DATA32);
SIGNAL(TRLO_SAMPLER_S470,los_sampler.sampler.sampler[469],DATA32);
SIGNAL(TRLO_SAMPLER_S471,los_sampler.sampler.sampler[470],DATA32);
SIGNAL(TRLO_SAMPLER_S472,los_sampler.sampler.sampler[471],DATA32);
SIGNAL(TRLO_SAMPLER_S473,los_sampler.sampler.sampler[472],DATA32);
SIGNAL(TRLO_SAMPLER_S474,los_sampler.sampler.sampler[473],DATA32);
SIGNAL(TRLO_SAMPLER_S475,los_sampler.sampler.sampler[474],DATA32);
SIGNAL(TRLO_SAMPLER_S476,los_sampler.sampler.sampler[475],DATA32);
SIGNAL(TRLO_SAMPLER_S477,los_sampler.sampler.sampler[476],DATA32);
SIGNAL(TRLO_SAMPLER_S478,los_sampler.sampler.sampler[477],DATA32);
SIGNAL(TRLO_SAMPLER_S479,los_sampler.sampler.sampler[478],DATA32);
SIGNAL(TRLO_SAMPLER_S48,los_sampler.sampler.sampler[47],DATA32);
SIGNAL(TRLO_SAMPLER_S480,los_sampler.sampler.sampler[479],DATA32);
SIGNAL(TRLO_SAMPLER_S481,los_sampler.sampler.sampler[480],DATA32);
SIGNAL(TRLO_SAMPLER_S482,los_sampler.sampler.sampler[481],DATA32);
SIGNAL(TRLO_SAMPLER_S483,los_sampler.sampler.sampler[482],DATA32);
SIGNAL(TRLO_SAMPLER_S484,los_sampler.sampler.sampler[483],DATA32);
SIGNAL(TRLO_SAMPLER_S485,los_sampler.sampler.sampler[484],DATA32);
SIGNAL(TRLO_SAMPLER_S486,los_sampler.sampler.sampler[485],DATA32);
SIGNAL(TRLO_SAMPLER_S487,los_sampler.sampler.sampler[486],DATA32);
SIGNAL(TRLO_SAMPLER_S488,los_sampler.sampler.sampler[487],DATA32);
SIGNAL(TRLO_SAMPLER_S489,los_sampler.sampler.sampler[488],DATA32);
SIGNAL(TRLO_SAMPLER_S49,los_sampler.sampler.sampler[48],DATA32);
SIGNAL(TRLO_SAMPLER_S490,los_sampler.sampler.sampler[489],DATA32);
SIGNAL(TRLO_SAMPLER_S491,los_sampler.sampler.sampler[490],DATA32);
SIGNAL(TRLO_SAMPLER_S492,los_sampler.sampler.sampler[491],DATA32);
SIGNAL(TRLO_SAMPLER_S493,los_sampler.sampler.sampler[492],DATA32);
SIGNAL(TRLO_SAMPLER_S494,los_sampler.sampler.sampler[493],DATA32);
SIGNAL(TRLO_SAMPLER_S495,los_sampler.sampler.sampler[494],DATA32);
SIGNAL(TRLO_SAMPLER_S496,los_sampler.sampler.sampler[495],DATA32);
SIGNAL(TRLO_SAMPLER_S497,los_sampler.sampler.sampler[496],DATA32);
SIGNAL(TRLO_SAMPLER_S498,los_sampler.sampler.sampler[497],DATA32);
SIGNAL(TRLO_SAMPLER_S499,los_sampler.sampler.sampler[498],DATA32);
SIGNAL(TRLO_SAMPLER_S5,los_sampler.sampler.sampler[4],DATA32);
SIGNAL(TRLO_SAMPLER_S50,los_sampler.sampler.sampler[49],DATA32);
SIGNAL(TRLO_SAMPLER_S500,los_sampler.sampler.sampler[499],DATA32);
SIGNAL(TRLO_SAMPLER_S501,los_sampler.sampler.sampler[500],DATA32);
SIGNAL(TRLO_SAMPLER_S502,los_sampler.sampler.sampler[501],DATA32);
SIGNAL(TRLO_SAMPLER_S503,los_sampler.sampler.sampler[502],DATA32);
SIGNAL(TRLO_SAMPLER_S504,los_sampler.sampler.sampler[503],DATA32);
SIGNAL(TRLO_SAMPLER_S505,los_sampler.sampler.sampler[504],DATA32);
SIGNAL(TRLO_SAMPLER_S506,los_sampler.sampler.sampler[505],DATA32);
SIGNAL(TRLO_SAMPLER_S507,los_sampler.sampler.sampler[506],DATA32);
SIGNAL(TRLO_SAMPLER_S508,los_sampler.sampler.sampler[507],DATA32);
SIGNAL(TRLO_SAMPLER_S509,los_sampler.sampler.sampler[508],DATA32);
SIGNAL(TRLO_SAMPLER_S51,los_sampler.sampler.sampler[50],DATA32);
SIGNAL(TRLO_SAMPLER_S510,los_sampler.sampler.sampler[509],DATA32);
SIGNAL(TRLO_SAMPLER_S511,los_sampler.sampler.sampler[510],DATA32);
SIGNAL(TRLO_SAMPLER_S512,los_sampler.sampler.sampler[511],DATA32);
SIGNAL(TRLO_SAMPLER_S52,los_sampler.sampler.sampler[51],DATA32);
SIGNAL(TRLO_SAMPLER_S53,los_sampler.sampler.sampler[52],DATA32);
SIGNAL(TRLO_SAMPLER_S54,los_sampler.sampler.sampler[53],DATA32);
SIGNAL(TRLO_SAMPLER_S55,los_sampler.sampler.sampler[54],DATA32);
SIGNAL(TRLO_SAMPLER_S56,los_sampler.sampler.sampler[55],DATA32);
SIGNAL(TRLO_SAMPLER_S57,los_sampler.sampler.sampler[56],DATA32);
SIGNAL(TRLO_SAMPLER_S58,los_sampler.sampler.sampler[57],DATA32);
SIGNAL(TRLO_SAMPLER_S59,los_sampler.sampler.sampler[58],DATA32);
SIGNAL(TRLO_SAMPLER_S6,los_sampler.sampler.sampler[5],DATA32);
SIGNAL(TRLO_SAMPLER_S60,los_sampler.sampler.sampler[59],DATA32);
SIGNAL(TRLO_SAMPLER_S61,los_sampler.sampler.sampler[60],DATA32);
SIGNAL(TRLO_SAMPLER_S62,los_sampler.sampler.sampler[61],DATA32);
SIGNAL(TRLO_SAMPLER_S63,los_sampler.sampler.sampler[62],DATA32);
SIGNAL(TRLO_SAMPLER_S64,los_sampler.sampler.sampler[63],DATA32);
SIGNAL(TRLO_SAMPLER_S65,los_sampler.sampler.sampler[64],DATA32);
SIGNAL(TRLO_SAMPLER_S66,los_sampler.sampler.sampler[65],DATA32);
SIGNAL(TRLO_SAMPLER_S67,los_sampler.sampler.sampler[66],DATA32);
SIGNAL(TRLO_SAMPLER_S68,los_sampler.sampler.sampler[67],DATA32);
SIGNAL(TRLO_SAMPLER_S69,los_sampler.sampler.sampler[68],DATA32);
SIGNAL(TRLO_SAMPLER_S7,los_sampler.sampler.sampler[6],DATA32);
SIGNAL(TRLO_SAMPLER_S70,los_sampler.sampler.sampler[69],DATA32);
SIGNAL(TRLO_SAMPLER_S71,los_sampler.sampler.sampler[70],DATA32);
SIGNAL(TRLO_SAMPLER_S72,los_sampler.sampler.sampler[71],DATA32);
SIGNAL(TRLO_SAMPLER_S73,los_sampler.sampler.sampler[72],DATA32);
SIGNAL(TRLO_SAMPLER_S74,los_sampler.sampler.sampler[73],DATA32);
SIGNAL(TRLO_SAMPLER_S75,los_sampler.sampler.sampler[74],DATA32);
SIGNAL(TRLO_SAMPLER_S76,los_sampler.sampler.sampler[75],DATA32);
SIGNAL(TRLO_SAMPLER_S77,los_sampler.sampler.sampler[76],DATA32);
SIGNAL(TRLO_SAMPLER_S78,los_sampler.sampler.sampler[77],DATA32);
SIGNAL(TRLO_SAMPLER_S79,los_sampler.sampler.sampler[78],DATA32);
SIGNAL(TRLO_SAMPLER_S8,los_sampler.sampler.sampler[7],DATA32);
SIGNAL(TRLO_SAMPLER_S80,los_sampler.sampler.sampler[79],DATA32);
SIGNAL(TRLO_SAMPLER_S81,los_sampler.sampler.sampler[80],DATA32);
SIGNAL(TRLO_SAMPLER_S82,los_sampler.sampler.sampler[81],DATA32);
SIGNAL(TRLO_SAMPLER_S83,los_sampler.sampler.sampler[82],DATA32);
SIGNAL(TRLO_SAMPLER_S84,los_sampler.sampler.sampler[83],DATA32);
SIGNAL(TRLO_SAMPLER_S85,los_sampler.sampler.sampler[84],DATA32);
SIGNAL(TRLO_SAMPLER_S86,los_sampler.sampler.sampler[85],DATA32);
SIGNAL(TRLO_SAMPLER_S87,los_sampler.sampler.sampler[86],DATA32);
SIGNAL(TRLO_SAMPLER_S88,los_sampler.sampler.sampler[87],DATA32);
SIGNAL(TRLO_SAMPLER_S89,los_sampler.sampler.sampler[88],DATA32);
SIGNAL(TRLO_SAMPLER_S9,los_sampler.sampler.sampler[8],DATA32);
SIGNAL(TRLO_SAMPLER_S90,los_sampler.sampler.sampler[89],DATA32);
SIGNAL(TRLO_SAMPLER_S91,los_sampler.sampler.sampler[90],DATA32);
SIGNAL(TRLO_SAMPLER_S92,los_sampler.sampler.sampler[91],DATA32);
SIGNAL(TRLO_SAMPLER_S93,los_sampler.sampler.sampler[92],DATA32);
SIGNAL(TRLO_SAMPLER_S94,los_sampler.sampler.sampler[93],DATA32);
SIGNAL(TRLO_SAMPLER_S95,los_sampler.sampler.sampler[94],DATA32);
SIGNAL(TRLO_SAMPLER_S96,los_sampler.sampler.sampler[95],DATA32);
SIGNAL(TRLO_SAMPLER_S97,los_sampler.sampler.sampler[96],DATA32);
SIGNAL(TRLO_SAMPLER_S98,los_sampler.sampler.sampler[97],DATA32);
SIGNAL(TRLO_SAMPLER_S99,los_sampler.sampler.sampler[98],DATA32);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T1_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T1_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T1_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T1_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T2_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T2_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T2_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P1T2_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T1_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T1_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T1_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T1_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T2_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T2_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T2_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P2T2_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T1_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T1_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T1_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T1_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T2_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T2_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T2_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P3T2_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T1_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T1_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T1_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T1_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T2_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T2_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T2_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P4T2_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T1_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T1_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T1_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T1_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T2_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T2_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T2_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P5T2_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T1_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T1_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T1_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T1_TFT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T2_TCL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T2_TCT1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T2_TFL1);
SIGNAL( ZERO_SUPPRESS_MULTI(32):TOFD_P6T2_TFT1);
SIGNAL( ZERO_SUPPRESS:TRLO_SAMPLER_S1);
/**********************************************************/

/** END_INPUT_DEFINITION **********************************************/

/**********************************************************
 * Generating unpacking code...
 */

//
// Generating code for: BARRIER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
#if !PACKER_CODE
# define DECLARED_UNPACK_BARRIER
class BARRIER
#else//PACKER_CODE
# define DECLARED_PACKER_BARRIER
class PACKER_BARRIER
#endif//PACKER_CODE

{
public:
  // UINT32 barrier
  // {
    //  0_31: 0xbabababa;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } barrier;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(BARRIER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_src_t>
void BARRIER::__unpack(__data_src_t &__buffer)
{
  // UINT32 barrier
  // {
    //  0_31: 0xbabababa;
  // }
  READ_FROM_BUFFER_FULL(13,uint32 ,barrier,barrier.u32);
  CHECK_BITS_EQUAL(12,barrier.unnamed_0_31,0xbabababa);
}
FORCE_IMPL_DATA_SRC_FCN(void,BARRIER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_src_t>
bool BARRIER::__match(__data_src_t &__buffer)
{
  // UINT32 barrier
  // {
    //  0_31: 0xbabababa;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } __barrier;
  READ_FROM_BUFFER_FULL(13,uint32 ,barrier,__barrier.u32);
  MATCH_BITS_EQUAL(12,__barrier.unnamed_0_31,0xbabababa);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,BARRIER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for BARRIER.
 *
 * Do not edit - automatically generated.
 */

// BARRIER()
template<typename __data_dest_t>
void PACKER_BARRIER::__packer(__data_dest_t &__buffer)
{
  // UINT32 barrier
  // {
    //  0_31: 0xbabababa;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,BARRIER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_BAD_EVENTHEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_BAD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_BAD_EVENTHEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_BAD_EVENTHEADER
class FEBEX_BAD_EVENTHEADER
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_BAD_EVENTHEADER
class PACKER_FEBEX_BAD_EVENTHEADER
#endif//PACKER_CODE

{
public:
  // UINT32 badbad
  // {
    //  0_31: 0xbad00bad;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } badbad;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_BAD_EVENTHEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_BAD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_BAD_EVENTHEADER()
template<typename __data_src_t>
void FEBEX_BAD_EVENTHEADER::__unpack(__data_src_t &__buffer)
{
  // UINT32 badbad
  // {
    //  0_31: 0xbad00bad;
  // }
  READ_FROM_BUFFER_FULL(21,uint32 ,badbad,badbad.u32);
  CHECK_BITS_EQUAL(20,badbad.unnamed_0_31,0xbad00bad);
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_BAD_EVENTHEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_BAD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_BAD_EVENTHEADER()
template<typename __data_src_t>
bool FEBEX_BAD_EVENTHEADER::__match(__data_src_t &__buffer)
{
  // UINT32 badbad
  // {
    //  0_31: 0xbad00bad;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } __badbad;
  READ_FROM_BUFFER_FULL(21,uint32 ,badbad,__badbad.u32);
  MATCH_BITS_EQUAL(20,__badbad.unnamed_0_31,0xbad00bad);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_BAD_EVENTHEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_BAD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_BAD_EVENTHEADER()
template<typename __data_dest_t>
void PACKER_FEBEX_BAD_EVENTHEADER::__packer(__data_dest_t &__buffer)
{
  // UINT32 badbad
  // {
    //  0_31: 0xbad00bad;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_BAD_EVENTHEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_EVENTHEADER
//
//
// Generating code for: FEBEX_GOOD_EVENTHEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_GOOD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_GOOD_EVENTHEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_GOOD_EVENTHEADER
class FEBEX_GOOD_EVENTHEADER
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_GOOD_EVENTHEADER
class PACKER_FEBEX_GOOD_EVENTHEADER
#endif//PACKER_CODE

{
public:
  // UINT32 febexcards
  // {
    //  0_07: n_febex_sfp0 = RANGE(0,64);
    //  8_15: n_febex_sfp1 = RANGE(0,64);
    // 16_23: n_febex_sfp2 = RANGE(0,64);
    // 24_31: n_febex_sfp3 = RANGE(0,64);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 n_febex_sfp0 : 8; // 0..7
      uint32 n_febex_sfp1 : 8; // 8..15
      uint32 n_febex_sfp2 : 8; // 16..23
      uint32 n_febex_sfp3 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 n_febex_sfp3 : 8; // 24..31
      uint32 n_febex_sfp2 : 8; // 16..23
      uint32 n_febex_sfp1 : 8; // 8..15
      uint32 n_febex_sfp0 : 8; // 0..7
#endif
    };
    uint32  u32;
  } febexcards;
  // UINT32 trig_length
  // {
    //  0_15: trace_length;
    // 16_31: trigger_delay;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 trace_length : 16; // 0..15
      uint32 trigger_delay : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 trigger_delay : 16; // 16..31
      uint32 trace_length : 16; // 0..15
#endif
    };
    uint32  u32;
  } trig_length;
  // UINT32 energy_filter
  // {
    //  0_10: sum_b;
    // 11_20: gap;
    // 21_31: sum_a;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 sum_b : 11; // 0..10
      uint32 gap : 10; // 11..20
      uint32 sum_a : 11; // 21..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 sum_a : 11; // 21..31
      uint32 gap : 10; // 11..20
      uint32 sum_b : 11; // 0..10
#endif
    };
    uint32  u32;
  } energy_filter;
  // UINT32 polarity1
  // {
    //  0_31: pola;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 pola : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pola : 32; // 0..31
#endif
    };
    uint32  u32;
  } polarity1;
  // UINT32 polarity2
  // {
    //  0_31: pola;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 pola : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pola : 32; // 0..31
#endif
    };
    uint32  u32;
  } polarity2;
  // UINT32 polarity3
  // {
    //  0_31: pola;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 pola : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pola : 32; // 0..31
#endif
    };
    uint32  u32;
  } polarity3;
  // UINT32 polarity4
  // {
    //  0_31: pola;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 pola : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pola : 32; // 0..31
#endif
    };
    uint32  u32;
  } polarity4;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_GOOD_EVENTHEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_GOOD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_GOOD_EVENTHEADER()
template<typename __data_src_t>
void FEBEX_GOOD_EVENTHEADER::__unpack(__data_src_t &__buffer)
{
  // UINT32 febexcards
  // {
    //  0_07: n_febex_sfp0 = RANGE(0,64);
    //  8_15: n_febex_sfp1 = RANGE(0,64);
    // 16_23: n_febex_sfp2 = RANGE(0,64);
    // 24_31: n_febex_sfp3 = RANGE(0,64);
  // }
  READ_FROM_BUFFER_FULL(41,uint32 ,febexcards,febexcards.u32);
  CHECK_BITS_RANGE_MAX(37,febexcards.n_febex_sfp0,64);
  CHECK_BITS_RANGE_MAX(38,febexcards.n_febex_sfp1,64);
  CHECK_BITS_RANGE_MAX(39,febexcards.n_febex_sfp2,64);
  CHECK_BITS_RANGE_MAX(40,febexcards.n_febex_sfp3,64);
  // UINT32 trig_length
  // {
    //  0_15: trace_length;
    // 16_31: trigger_delay;
  // }
  READ_FROM_BUFFER_FULL(46,uint32 ,trig_length,trig_length.u32);
  // UINT32 energy_filter
  // {
    //  0_10: sum_b;
    // 11_20: gap;
    // 21_31: sum_a;
  // }
  READ_FROM_BUFFER_FULL(52,uint32 ,energy_filter,energy_filter.u32);
  // UINT32 polarity1
  // {
    //  0_31: pola;
  // }
  READ_FROM_BUFFER_FULL(56,uint32 ,polarity1,polarity1.u32);
  // UINT32 polarity2
  // {
    //  0_31: pola;
  // }
  READ_FROM_BUFFER_FULL(60,uint32 ,polarity2,polarity2.u32);
  // UINT32 polarity3
  // {
    //  0_31: pola;
  // }
  READ_FROM_BUFFER_FULL(64,uint32 ,polarity3,polarity3.u32);
  // UINT32 polarity4
  // {
    //  0_31: pola;
  // }
  READ_FROM_BUFFER_FULL(68,uint32 ,polarity4,polarity4.u32);
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_GOOD_EVENTHEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_GOOD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_GOOD_EVENTHEADER()
template<typename __data_src_t>
bool FEBEX_GOOD_EVENTHEADER::__match(__data_src_t &__buffer)
{
  // UINT32 febexcards
  // {
    //  0_07: n_febex_sfp0 = RANGE(0,64);
    //  8_15: n_febex_sfp1 = RANGE(0,64);
    // 16_23: n_febex_sfp2 = RANGE(0,64);
    // 24_31: n_febex_sfp3 = RANGE(0,64);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 n_febex_sfp0 : 8; // 0..7
      uint32 n_febex_sfp1 : 8; // 8..15
      uint32 n_febex_sfp2 : 8; // 16..23
      uint32 n_febex_sfp3 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 n_febex_sfp3 : 8; // 24..31
      uint32 n_febex_sfp2 : 8; // 16..23
      uint32 n_febex_sfp1 : 8; // 8..15
      uint32 n_febex_sfp0 : 8; // 0..7
#endif
    };
    uint32  u32;
  } __febexcards;
  READ_FROM_BUFFER_FULL(41,uint32 ,febexcards,__febexcards.u32);
  MATCH_BITS_RANGE_MAX(37,__febexcards.n_febex_sfp0,64);
  MATCH_BITS_RANGE_MAX(38,__febexcards.n_febex_sfp1,64);
  MATCH_BITS_RANGE_MAX(39,__febexcards.n_febex_sfp2,64);
  MATCH_BITS_RANGE_MAX(40,__febexcards.n_febex_sfp3,64);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_GOOD_EVENTHEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_GOOD_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_GOOD_EVENTHEADER()
template<typename __data_dest_t>
void PACKER_FEBEX_GOOD_EVENTHEADER::__packer(__data_dest_t &__buffer)
{
  // UINT32 febexcards
  // {
    //  0_07: n_febex_sfp0 = RANGE(0,64);
    //  8_15: n_febex_sfp1 = RANGE(0,64);
    // 16_23: n_febex_sfp2 = RANGE(0,64);
    // 24_31: n_febex_sfp3 = RANGE(0,64);
  // }
  // UINT32 trig_length
  // {
    //  0_15: trace_length;
    // 16_31: trigger_delay;
  // }
  // UINT32 energy_filter
  // {
    //  0_10: sum_b;
    // 11_20: gap;
    // 21_31: sum_a;
  // }
  // UINT32 polarity1
  // {
    //  0_31: pola;
  // }
  // UINT32 polarity2
  // {
    //  0_31: pola;
  // }
  // UINT32 polarity3
  // {
    //  0_31: pola;
  // }
  // UINT32 polarity4
  // {
    //  0_31: pola;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_GOOD_EVENTHEADER::__packer);

/** END_PACKER ********************************************************/


/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENTHEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_EVENTHEADER
class FEBEX_EVENTHEADER
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_EVENTHEADER
class PACKER_FEBEX_EVENTHEADER
#endif//PACKER_CODE

{
public:
  // select

    // good = FEBEX_GOOD_EVENTHEADER();
    // bad = FEBEX_BAD_EVENTHEADER();
  SINGLE(FEBEX_GOOD_EVENTHEADER,good);
  SINGLE(FEBEX_BAD_EVENTHEADER,bad);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_EVENTHEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENTHEADER()
template<typename __data_src_t>
void FEBEX_EVENTHEADER::__unpack(__data_src_t &__buffer)
{
  // select

    // good = FEBEX_GOOD_EVENTHEADER();
    // bad = FEBEX_BAD_EVENTHEADER();
  do
  {
    int __match_no = 0;
    // optimized match 1: FEBEX_GOOD_EVENTHEADER good: (s32) => (0x80808080,0x00000000)
    // optimized match 2: FEBEX_BAD_EVENTHEADER bad: (s32) => (0xffffffff,0xbad00bad)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(30,uint32,__match_peek);
    // differ = bad00bad : 0 2 3 5 7 8 9 11 20 22 23 25 27 28 29 31
    MATCH_DECL_QUICK(28,__match_no,1,good,__match_peek,0x80808080,0x00000000);
    MATCH_DECL_QUICK(29,__match_no,2,bad,__match_peek,0xffffffff,0xbad00bad);
    // last_subevent_item = 0
    }
    if (!__match_no) ERROR_U_LOC(30,"No match for select statement.");
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(28,spurious_match_abort_loop_0,FEBEX_GOOD_EVENTHEADER);
        UNPACK_DECL(28,FEBEX_GOOD_EVENTHEADER,good);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(29,spurious_match_abort_loop_0,FEBEX_BAD_EVENTHEADER);
        UNPACK_DECL(29,FEBEX_BAD_EVENTHEADER,bad);
        break;
    }
  }
  while (0);
  spurious_match_abort_loop_0:;
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_EVENTHEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENTHEADER()
template<typename __data_src_t>
bool FEBEX_EVENTHEADER::__match(__data_src_t &__buffer)
{
  // select

    // good = FEBEX_GOOD_EVENTHEADER();
    // bad = FEBEX_BAD_EVENTHEADER();
  do
  {
    int __match_no = 0;
    MATCH_DECL(28,__match_no,1,FEBEX_GOOD_EVENTHEADER,good);
    MATCH_DECL(29,__match_no,2,FEBEX_BAD_EVENTHEADER,bad);
    if (!__match_no) ERROR_U_LOC(30,"No match for select statement.");
    return true;
  }
  while (0);
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_EVENTHEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_EVENTHEADER.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_EVENTHEADER()
template<typename __data_dest_t>
void PACKER_FEBEX_EVENTHEADER::__packer(__data_dest_t &__buffer)
{
  // select

    // good = FEBEX_GOOD_EVENTHEADER();
    // bad = FEBEX_BAD_EVENTHEADER();
  {
    PACK_DECL(28,FEBEX_GOOD_EVENTHEADER,good);
    PACK_DECL(29,FEBEX_BAD_EVENTHEADER,bad);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_EVENTHEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_NOTRACE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_NOTRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_NOTRACE(sfp,card)
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_NOTRACE
class FEBEX_NOTRACE
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_NOTRACE
class PACKER_FEBEX_NOTRACE
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA8 n_hit[16]);
  raw_array<DATA8,DATA8,16> n_hit;
  // MEMBER(DATA12 t[16] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA12,DATA12,16,32> t;
  // MEMBER(DATA32 e[16] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA32,DATA32,16,32> e;
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  // UINT32 data_size NOENCODE
  // {
    //  0_31: size;
  // }
  // UINT32 head NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 175;
  // }
  // UINT32 triggertime NOENCODE
  // {
    //  0_31: trigger_time;
  // }
  // UINT32 time NOENCODE
  // {
    //  0_31: time;
  // }
  // list(0<=i<((data_size.size - 16) >> 3))

    // UINT32 time NOENCODE
    // {
      //  0_10: time;
      // 11_14: unused1;
      //    15: sign;
      // 16_19: unused2;
      // 20_23: multi_hit;
      // 24_27: n_hit;
      // 28_31: channel_id;
      // ENCODE(t[channel_id],(value=((time | (sign << 11)) & 0xfff)));
      // ENCODE(n_hit[channel_id],(value=n_hit));
    // }
    // UINT32 energy NOENCODE
    // {
      //  0_21: energy;
      //    22: unused1;
      //    23: sign;
      // 24_27: unused2;
      // 28_31: channel_id;
      // ENCODE(e[channel_id],(value=(energy | (sign << 23))));
    // }
  // UINT32 trailer NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 191;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_NOTRACE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_NOTRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_NOTRACE(sfp,card)
template<typename __data_src_t>
void FEBEX_NOTRACE::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA8 n_hit[16]);
  // MEMBER(DATA12 t[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 e[16] ZERO_SUPPRESS_MULTI(32));
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  READ_FROM_BUFFER_FULL(83,uint32 ,indicator,indicator.u32);
  CHECK_BITS_EQUAL(78,indicator.unnamed_0_7,52);
  CHECK_BITS_EQUAL(80,indicator.sfp,sfp);
  CHECK_BITS_EQUAL(81,indicator.card,card);
  CHECK_BITS_EQUAL(82,indicator.unnamed_24_31,255);
  // UINT32 data_size NOENCODE
  // {
    //  0_31: size;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 32; // 0..31
#endif
    };
    uint32  u32;
  } data_size;
  READ_FROM_BUFFER_FULL(87,uint32 ,data_size,data_size.u32);
  // UINT32 head NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 175;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unused : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 unused : 24; // 0..23
#endif
    };
    uint32  u32;
  } head;
  READ_FROM_BUFFER_FULL(92,uint32 ,head,head.u32);
  CHECK_BITS_EQUAL(91,head.unnamed_24_31,175);
  // UINT32 triggertime NOENCODE
  // {
    //  0_31: trigger_time;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 trigger_time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 trigger_time : 32; // 0..31
#endif
    };
    uint32  u32;
  } triggertime;
  READ_FROM_BUFFER_FULL(96,uint32 ,triggertime,triggertime.u32);
  // UINT32 time NOENCODE
  // {
    //  0_31: time;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } time;
  READ_FROM_BUFFER_FULL(100,uint32 ,time,time.u32);
  // list(0<=i<((data_size.size - 16) >> 3))

  for (uint32 i = 0; i < (uint32) (((data_size.size - 16) >> 3)); ++i)
  {
    // UINT32 time NOENCODE
    // {
      //  0_10: time;
      // 11_14: unused1;
      //    15: sign;
      // 16_19: unused2;
      // 20_23: multi_hit;
      // 24_27: n_hit;
      // 28_31: channel_id;
      // ENCODE(t[channel_id],(value=((time | (sign << 11)) & 0xfff)));
      // ENCODE(n_hit[channel_id],(value=n_hit));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time : 11; // 0..10
        uint32 unused1 : 4; // 11..14
        uint32 sign : 1; // 15
        uint32 unused2 : 4; // 16..19
        uint32 multi_hit : 4; // 20..23
        uint32 n_hit : 4; // 24..27
        uint32 channel_id : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel_id : 4; // 28..31
        uint32 n_hit : 4; // 24..27
        uint32 multi_hit : 4; // 20..23
        uint32 unused2 : 4; // 16..19
        uint32 sign : 1; // 15
        uint32 unused1 : 4; // 11..14
        uint32 time : 11; // 0..10
#endif
      };
      uint32  u32;
    } time;
    READ_FROM_BUFFER_FULL(114,uint32 ,time,time.u32);
    {
      typedef __typeof__(*(&(t))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = t.insert_index(112,time.channel_id);
      __item.value = ((time.time | (time.sign << 11)) & 0xfff);
    }
    {
      typedef __typeof__(*(&(n_hit))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = n_hit.insert_index(113,time.channel_id);
      __item.value = time.n_hit;
    }
    // UINT32 energy NOENCODE
    // {
      //  0_21: energy;
      //    22: unused1;
      //    23: sign;
      // 24_27: unused2;
      // 28_31: channel_id;
      // ENCODE(e[channel_id],(value=(energy | (sign << 23))));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 energy : 22; // 0..21
        uint32 unused1 : 1; // 22
        uint32 sign : 1; // 23
        uint32 unused2 : 4; // 24..27
        uint32 channel_id : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 channel_id : 4; // 28..31
        uint32 unused2 : 4; // 24..27
        uint32 sign : 1; // 23
        uint32 unused1 : 1; // 22
        uint32 energy : 22; // 0..21
#endif
      };
      uint32  u32;
    } energy;
    READ_FROM_BUFFER_FULL(123,uint32 ,energy,energy.u32);
    {
      typedef __typeof__(*(&(e))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = e.insert_index(122,energy.channel_id);
      __item.value = (energy.energy | (energy.sign << 23));
    }
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 191;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unused : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 unused : 24; // 0..23
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(129,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(128,trailer.unnamed_24_31,191);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_NOTRACE::__unpack,uint32 sfp,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_NOTRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_NOTRACE(sfp,card)
template<typename __data_src_t>
bool FEBEX_NOTRACE::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA8 n_hit[16]);
  // MEMBER(DATA12 t[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 e[16] ZERO_SUPPRESS_MULTI(32));
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  READ_FROM_BUFFER_FULL(83,uint32 ,indicator,indicator.u32);
  MATCH_BITS_EQUAL(78,indicator.unnamed_0_7,52);
  MATCH_BITS_EQUAL(80,indicator.sfp,sfp);
  MATCH_BITS_EQUAL(81,indicator.card,card);
  MATCH_BITS_EQUAL(82,indicator.unnamed_24_31,255);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FEBEX_NOTRACE::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_NOTRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_NOTRACE(sfp,card)
template<typename __data_dest_t>
void PACKER_FEBEX_NOTRACE::__packer(__data_dest_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA8 n_hit[16]);
  // MEMBER(DATA12 t[16] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA32 e[16] ZERO_SUPPRESS_MULTI(32));
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 255;
  // }
  // UINT32 data_size NOENCODE
  // {
    //  0_31: size;
  // }
  // UINT32 head NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 175;
  // }
  // UINT32 triggertime NOENCODE
  // {
    //  0_31: trigger_time;
  // }
  // UINT32 time NOENCODE
  // {
    //  0_31: time;
  // }
  // list(0<=i<((data_size.size - 16) >> 3))

  {
    // UINT32 time NOENCODE
    // {
      //  0_10: time;
      // 11_14: unused1;
      //    15: sign;
      // 16_19: unused2;
      // 20_23: multi_hit;
      // 24_27: n_hit;
      // 28_31: channel_id;
      // ENCODE(t[channel_id],(value=((time | (sign << 11)) & 0xfff)));
      // ENCODE(n_hit[channel_id],(value=n_hit));
    // }
    // UINT32 energy NOENCODE
    // {
      //  0_21: energy;
      //    22: unused1;
      //    23: sign;
      // 24_27: unused2;
      // 28_31: channel_id;
      // ENCODE(e[channel_id],(value=(energy | (sign << 23))));
    // }
  }
  // UINT32 trailer NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 191;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_NOTRACE::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_PADDING
class FEBEX_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_PADDING
class PACKER_FEBEX_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
void FEBEX_PADDING::__unpack(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  READ_FROM_BUFFER_FULL(139,uint32 ,pads_data,pads_data.u32);
  CHECK_BITS_EQUAL(138,pads_data.unnamed_20_31,0xadd);
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_src_t>
bool FEBEX_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } pads_data;
  READ_FROM_BUFFER_FULL(139,uint32 ,pads_data,pads_data.u32);
  MATCH_BITS_EQUAL(138,pads_data.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,FEBEX_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_PADDING.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_PADDING()
template<typename __data_dest_t>
void PACKER_FEBEX_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 pads_data NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,FEBEX_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: FEBEX_TRACE
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for FEBEX_TRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACE(sfp,card)
#if !PACKER_CODE
# define DECLARED_UNPACK_FEBEX_TRACE
class FEBEX_TRACE
#else//PACKER_CODE
# define DECLARED_PACKER_FEBEX_TRACE
class PACKER_FEBEX_TRACE
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 trace_length[16] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,16> trace_length;
  // MEMBER(DATA16 trace[16][1000] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA16,DATA16,1000> trace[16];
  // MEMBER(DATA32 filter[16][1000] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,1000> filter[16];
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: channel_id = RANGE(0,254);
  // }
  // UINT32 trace_size NOENCODE
  // {
    //  0_31: size;
    // ENCODE(trace_length[header.channel_id],(value=((size / 2) - 4)));
  // }
  // UINT32 trace_header NOENCODE
  // {
    //  0_17: notused1;
    //    18: filter_mode;
    //    19: filter_onoff;
    // 20_22: notused2;
    //    23: adc_type;
    // 24_31: 170;
  // }
  // if((trace_header.filter_onoff == 0))

  // else

    // list(0<=i<((trace_size.size / 4) - 2))

      // UINT32 channel_trace NOENCODE
      // {
        //  0_13: data1;
        // 14_15: nik_knows;
        // 16_29: data2;
        // 30_31: nik_knows2;
        // ENCODE(trace[header.channel_id][((2 * i) + 0)],(value=data1));
        // ENCODE(trace[header.channel_id][((2 * i) + 1)],(value=data2));
      // }
    // list(0<=i<((trace_size.size / 8) - 1))

      // UINT32 channel_trace NOENCODE
      // {
        //  0_13: data1;
        // 14_31: nik_knows;
        // ENCODE(trace[header.channel_id][i],(value=data1));
      // }
      // UINT32 channel_filter NOENCODE
      // {
        //  0_22: data1;
        //    23: sign;
        // 24_31: nik_knows2;
        // ENCODE(filter[header.channel_id][i],(value=(data1 * (1 - (2 * sign)))));
      // }
  // UINT32 trace_trailer NOENCODE
  // {
    //  0_23: notused;
    // 24_31: 187;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(FEBEX_TRACE);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for FEBEX_TRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACE(sfp,card)
template<typename __data_src_t>
void FEBEX_TRACE::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA32 trace_length[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 trace[16][1000] ZERO_SUPPRESS);
  // MEMBER(DATA32 filter[16][1000] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: channel_id = RANGE(0,254);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 channel_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 channel_id : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(154,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(149,header.unnamed_0_7,52);
  CHECK_BITS_EQUAL(151,header.sfp,sfp);
  CHECK_BITS_EQUAL(152,header.card,card);
  CHECK_BITS_RANGE_MAX(153,header.channel_id,254);
  // UINT32 trace_size NOENCODE
  // {
    //  0_31: size;
    // ENCODE(trace_length[header.channel_id],(value=((size / 2) - 4)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 size : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 size : 32; // 0..31
#endif
    };
    uint32  u32;
  } trace_size;
  READ_FROM_BUFFER_FULL(159,uint32 ,trace_size,trace_size.u32);
  {
    typedef __typeof__(*(&(trace_length))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = trace_length.insert_index(158,header.channel_id);
    __item.value = ((trace_size.size / 2) - 4);
  }
  // UINT32 trace_header NOENCODE
  // {
    //  0_17: notused1;
    //    18: filter_mode;
    //    19: filter_onoff;
    // 20_22: notused2;
    //    23: adc_type;
    // 24_31: 170;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 notused1 : 18; // 0..17
      uint32 filter_mode : 1; // 18
      uint32 filter_onoff : 1; // 19
      uint32 notused2 : 3; // 20..22
      uint32 adc_type : 1; // 23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 adc_type : 1; // 23
      uint32 notused2 : 3; // 20..22
      uint32 filter_onoff : 1; // 19
      uint32 filter_mode : 1; // 18
      uint32 notused1 : 18; // 0..17
#endif
    };
    uint32  u32;
  } trace_header;
  READ_FROM_BUFFER_FULL(168,uint32 ,trace_header,trace_header.u32);
  CHECK_BITS_EQUAL(167,trace_header.unnamed_24_31,170);
  // if((trace_header.filter_onoff == 0))

  // else

  if ((trace_header.filter_onoff == 0))
  {
    // list(0<=i<((trace_size.size / 4) - 2))

    for (uint32 i = 0; i < (uint32) (((trace_size.size / 4) - 2)); ++i)
    {
      // UINT32 channel_trace NOENCODE
      // {
        //  0_13: data1;
        // 14_15: nik_knows;
        // 16_29: data2;
        // 30_31: nik_knows2;
        // ENCODE(trace[header.channel_id][((2 * i) + 0)],(value=data1));
        // ENCODE(trace[header.channel_id][((2 * i) + 1)],(value=data2));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 data1 : 14; // 0..13
          uint32 nik_knows : 2; // 14..15
          uint32 data2 : 14; // 16..29
          uint32 nik_knows2 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 nik_knows2 : 2; // 30..31
          uint32 data2 : 14; // 16..29
          uint32 nik_knows : 2; // 14..15
          uint32 data1 : 14; // 0..13
#endif
        };
        uint32  u32;
      } channel_trace;
      READ_FROM_BUFFER_FULL(181,uint32 ,channel_trace,channel_trace.u32);
      {
        typedef __typeof__(*(&(trace[header.channel_id]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = trace[header.channel_id].insert_index(179,((2 * i) + 0));
        __item.value = channel_trace.data1;
      }
      {
        typedef __typeof__(*(&(trace[header.channel_id]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = trace[header.channel_id].insert_index(180,((2 * i) + 1));
        __item.value = channel_trace.data2;
      }
    }
  }

  else
  {
    // list(0<=i<((trace_size.size / 8) - 1))

    for (uint32 i = 0; i < (uint32) (((trace_size.size / 8) - 1)); ++i)
    {
      // UINT32 channel_trace NOENCODE
      // {
        //  0_13: data1;
        // 14_31: nik_knows;
        // ENCODE(trace[header.channel_id][i],(value=data1));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 data1 : 14; // 0..13
          uint32 nik_knows : 18; // 14..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 nik_knows : 18; // 14..31
          uint32 data1 : 14; // 0..13
#endif
        };
        uint32  u32;
      } channel_trace;
      READ_FROM_BUFFER_FULL(193,uint32 ,channel_trace,channel_trace.u32);
      {
        typedef __typeof__(*(&(trace[header.channel_id]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = trace[header.channel_id].insert_index(192,i);
        __item.value = channel_trace.data1;
      }
      // UINT32 channel_filter NOENCODE
      // {
        //  0_22: data1;
        //    23: sign;
        // 24_31: nik_knows2;
        // ENCODE(filter[header.channel_id][i],(value=(data1 * (1 - (2 * sign)))));
      // }
      union
      {
        struct
        {
#if __BYTE_ORDER == __LITTLE_ENDIAN
          uint32 data1 : 23; // 0..22
          uint32 sign : 1; // 23
          uint32 nik_knows2 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
          uint32 nik_knows2 : 8; // 24..31
          uint32 sign : 1; // 23
          uint32 data1 : 23; // 0..22
#endif
        };
        uint32  u32;
      } channel_filter;
      READ_FROM_BUFFER_FULL(200,uint32 ,channel_filter,channel_filter.u32);
      {
        typedef __typeof__(*(&(filter[header.channel_id]))) __array_t;
        typedef typename __array_t::item_t __item_t;
        __item_t &__item = filter[header.channel_id].insert_index(199,i);
        __item.value = (channel_filter.data1 * (1 - (2 * channel_filter.sign)));
      }
    }
  }
  // UINT32 trace_trailer NOENCODE
  // {
    //  0_23: notused;
    // 24_31: 187;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 notused : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 notused : 24; // 0..23
#endif
    };
    uint32  u32;
  } trace_trailer;
  READ_FROM_BUFFER_FULL(207,uint32 ,trace_trailer,trace_trailer.u32);
  CHECK_BITS_EQUAL(206,trace_trailer.unnamed_24_31,187);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_TRACE::__unpack,uint32 sfp,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for FEBEX_TRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACE(sfp,card)
template<typename __data_src_t>
bool FEBEX_TRACE::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA32 trace_length[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 trace[16][1000] ZERO_SUPPRESS);
  // MEMBER(DATA32 filter[16][1000] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: channel_id = RANGE(0,254);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 channel_id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 channel_id : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(154,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(149,header.unnamed_0_7,52);
  MATCH_BITS_EQUAL(151,header.sfp,sfp);
  MATCH_BITS_EQUAL(152,header.card,card);
  MATCH_BITS_RANGE_MAX(153,header.channel_id,254);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,FEBEX_TRACE::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for FEBEX_TRACE.
 *
 * Do not edit - automatically generated.
 */

// FEBEX_TRACE(sfp,card)
template<typename __data_dest_t>
void PACKER_FEBEX_TRACE::__packer(__data_dest_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA32 trace_length[16] ZERO_SUPPRESS);
  // MEMBER(DATA16 trace[16][1000] ZERO_SUPPRESS);
  // MEMBER(DATA32 filter[16][1000] ZERO_SUPPRESS);
  // UINT32 header NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: channel_id = RANGE(0,254);
  // }
  // UINT32 trace_size NOENCODE
  // {
    //  0_31: size;
    // ENCODE(trace_length[header.channel_id],(value=((size / 2) - 4)));
  // }
  // UINT32 trace_header NOENCODE
  // {
    //  0_17: notused1;
    //    18: filter_mode;
    //    19: filter_onoff;
    // 20_22: notused2;
    //    23: adc_type;
    // 24_31: 170;
  // }
  // if((trace_header.filter_onoff == 0))

  // else

  if ((trace_header.filter_onoff == 0))
  {
    // list(0<=i<((trace_size.size / 4) - 2))

    {
      // UINT32 channel_trace NOENCODE
      // {
        //  0_13: data1;
        // 14_15: nik_knows;
        // 16_29: data2;
        // 30_31: nik_knows2;
        // ENCODE(trace[header.channel_id][((2 * i) + 0)],(value=data1));
        // ENCODE(trace[header.channel_id][((2 * i) + 1)],(value=data2));
      // }
    }
  }

  else
  {
    // list(0<=i<((trace_size.size / 8) - 1))

    {
      // UINT32 channel_trace NOENCODE
      // {
        //  0_13: data1;
        // 14_31: nik_knows;
        // ENCODE(trace[header.channel_id][i],(value=data1));
      // }
      // UINT32 channel_filter NOENCODE
      // {
        //  0_22: data1;
        //    23: sign;
        // 24_31: nik_knows2;
        // ENCODE(filter[header.channel_id][i],(value=(data1 * (1 - (2 * sign)))));
      // }
    }
  }
  // UINT32 trace_trailer NOENCODE
  // {
    //  0_23: notused;
    // 24_31: 187;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,FEBEX_TRACE::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: LAND_STD_VME
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
#if !PACKER_CODE
# define DECLARED_UNPACK_LAND_STD_VME
class LAND_STD_VME
#else//PACKER_CODE
# define DECLARED_PACKER_LAND_STD_VME
class PACKER_LAND_STD_VME
#endif//PACKER_CODE

{
public:
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 fail_general : 1; // 0
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 dummy_8_21 : 14;
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_event : 1; // 30
      uint32 has_time_stamp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 has_time_stamp : 1; // 31
      uint32 has_multi_event : 1; // 30
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_no_zero_suppression : 1; // 27
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 dummy_8_21 : 14;
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_general : 1; // 0
#endif
    };
    uint32  u32;
  } failure;
  // if(failure.has_continous_event_counter)

    // UINT32 continous_event_counter;
    uint32  continous_event_counter;
  // if(failure.has_time_stamp)

    // UINT32 time_stamp;
    uint32  time_stamp;
  // if(failure.has_clock_counter_stamp)

    // UINT32 clock_counter_stamp;
    uint32  clock_counter_stamp;
  // if(failure.has_update_qdc_iped_value)

    // UINT32 iped;
    uint32  iped;
  // if(failure.has_multi_event)

    // UINT32 multi_events;
    uint32  multi_events;
  // if(failure.has_multi_trlo_ii_counter0)

    // UINT32 multi_trlo_ii_counter0;
    uint32  multi_trlo_ii_counter0;
  // if(failure.has_multi_scaler_counter0)

    // UINT32 multi_scaler_counter0;
    uint32  multi_scaler_counter0;
  // if(failure.has_multi_adctdc_counter0)

    // UINT32 multi_adctdc_counter0;
    uint32  multi_adctdc_counter0;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(LAND_STD_VME);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_src_t>
void LAND_STD_VME::__unpack(__data_src_t &__buffer)
{
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  READ_FROM_BUFFER_FULL(232,uint32 ,failure,failure.u32);
  CHECK_UNNAMED_BITS_ZERO(232,failure.u32,0x003fff00);
  // if(failure.has_continous_event_counter)

  if (failure.has_continous_event_counter)
  {
    // UINT32 continous_event_counter;
    READ_FROM_BUFFER(235,uint32 ,continous_event_counter);
  }
  // if(failure.has_time_stamp)

  if (failure.has_time_stamp)
  {
    // UINT32 time_stamp;
    READ_FROM_BUFFER(239,uint32 ,time_stamp);
  }
  // if(failure.has_clock_counter_stamp)

  if (failure.has_clock_counter_stamp)
  {
    // UINT32 clock_counter_stamp;
    READ_FROM_BUFFER(243,uint32 ,clock_counter_stamp);
  }
  // if(failure.has_update_qdc_iped_value)

  if (failure.has_update_qdc_iped_value)
  {
    // UINT32 iped;
    READ_FROM_BUFFER(247,uint32 ,iped);
  }
  // if(failure.has_multi_event)

  if (failure.has_multi_event)
  {
    // UINT32 multi_events;
    READ_FROM_BUFFER(251,uint32 ,multi_events);
  }
  // if(failure.has_multi_trlo_ii_counter0)

  if (failure.has_multi_trlo_ii_counter0)
  {
    // UINT32 multi_trlo_ii_counter0;
    READ_FROM_BUFFER(255,uint32 ,multi_trlo_ii_counter0);
  }
  // if(failure.has_multi_scaler_counter0)

  if (failure.has_multi_scaler_counter0)
  {
    // UINT32 multi_scaler_counter0;
    READ_FROM_BUFFER(259,uint32 ,multi_scaler_counter0);
  }
  // if(failure.has_multi_adctdc_counter0)

  if (failure.has_multi_adctdc_counter0)
  {
    // UINT32 multi_adctdc_counter0;
    READ_FROM_BUFFER(263,uint32 ,multi_adctdc_counter0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_STD_VME::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_src_t>
bool LAND_STD_VME::__match(__data_src_t &__buffer)
{
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 fail_general : 1; // 0
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 dummy_8_21 : 14;
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_no_zero_suppression : 1; // 27
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_event : 1; // 30
      uint32 has_time_stamp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 has_time_stamp : 1; // 31
      uint32 has_multi_event : 1; // 30
      uint32 has_multi_scaler_counter0 : 1; // 29
      uint32 has_multi_adctdc_counter0 : 1; // 28
      uint32 has_no_zero_suppression : 1; // 27
      uint32 spurious_start_before_tcal : 1; // 26
      uint32 has_update_qdc_iped_value : 1; // 25
      uint32 has_continous_event_counter : 1; // 24
      uint32 has_clock_counter_stamp : 1; // 23
      uint32 has_multi_trlo_ii_counter0 : 1; // 22
      uint32 dummy_8_21 : 14;
      uint32 fail_firmware_mismatch : 1; // 7
      uint32 fail_unexpected_trigger : 1; // 6
      uint32 fail_readout_error_driver : 1; // 5
      uint32 fail_event_counter_mismatch : 1; // 4
      uint32 fail_data_too_much : 1; // 3
      uint32 fail_data_missing : 1; // 2
      uint32 fail_data_corrupt : 1; // 1
      uint32 fail_general : 1; // 0
#endif
    };
    uint32  u32;
  } __failure;
  READ_FROM_BUFFER_FULL(232,uint32 ,failure,__failure.u32);
  MATCH_UNNAMED_BITS_ZERO(232,__failure.u32,0x003fff00);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,LAND_STD_VME::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for LAND_STD_VME.
 *
 * Do not edit - automatically generated.
 */

// LAND_STD_VME()
template<typename __data_dest_t>
void PACKER_LAND_STD_VME::__packer(__data_dest_t &__buffer)
{
  // UINT32 failure
  // {
    //     0: fail_general;
    //     1: fail_data_corrupt;
    //     2: fail_data_missing;
    //     3: fail_data_too_much;
    //     4: fail_event_counter_mismatch;
    //     5: fail_readout_error_driver;
    //     6: fail_unexpected_trigger;
    //     7: fail_firmware_mismatch;
    //    22: has_multi_trlo_ii_counter0;
    //    23: has_clock_counter_stamp;
    //    24: has_continous_event_counter;
    //    25: has_update_qdc_iped_value;
    //    26: spurious_start_before_tcal;
    //    27: has_no_zero_suppression;
    //    28: has_multi_adctdc_counter0;
    //    29: has_multi_scaler_counter0;
    //    30: has_multi_event;
    //    31: has_time_stamp;
  // }
  // if(failure.has_continous_event_counter)

  if (failure.has_continous_event_counter)
  {
    // UINT32 continous_event_counter;
  }
  // if(failure.has_time_stamp)

  if (failure.has_time_stamp)
  {
    // UINT32 time_stamp;
  }
  // if(failure.has_clock_counter_stamp)

  if (failure.has_clock_counter_stamp)
  {
    // UINT32 clock_counter_stamp;
  }
  // if(failure.has_update_qdc_iped_value)

  if (failure.has_update_qdc_iped_value)
  {
    // UINT32 iped;
  }
  // if(failure.has_multi_event)

  if (failure.has_multi_event)
  {
    // UINT32 multi_events;
  }
  // if(failure.has_multi_trlo_ii_counter0)

  if (failure.has_multi_trlo_ii_counter0)
  {
    // UINT32 multi_trlo_ii_counter0;
  }
  // if(failure.has_multi_scaler_counter0)

  if (failure.has_multi_scaler_counter0)
  {
    // UINT32 multi_scaler_counter0;
  }
  // if(failure.has_multi_adctdc_counter0)

  if (failure.has_multi_adctdc_counter0)
  {
    // UINT32 multi_adctdc_counter0;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,LAND_STD_VME::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: SCALER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for SCALER.
 *
 * Do not edit - automatically generated.
 */

// SCALER()
#if !PACKER_CODE
# define DECLARED_UNPACK_SCALER
class SCALER
#else//PACKER_CODE
# define DECLARED_PACKER_SCALER
class PACKER_SCALER
#endif//PACKER_CODE

{
public:
  // UINT32 scaler;
  uint32  scaler;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(SCALER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for SCALER.
 *
 * Do not edit - automatically generated.
 */

// SCALER()
template<typename __data_src_t>
void SCALER::__unpack(__data_src_t &__buffer)
{
  // UINT32 scaler;
  READ_FROM_BUFFER(269,uint32 ,scaler);
}
FORCE_IMPL_DATA_SRC_FCN(void,SCALER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for SCALER.
 *
 * Do not edit - automatically generated.
 */

// SCALER()
template<typename __data_src_t>
bool SCALER::__match(__data_src_t &__buffer)
{
  // UINT32 scaler;
  uint32  __scaler;
  READ_FROM_BUFFER(269,uint32 ,__scaler);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,SCALER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for SCALER.
 *
 * Do not edit - automatically generated.
 */

// SCALER()
template<typename __data_dest_t>
void PACKER_SCALER::__packer(__data_dest_t &__buffer)
{
  // UINT32 scaler;
}
FORCE_IMPL_DATA_SRC_FCN(void,SCALER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX3_HEADER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX3_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_HEADER()
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX3_HEADER
class TAMEX3_HEADER
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX3_HEADER
class PACKER_TAMEX3_HEADER
#endif//PACKER_CODE

{
public:
  // UINT32 trigger_window
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 post_trig_ns : 16; // 0..15
      uint32 pre_trig_ns : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pre_trig_ns : 16; // 16..31
      uint32 post_trig_ns : 16; // 0..15
#endif
    };
    uint32  u32;
  } trigger_window;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX3_HEADER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX3_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_HEADER()
template<typename __data_src_t>
void TAMEX3_HEADER::__unpack(__data_src_t &__buffer)
{
  // UINT32 trigger_window
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
  // }
  READ_FROM_BUFFER_FULL(278,uint32 ,trigger_window,trigger_window.u32);
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX3_HEADER::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX3_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_HEADER()
template<typename __data_src_t>
bool TAMEX3_HEADER::__match(__data_src_t &__buffer)
{
  // UINT32 trigger_window
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 post_trig_ns : 16; // 0..15
      uint32 pre_trig_ns : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 pre_trig_ns : 16; // 16..31
      uint32 post_trig_ns : 16; // 0..15
#endif
    };
    uint32  u32;
  } __trigger_window;
  READ_FROM_BUFFER_FULL(278,uint32 ,trigger_window,__trigger_window.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TAMEX3_HEADER::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX3_HEADER.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_HEADER()
template<typename __data_dest_t>
void PACKER_TAMEX3_HEADER::__packer(__data_dest_t &__buffer)
{
  // UINT32 trigger_window
  // {
    //  0_15: post_trig_ns;
    // 16_31: pre_trig_ns;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX3_HEADER::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX3_PADDING
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX3_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_PADDING()
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX3_PADDING
class TAMEX3_PADDING
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX3_PADDING
class PACKER_TAMEX3_PADDING
#endif//PACKER_CODE

{
public:
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX3_PADDING);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX3_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_PADDING()
template<typename __data_src_t>
void TAMEX3_PADDING::__unpack(__data_src_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } padding;
  READ_FROM_BUFFER_FULL(288,uint32 ,padding,padding.u32);
  CHECK_BITS_EQUAL(287,padding.unnamed_20_31,0xadd);
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX3_PADDING::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX3_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_PADDING()
template<typename __data_src_t>
bool TAMEX3_PADDING::__match(__data_src_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 12; // 0..11
      uint32 index : 8; // 12..19
      uint32 unnamed_20_31 : 12; // 20..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_20_31 : 12; // 20..31
      uint32 index : 8; // 12..19
      uint32 counter : 12; // 0..11
#endif
    };
    uint32  u32;
  } padding;
  READ_FROM_BUFFER_FULL(288,uint32 ,padding,padding.u32);
  MATCH_BITS_EQUAL(287,padding.unnamed_20_31,0xadd);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,TAMEX3_PADDING::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX3_PADDING.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_PADDING()
template<typename __data_dest_t>
void PACKER_TAMEX3_PADDING::__packer(__data_dest_t &__buffer)
{
  // UINT32 padding NOENCODE
  // {
    //  0_11: counter;
    // 12_19: index;
    // 20_31: 0xadd;
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,TAMEX3_PADDING::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: TAMEX3_SFP
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TAMEX3_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_SFP(sfp,card)
#if !PACKER_CODE
# define DECLARED_UNPACK_TAMEX3_SFP
class TAMEX3_SFP
#else//PACKER_CODE
# define DECLARED_PACKER_TAMEX3_SFP
class PACKER_TAMEX3_SFP
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA16 time_coarse[34] ZERO_SUPPRESS_MULTI(200));
  raw_array_multi_zero_suppress<DATA16,DATA16,34,200> time_coarse;
  // MEMBER(DATA12 time_fine[34] ZERO_SUPPRESS_MULTI(200));
  raw_array_multi_zero_suppress<DATA12,DATA12,34,200> time_fine;
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
  // }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
  // }
  // list(0<=i<((data_size.bytes / 4) - 3))

    // UINT32 data NOENCODE
    // {
      //  0_10: coarse;
      //    11: is_leading;
      // 12_21: fine;
      // 22_28: channel_index;
      // 29_31: type;
      // ENCODE(time_coarse[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=coarse));
      // ENCODE(time_fine[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=fine));
    // }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 187;
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 sfp,uint32 card);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 sfp,uint32 card);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 sfp,uint32 card);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TAMEX3_SFP);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TAMEX3_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_SFP(sfp,card)
template<typename __data_src_t>
void TAMEX3_SFP::__unpack(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA16 time_coarse[34] ZERO_SUPPRESS_MULTI(200));
  // MEMBER(DATA12 time_fine[34] ZERO_SUPPRESS_MULTI(200));
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  READ_FROM_BUFFER_FULL(302,uint32 ,indicator,indicator.u32);
  CHECK_BITS_EQUAL(297,indicator.unnamed_0_7,52);
  CHECK_BITS_EQUAL(299,indicator.sfp,sfp);
  CHECK_BITS_EQUAL(300,indicator.card,card);
  CHECK_BITS_EQUAL(301,indicator.unnamed_24_31,0);
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bytes : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 bytes : 32; // 0..31
#endif
    };
    uint32  u32;
  } data_size;
  READ_FROM_BUFFER_FULL(307,uint32 ,data_size,data_size.u32);
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 lec : 16; // 0..15
      uint32 buf_no : 1; // 16
      uint32 reserved : 3; // 17..19
      uint32 trigger_type : 4; // 20..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 trigger_type : 4; // 20..23
      uint32 reserved : 3; // 17..19
      uint32 buf_no : 1; // 16
      uint32 lec : 16; // 0..15
#endif
    };
    uint32  u32;
  } tdc_header;
  READ_FROM_BUFFER_FULL(315,uint32 ,tdc_header,tdc_header.u32);
  CHECK_BITS_EQUAL(314,tdc_header.unnamed_24_31,170);
  // list(0<=i<((data_size.bytes / 4) - 3))

  for (uint32 i = 0; i < (uint32) (((data_size.bytes / 4) - 3)); ++i)
  {
    // UINT32 data NOENCODE
    // {
      //  0_10: coarse;
      //    11: is_leading;
      // 12_21: fine;
      // 22_28: channel_index;
      // 29_31: type;
      // ENCODE(time_coarse[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=coarse));
      // ENCODE(time_fine[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=fine));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 coarse : 11; // 0..10
        uint32 is_leading : 1; // 11
        uint32 fine : 10; // 12..21
        uint32 channel_index : 7; // 22..28
        uint32 type : 3; // 29..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 type : 3; // 29..31
        uint32 channel_index : 7; // 22..28
        uint32 fine : 10; // 12..21
        uint32 is_leading : 1; // 11
        uint32 coarse : 11; // 0..10
#endif
      };
      uint32  u32;
    } data;
    READ_FROM_BUFFER_FULL(327,uint32 ,data,data.u32);
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.insert_index(325,(((4 <= data.type) * data.channel_index) + ((4 > data.type) * 33)));
      __item.value = data.coarse;
    }
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.insert_index(326,(((4 <= data.type) * data.channel_index) + ((4 > data.type) * 33)));
      __item.value = data.fine;
    }
  }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 bits : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 bits : 24; // 0..23
#endif
    };
    uint32  u32;
  } error_bits;
  READ_FROM_BUFFER_FULL(333,uint32 ,error_bits,error_bits.u32);
  CHECK_BITS_EQUAL(332,error_bits.unnamed_24_31,238);
  // UINT32 trailer NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 187;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unused : 24; // 0..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 unused : 24; // 0..23
#endif
    };
    uint32  u32;
  } trailer;
  READ_FROM_BUFFER_FULL(338,uint32 ,trailer,trailer.u32);
  CHECK_BITS_EQUAL(337,trailer.unnamed_24_31,187);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX3_SFP::__unpack,uint32 sfp,uint32 card);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TAMEX3_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_SFP(sfp,card)
template<typename __data_src_t>
bool TAMEX3_SFP::__match(__data_src_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA16 time_coarse[34] ZERO_SUPPRESS_MULTI(200));
  // MEMBER(DATA12 time_fine[34] ZERO_SUPPRESS_MULTI(200));
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 trigger_type : 4; // 8..11
      uint32 sfp : 4; // 12..15
      uint32 card : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 card : 8; // 16..23
      uint32 sfp : 4; // 12..15
      uint32 trigger_type : 4; // 8..11
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } indicator;
  READ_FROM_BUFFER_FULL(302,uint32 ,indicator,indicator.u32);
  MATCH_BITS_EQUAL(297,indicator.unnamed_0_7,52);
  MATCH_BITS_EQUAL(299,indicator.sfp,sfp);
  MATCH_BITS_EQUAL(300,indicator.card,card);
  MATCH_BITS_EQUAL(301,indicator.unnamed_24_31,0);
  // MATCH_END;
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TAMEX3_SFP::__match,uint32 sfp,uint32 card);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TAMEX3_SFP.
 *
 * Do not edit - automatically generated.
 */

// TAMEX3_SFP(sfp,card)
template<typename __data_dest_t>
void PACKER_TAMEX3_SFP::__packer(__data_dest_t &__buffer,uint32 sfp,uint32 card)
{
  // MEMBER(DATA16 time_coarse[34] ZERO_SUPPRESS_MULTI(200));
  // MEMBER(DATA12 time_fine[34] ZERO_SUPPRESS_MULTI(200));
  // UINT32 indicator NOENCODE
  // {
    //  0_07: 52;
    //  8_11: trigger_type;
    // 12_15: sfp = MATCH(sfp);
    // 16_23: card = MATCH(card);
    // 24_31: 0;
  // }
  // MATCH_END;
  // UINT32 data_size NOENCODE
  // {
    //  0_31: bytes;
  // }
  // UINT32 tdc_header NOENCODE
  // {
    //  0_15: lec;
    //    16: buf_no;
    // 17_19: reserved;
    // 20_23: trigger_type;
    // 24_31: 170;
  // }
  // list(0<=i<((data_size.bytes / 4) - 3))

  {
    // UINT32 data NOENCODE
    // {
      //  0_10: coarse;
      //    11: is_leading;
      // 12_21: fine;
      // 22_28: channel_index;
      // 29_31: type;
      // ENCODE(time_coarse[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=coarse));
      // ENCODE(time_fine[(((4 <= type) * channel_index) + ((4 > type) * 33))],(value=fine));
    // }
  }
  // UINT32 error_bits NOENCODE
  // {
    //  0_23: bits;
    // 24_31: 238;
  // }
  // UINT32 trailer NOENCODE
  // {
    //  0_23: unused;
    // 24_31: 187;
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TAMEX3_SFP::__packer,uint32 sfp,uint32 card);

/** END_PACKER ********************************************************/

//
// Generating code for: TIMESTAMP_WHITERABBIT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TIMESTAMP_WHITERABBIT
class TIMESTAMP_WHITERABBIT
#else//PACKER_CODE
# define DECLARED_PACKER_TIMESTAMP_WHITERABBIT
class PACKER_TIMESTAMP_WHITERABBIT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 subsystem_id);
  DATA12 subsystem_id;
  // MEMBER(DATA16 t1);
  DATA16 t1;
  // MEMBER(DATA16 t2);
  DATA16 t2;
  // MEMBER(DATA16 t3);
  DATA16 t3;
  // MEMBER(DATA16 t4);
  DATA16 t4;
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TIMESTAMP_WHITERABBIT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
void TIMESTAMP_WHITERABBIT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(355,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(350,header.id,id);
  CHECK_BITS_EQUAL(351,header.unnamed_12_15,0);
  CHECK_BITS_EQUAL(353,header.unnamed_17_31,0);
  {
    subsystem_id.value = header.id;
  }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t1 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t1 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d1;
  READ_FROM_BUFFER_FULL(361,uint32 ,d1,d1.u32);
  CHECK_BITS_EQUAL(359,d1.unnamed_16_31,0x3e1);
  {
    t1.value = d1.t1;
  }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t2 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t2 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d2;
  READ_FROM_BUFFER_FULL(367,uint32 ,d2,d2.u32);
  CHECK_BITS_EQUAL(365,d2.unnamed_16_31,0x4e1);
  {
    t2.value = d2.t2;
  }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t3 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t3 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d3;
  READ_FROM_BUFFER_FULL(373,uint32 ,d3,d3.u32);
  CHECK_BITS_EQUAL(371,d3.unnamed_16_31,0x5e1);
  {
    t3.value = d3.t3;
  }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 t4 : 16; // 0..15
      uint32 unnamed_16_31 : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_16_31 : 16; // 16..31
      uint32 t4 : 16; // 0..15
#endif
    };
    uint32  u32;
  } d4;
  READ_FROM_BUFFER_FULL(379,uint32 ,d4,d4.u32);
  CHECK_BITS_EQUAL(377,d4.unnamed_16_31,0x6e1);
  {
    t4.value = d4.t4;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_src_t>
bool TIMESTAMP_WHITERABBIT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 12; // 0..11
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 error_bit : 1; // 16
      uint32 unnamed_17_31 : 15; // 17..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_17_31 : 15; // 17..31
      uint32 error_bit : 1; // 16
      uint32 unnamed_12_15 : 4; // 12..15
      uint32 id : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(355,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(350,header.id,id);
  MATCH_BITS_EQUAL(351,header.unnamed_12_15,0);
  MATCH_BITS_EQUAL(353,header.unnamed_17_31,0);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TIMESTAMP_WHITERABBIT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TIMESTAMP_WHITERABBIT.
 *
 * Do not edit - automatically generated.
 */

// TIMESTAMP_WHITERABBIT(id)
template<typename __data_dest_t>
void PACKER_TIMESTAMP_WHITERABBIT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 subsystem_id);
  // MEMBER(DATA16 t1);
  // MEMBER(DATA16 t2);
  // MEMBER(DATA16 t3);
  // MEMBER(DATA16 t4);
  // UINT32 header NOENCODE
  // {
    //  0_11: id = MATCH(id);
    // 12_15: 0;
    //    16: error_bit;
    // 17_31: 0;
    // ENCODE(subsystem_id,(value=id));
  // }
  // UINT32 d1 NOENCODE
  // {
    //  0_15: t1;
    // 16_31: 0x3e1;
    // ENCODE(t1,(value=t1));
  // }
  // UINT32 d2 NOENCODE
  // {
    //  0_15: t2;
    // 16_31: 0x4e1;
    // ENCODE(t2,(value=t2));
  // }
  // UINT32 d3 NOENCODE
  // {
    //  0_15: t3;
    // 16_31: 0x5e1;
    // ENCODE(t3,(value=t3));
  // }
  // UINT32 d4 NOENCODE
  // {
    //  0_15: t4;
    // 16_31: 0x6e1;
    // ENCODE(t4,(value=t4));
  // }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TIMESTAMP_WHITERABBIT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLOII_LMU_SCALERS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLOII_LMU_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_LMU_SCALERS(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLOII_LMU_SCALERS
class TRLOII_LMU_SCALERS
#else//PACKER_CODE
# define DECLARED_PACKER_TRLOII_LMU_SCALERS
class PACKER_TRLOII_LMU_SCALERS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 before_lmu[63] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,63> before_lmu;
  // MEMBER(DATA32 before_lmu_mux[31] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,31> before_lmu_mux;
  // MEMBER(DATA32 before_lmu_aux[31] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,31> before_lmu_aux;
  // MEMBER(DATA32 before_dt[127] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,127> before_dt;
  // MEMBER(DATA32 after_dt[127] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,127> after_dt;
  // MEMBER(DATA32 after_reduction[127] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,127> after_reduction;
  // UINT32 header
  // {
    //  0_05: before_lmu;
    //  6_10: before_lmu_mux;
    // 11_15: before_lmu_aux;
    // 16_23: after_lmu;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 before_lmu : 6; // 0..5
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu_aux : 5; // 11..15
      uint32 after_lmu : 8; // 16..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 after_lmu : 8; // 16..23
      uint32 before_lmu_aux : 5; // 11..15
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu : 6; // 0..5
#endif
    };
    uint32  u32;
  } header;
  // list(0<=i<header.before_lmu)

    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu[i],(value=value));
    // }
  // list(0<=i<header.before_lmu_mux)

    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_mux[i],(value=value));
    // }
  // list(0<=i<header.before_lmu_aux)

    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_aux[i],(value=value));
    // }
  // list(0<=i<header.after_lmu)

    // UINT32 scaler_bdt NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_dt[i],(value=value));
    // }
    // UINT32 scaler_adt NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_dt[i],(value=value));
    // }
    // UINT32 scaler_ard NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_reduction[i],(value=value));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLOII_LMU_SCALERS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLOII_LMU_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_LMU_SCALERS(id)
template<typename __data_src_t>
void TRLOII_LMU_SCALERS::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 before_lmu[63] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_mux[31] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_aux[31] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_dt[127] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_dt[127] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_reduction[127] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_05: before_lmu;
    //  6_10: before_lmu_mux;
    // 11_15: before_lmu_aux;
    // 16_23: after_lmu;
    // 24_31: id = MATCH(id);
  // }
  READ_FROM_BUFFER_FULL(397,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(396,header.id,id);
  // list(0<=i<header.before_lmu)

  for (uint32 i = 0; i < (uint32) (header.before_lmu); ++i)
  {
    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } scaler;
    READ_FROM_BUFFER_FULL(404,uint32 ,scaler,scaler.u32);
    {
      typedef __typeof__(*(&(before_lmu))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_lmu.insert_index(403,i);
      __item.value = scaler.value;
    }
  }
  // list(0<=i<header.before_lmu_mux)

  for (uint32 i = 0; i < (uint32) (header.before_lmu_mux); ++i)
  {
    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_mux[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } scaler;
    READ_FROM_BUFFER_FULL(412,uint32 ,scaler,scaler.u32);
    {
      typedef __typeof__(*(&(before_lmu_mux))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_lmu_mux.insert_index(411,i);
      __item.value = scaler.value;
    }
  }
  // list(0<=i<header.before_lmu_aux)

  for (uint32 i = 0; i < (uint32) (header.before_lmu_aux); ++i)
  {
    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_aux[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } scaler;
    READ_FROM_BUFFER_FULL(420,uint32 ,scaler,scaler.u32);
    {
      typedef __typeof__(*(&(before_lmu_aux))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_lmu_aux.insert_index(419,i);
      __item.value = scaler.value;
    }
  }
  // list(0<=i<header.after_lmu)

  for (uint32 i = 0; i < (uint32) (header.after_lmu); ++i)
  {
    // UINT32 scaler_bdt NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_dt[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } scaler_bdt;
    READ_FROM_BUFFER_FULL(428,uint32 ,scaler_bdt,scaler_bdt.u32);
    {
      typedef __typeof__(*(&(before_dt))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = before_dt.insert_index(427,i);
      __item.value = scaler_bdt.value;
    }
    // UINT32 scaler_adt NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_dt[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } scaler_adt;
    READ_FROM_BUFFER_FULL(433,uint32 ,scaler_adt,scaler_adt.u32);
    {
      typedef __typeof__(*(&(after_dt))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = after_dt.insert_index(432,i);
      __item.value = scaler_adt.value;
    }
    // UINT32 scaler_ard NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_reduction[i],(value=value));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 value : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 value : 32; // 0..31
#endif
      };
      uint32  u32;
    } scaler_ard;
    READ_FROM_BUFFER_FULL(438,uint32 ,scaler_ard,scaler_ard.u32);
    {
      typedef __typeof__(*(&(after_reduction))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = after_reduction.insert_index(437,i);
      __item.value = scaler_ard.value;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_LMU_SCALERS::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLOII_LMU_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_LMU_SCALERS(id)
template<typename __data_src_t>
bool TRLOII_LMU_SCALERS::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 before_lmu[63] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_mux[31] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_aux[31] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_dt[127] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_dt[127] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_reduction[127] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_05: before_lmu;
    //  6_10: before_lmu_mux;
    // 11_15: before_lmu_aux;
    // 16_23: after_lmu;
    // 24_31: id = MATCH(id);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 before_lmu : 6; // 0..5
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu_aux : 5; // 11..15
      uint32 after_lmu : 8; // 16..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 after_lmu : 8; // 16..23
      uint32 before_lmu_aux : 5; // 11..15
      uint32 before_lmu_mux : 5; // 6..10
      uint32 before_lmu : 6; // 0..5
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(397,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(396,__header.id,id);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLOII_LMU_SCALERS::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLOII_LMU_SCALERS.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_LMU_SCALERS(id)
template<typename __data_dest_t>
void PACKER_TRLOII_LMU_SCALERS::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 before_lmu[63] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_mux[31] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_lmu_aux[31] ZERO_SUPPRESS);
  // MEMBER(DATA32 before_dt[127] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_dt[127] ZERO_SUPPRESS);
  // MEMBER(DATA32 after_reduction[127] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_05: before_lmu;
    //  6_10: before_lmu_mux;
    // 11_15: before_lmu_aux;
    // 16_23: after_lmu;
    // 24_31: id = MATCH(id);
  // }
  // list(0<=i<header.before_lmu)

  {
    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu[i],(value=value));
    // }
  }
  // list(0<=i<header.before_lmu_mux)

  {
    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_mux[i],(value=value));
    // }
  }
  // list(0<=i<header.before_lmu_aux)

  {
    // UINT32 scaler NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_lmu_aux[i],(value=value));
    // }
  }
  // list(0<=i<header.after_lmu)

  {
    // UINT32 scaler_bdt NOENCODE
    // {
      //  0_31: value;
      // ENCODE(before_dt[i],(value=value));
    // }
    // UINT32 scaler_adt NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_dt[i],(value=value));
    // }
    // UINT32 scaler_ard NOENCODE
    // {
      //  0_31: value;
      // ENCODE(after_reduction[i],(value=value));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_LMU_SCALERS::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLOII_SAMPLER
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLOII_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER(mark)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLOII_SAMPLER
class TRLOII_SAMPLER
#else//PACKER_CODE
# define DECLARED_PACKER_TRLOII_SAMPLER
class PACKER_TRLOII_SAMPLER
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 sampler[512] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,512> sampler;
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_num : 10; // 0..9
      uint32 overflow : 1; // 10
      uint32 dummy_11_15 : 5;
      uint32 mark : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 mark : 16; // 16..31
      uint32 dummy_11_15 : 5;
      uint32 overflow : 1; // 10
      uint32 word_num : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<header.word_num)

    // UINT32 time_lo NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler[index],(value=time));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 mark);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 mark);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 mark);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLOII_SAMPLER);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLOII_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER(mark)
template<typename __data_src_t>
void TRLOII_SAMPLER::__unpack(__data_src_t &__buffer,uint32 mark)
{
  // MEMBER(DATA32 sampler[512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  READ_FROM_BUFFER_FULL(450,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(449,header.mark,mark);
  CHECK_UNNAMED_BITS_ZERO(450,header.u32,0x0000f800);
  // list(0<=index<header.word_num)

  for (uint32 index = 0; index < (uint32) (header.word_num); ++index)
  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler[index],(value=time));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time : 30; // 0..29
        uint32 dunno : 1; // 30
        uint32 overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow : 1; // 31
        uint32 dunno : 1; // 30
        uint32 time : 30; // 0..29
#endif
      };
      uint32  u32;
    } time_lo;
    READ_FROM_BUFFER_FULL(459,uint32 ,time_lo,time_lo.u32);
    {
      typedef __typeof__(*(&(sampler))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = sampler.insert_index(458,index);
      __item.value = time_lo.time;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_SAMPLER::__unpack,uint32 mark);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLOII_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER(mark)
template<typename __data_src_t>
bool TRLOII_SAMPLER::__match(__data_src_t &__buffer,uint32 mark)
{
  // MEMBER(DATA32 sampler[512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_num : 10; // 0..9
      uint32 overflow : 1; // 10
      uint32 dummy_11_15 : 5;
      uint32 mark : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 mark : 16; // 16..31
      uint32 dummy_11_15 : 5;
      uint32 overflow : 1; // 10
      uint32 word_num : 10; // 0..9
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(450,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(449,__header.mark,mark);
  MATCH_UNNAMED_BITS_ZERO(450,__header.u32,0x0000f800);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLOII_SAMPLER::__match,uint32 mark);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLOII_SAMPLER.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER(mark)
template<typename __data_dest_t>
void PACKER_TRLOII_SAMPLER::__packer(__data_dest_t &__buffer,uint32 mark)
{
  // MEMBER(DATA32 sampler[512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  // list(0<=index<header.word_num)

  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler[index],(value=time));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_SAMPLER::__packer,uint32 mark);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLOII_SAMPLER_TWO
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLOII_SAMPLER_TWO.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER_TWO(mark)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLOII_SAMPLER_TWO
class TRLOII_SAMPLER_TWO
#else//PACKER_CODE
# define DECLARED_PACKER_TRLOII_SAMPLER_TWO
class PACKER_TRLOII_SAMPLER_TWO
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 sampler_hi[512] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,512> sampler_hi;
  // MEMBER(DATA32 sampler_lo[512] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA32,DATA32,512> sampler_lo;
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_num : 10; // 0..9
      uint32 overflow : 1; // 10
      uint32 dummy_11_15 : 5;
      uint32 mark : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 mark : 16; // 16..31
      uint32 dummy_11_15 : 5;
      uint32 overflow : 1; // 10
      uint32 word_num : 10; // 0..9
#endif
    };
    uint32  u32;
  } header;
  // list(0<=index<(header.word_num / 2))

    // UINT32 time_lo NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler_lo[index],(value=time));
    // }
    // UINT32 time_hi NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler_hi[index],(value=time));
    // }
  // if(((header.word_num % 2) == 1))

    // UINT32 last_word NOENCODE;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 mark);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 mark);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 mark);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLOII_SAMPLER_TWO);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLOII_SAMPLER_TWO.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER_TWO(mark)
template<typename __data_src_t>
void TRLOII_SAMPLER_TWO::__unpack(__data_src_t &__buffer,uint32 mark)
{
  // MEMBER(DATA32 sampler_hi[512] ZERO_SUPPRESS);
  // MEMBER(DATA32 sampler_lo[512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  READ_FROM_BUFFER_FULL(472,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(471,header.mark,mark);
  CHECK_UNNAMED_BITS_ZERO(472,header.u32,0x0000f800);
  // list(0<=index<(header.word_num / 2))

  for (uint32 index = 0; index < (uint32) ((header.word_num / 2)); ++index)
  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler_lo[index],(value=time));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time : 30; // 0..29
        uint32 dunno : 1; // 30
        uint32 overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow : 1; // 31
        uint32 dunno : 1; // 30
        uint32 time : 30; // 0..29
#endif
      };
      uint32  u32;
    } time_lo;
    READ_FROM_BUFFER_FULL(481,uint32 ,time_lo,time_lo.u32);
    {
      typedef __typeof__(*(&(sampler_lo))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = sampler_lo.insert_index(480,index);
      __item.value = time_lo.time;
    }
    // UINT32 time_hi NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler_hi[index],(value=time));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time : 30; // 0..29
        uint32 dunno : 1; // 30
        uint32 overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow : 1; // 31
        uint32 dunno : 1; // 30
        uint32 time : 30; // 0..29
#endif
      };
      uint32  u32;
    } time_hi;
    READ_FROM_BUFFER_FULL(488,uint32 ,time_hi,time_hi.u32);
    {
      typedef __typeof__(*(&(sampler_hi))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = sampler_hi.insert_index(487,index);
      __item.value = time_hi.time;
    }
  }
  // if(((header.word_num % 2) == 1))

  if (((header.word_num % 2) == 1))
  {
    // UINT32 last_word NOENCODE;
    uint32  last_word;READ_FROM_BUFFER(492,uint32 ,last_word);
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_SAMPLER_TWO::__unpack,uint32 mark);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLOII_SAMPLER_TWO.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER_TWO(mark)
template<typename __data_src_t>
bool TRLOII_SAMPLER_TWO::__match(__data_src_t &__buffer,uint32 mark)
{
  // MEMBER(DATA32 sampler_hi[512] ZERO_SUPPRESS);
  // MEMBER(DATA32 sampler_lo[512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_num : 10; // 0..9
      uint32 overflow : 1; // 10
      uint32 dummy_11_15 : 5;
      uint32 mark : 16; // 16..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 mark : 16; // 16..31
      uint32 dummy_11_15 : 5;
      uint32 overflow : 1; // 10
      uint32 word_num : 10; // 0..9
#endif
    };
    uint32  u32;
  } __header;
  READ_FROM_BUFFER_FULL(472,uint32 ,header,__header.u32);
  MATCH_BITS_EQUAL(471,__header.mark,mark);
  MATCH_UNNAMED_BITS_ZERO(472,__header.u32,0x0000f800);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLOII_SAMPLER_TWO::__match,uint32 mark);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLOII_SAMPLER_TWO.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_SAMPLER_TWO(mark)
template<typename __data_dest_t>
void PACKER_TRLOII_SAMPLER_TWO::__packer(__data_dest_t &__buffer,uint32 mark)
{
  // MEMBER(DATA32 sampler_hi[512] ZERO_SUPPRESS);
  // MEMBER(DATA32 sampler_lo[512] ZERO_SUPPRESS);
  // UINT32 header
  // {
    //  0_09: word_num;
    //    10: overflow;
    // 16_31: mark = MATCH(mark);
  // }
  // list(0<=index<(header.word_num / 2))

  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler_lo[index],(value=time));
    // }
    // UINT32 time_hi NOENCODE
    // {
      //  0_29: time;
      //    30: dunno;
      //    31: overflow;
      // ENCODE(sampler_hi[index],(value=time));
    // }
  }
  // if(((header.word_num % 2) == 1))

  if (((header.word_num % 2) == 1))
  {
    // UINT32 last_word NOENCODE;
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_SAMPLER_TWO::__packer,uint32 mark);

/** END_PACKER ********************************************************/

//
// Generating code for: TRLOII_TPAT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_TRLOII_TPAT
class TRLOII_TPAT
#else//PACKER_CODE
# define DECLARED_PACKER_TRLOII_TPAT
class PACKER_TRLOII_TPAT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 n);
  DATA32 n;
  // MEMBER(DATA16 tpat[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA16,DATA16,170> tpat;
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA8,DATA8,170> trig;
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,170> ts_lo;
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  raw_list_ii_zero_suppress<DATA32,DATA32,170> ts_hi;
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  // list(0<=index<(header.uint32_num / 3))

    // UINT32 time_lo NOENCODE
    // {
      //  0_31: t;
      // ENCODE(ts_lo APPEND_LIST,(value=t));
    // }
    // UINT32 time_hi NOENCODE
    // {
      //  0_30: t;
      //    31: overflow;
      // ENCODE(ts_hi APPEND_LIST,(value=t));
    // }
    // UINT32 trigger NOENCODE
    // {
      //  0_15: tpat;
      // 16_23: dunno;
      // 24_27: encoded;
      // 28_31: lec;
      // ENCODE(tpat APPEND_LIST,(value=tpat));
      // ENCODE(trig APPEND_LIST,(value=encoded));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(TRLOII_TPAT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
template<typename __data_src_t>
void TRLOII_TPAT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 n);
  // MEMBER(DATA16 tpat[170] NO_INDEX_LIST);
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 uint32_num : 12; // 0..11
      uint32 event_num : 12; // 12..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 event_num : 12; // 12..23
      uint32 uint32_num : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(509,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(507,header.id,id);
  {
    n.value = (header.uint32_num / 3);
  }
  // list(0<=index<(header.uint32_num / 3))

  for (uint32 index = 0; index < (uint32) ((header.uint32_num / 3)); ++index)
  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_31: t;
      // ENCODE(ts_lo APPEND_LIST,(value=t));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 t : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 t : 32; // 0..31
#endif
      };
      uint32  u32;
    } time_lo;
    READ_FROM_BUFFER_FULL(516,uint32 ,time_lo,time_lo.u32);
    {
      typedef __typeof__(*(&(ts_lo))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_lo.append_item(515);
      __item.value = time_lo.t;
    }
    // UINT32 time_hi NOENCODE
    // {
      //  0_30: t;
      //    31: overflow;
      // ENCODE(ts_hi APPEND_LIST,(value=t));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 t : 31; // 0..30
        uint32 overflow : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 overflow : 1; // 31
        uint32 t : 31; // 0..30
#endif
      };
      uint32  u32;
    } time_hi;
    READ_FROM_BUFFER_FULL(522,uint32 ,time_hi,time_hi.u32);
    {
      typedef __typeof__(*(&(ts_hi))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = ts_hi.append_item(521);
      __item.value = time_hi.t;
    }
    // UINT32 trigger NOENCODE
    // {
      //  0_15: tpat;
      // 16_23: dunno;
      // 24_27: encoded;
      // 28_31: lec;
      // ENCODE(tpat APPEND_LIST,(value=tpat));
      // ENCODE(trig APPEND_LIST,(value=encoded));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 tpat : 16; // 0..15
        uint32 dunno : 8; // 16..23
        uint32 encoded : 4; // 24..27
        uint32 lec : 4; // 28..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 lec : 4; // 28..31
        uint32 encoded : 4; // 24..27
        uint32 dunno : 8; // 16..23
        uint32 tpat : 16; // 0..15
#endif
      };
      uint32  u32;
    } trigger;
    READ_FROM_BUFFER_FULL(531,uint32 ,trigger,trigger.u32);
    {
      typedef __typeof__(*(&(tpat))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = tpat.append_item(529);
      __item.value = trigger.tpat;
    }
    {
      typedef __typeof__(*(&(trig))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = trig.append_item(530);
      __item.value = trigger.encoded;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_TPAT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
template<typename __data_src_t>
bool TRLOII_TPAT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 n);
  // MEMBER(DATA16 tpat[170] NO_INDEX_LIST);
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 uint32_num : 12; // 0..11
      uint32 event_num : 12; // 12..23
      uint32 id : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 id : 8; // 24..31
      uint32 event_num : 12; // 12..23
      uint32 uint32_num : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(509,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(507,header.id,id);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,TRLOII_TPAT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for TRLOII_TPAT.
 *
 * Do not edit - automatically generated.
 */

// TRLOII_TPAT(id)
template<typename __data_dest_t>
void PACKER_TRLOII_TPAT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA32 n);
  // MEMBER(DATA16 tpat[170] NO_INDEX_LIST);
  // MEMBER(DATA8 trig[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_lo[170] NO_INDEX_LIST);
  // MEMBER(DATA32 ts_hi[170] NO_INDEX_LIST);
  // UINT32 header NOENCODE
  // {
    //  0_11: uint32_num;
    // 12_23: event_num;
    // 24_31: id = MATCH(id);
    // ENCODE(n,(value=(uint32_num / 3)));
  // }
  // list(0<=index<(header.uint32_num / 3))

  {
    // UINT32 time_lo NOENCODE
    // {
      //  0_31: t;
      // ENCODE(ts_lo APPEND_LIST,(value=t));
    // }
    // UINT32 time_hi NOENCODE
    // {
      //  0_30: t;
      //    31: overflow;
      // ENCODE(ts_hi APPEND_LIST,(value=t));
    // }
    // UINT32 trigger NOENCODE
    // {
      //  0_15: tpat;
      // 16_23: dunno;
      // 24_27: encoded;
      // 28_31: lec;
      // ENCODE(tpat APPEND_LIST,(value=tpat));
      // ENCODE(trig APPEND_LIST,(value=encoded));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,TRLOII_TPAT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VFTX2_STATUS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VFTX2_STATUS.
 *
 * Do not edit - automatically generated.
 */

// VFTX2_STATUS()
#if !PACKER_CODE
# define DECLARED_UNPACK_VFTX2_STATUS
class VFTX2_STATUS
#else//PACKER_CODE
# define DECLARED_PACKER_VFTX2_STATUS
class PACKER_VFTX2_STATUS
#endif//PACKER_CODE

{
public:
  // UINT32 status;
  uint32  status;

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VFTX2_STATUS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VFTX2_STATUS.
 *
 * Do not edit - automatically generated.
 */

// VFTX2_STATUS()
template<typename __data_src_t>
void VFTX2_STATUS::__unpack(__data_src_t &__buffer)
{
  // UINT32 status;
  READ_FROM_BUFFER(537,uint32 ,status);
}
FORCE_IMPL_DATA_SRC_FCN(void,VFTX2_STATUS::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VFTX2_STATUS.
 *
 * Do not edit - automatically generated.
 */

// VFTX2_STATUS()
template<typename __data_src_t>
bool VFTX2_STATUS::__match(__data_src_t &__buffer)
{
  // UINT32 status;
  uint32  __status;
  READ_FROM_BUFFER(537,uint32 ,__status);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,VFTX2_STATUS::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VFTX2_STATUS.
 *
 * Do not edit - automatically generated.
 */

// VFTX2_STATUS()
template<typename __data_dest_t>
void PACKER_VFTX2_STATUS::__packer(__data_dest_t &__buffer)
{
  // UINT32 status;
}
FORCE_IMPL_DATA_SRC_FCN(void,VFTX2_STATUS::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_GSI_VFTX2
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_GSI_VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_GSI_VFTX2
class VME_GSI_VFTX2
#else//PACKER_CODE
# define DECLARED_PACKER_VME_GSI_VFTX2
class PACKER_VME_GSI_VFTX2
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA12,DATA12,32,100> time_fine;
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16,DATA16,32,100> time_coarse;
  // MEMBER(DATA16 time_trigger);
  DATA16 time_trigger;
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } custom_header;
  // if((0 < custom_header.count))

    // UINT32 event_header
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_7 : 8; // 0..7
        uint32 dummy_8_10 : 3;
        uint32 trigger_timestamp : 13; // 11..23
        uint32 dummy_24_28 : 5;
        uint32 unnamed_29_30 : 2; // 29..30
        uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_31_31 : 1; // 31
        uint32 unnamed_29_30 : 2; // 29..30
        uint32 dummy_24_28 : 5;
        uint32 trigger_timestamp : 13; // 11..23
        uint32 dummy_8_10 : 3;
        uint32 unnamed_0_7 : 8; // 0..7
#endif
      };
      uint32  u32;
    } event_header;
  // list(1<=index<custom_header.count)

    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_GSI_VFTX2);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_GSI_VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2(id)
template<typename __data_src_t>
void VME_GSI_VFTX2::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  READ_FROM_BUFFER_FULL(551,uint32 ,custom_header,custom_header.u32);
  CHECK_BITS_EQUAL(547,custom_header.id,id);
  CHECK_BITS_EQUAL(550,custom_header.unnamed_24_31,171);
  CHECK_UNNAMED_BITS_ZERO(551,custom_header.u32,0x00fc0000);
  // if((0 < custom_header.count))

  if ((0 < custom_header.count))
  {
    // UINT32 event_header
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
    READ_FROM_BUFFER_FULL(561,uint32 ,event_header,event_header.u32);
    CHECK_BITS_EQUAL(556,event_header.unnamed_0_7,170);
    CHECK_BITS_EQUAL(558,event_header.unnamed_29_30,1);
    CHECK_BITS_EQUAL(559,event_header.unnamed_31_31,1);
    CHECK_UNNAMED_BITS_ZERO(561,event_header.u32,0x1f000700);
    {
      time_trigger.value = event_header.trigger_timestamp;
    }
  }
  // list(1<=index<custom_header.count)

  for (uint32 index = 1; index < (uint32) (custom_header.count); ++index)
  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time_fine : 11; // 0..10
        uint32 time_coarse : 13; // 11..23
        uint32 future : 1; // 24
        uint32 channel : 5; // 25..29
        uint32 dummy_30_31 : 2;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 dummy_30_31 : 2;
        uint32 channel : 5; // 25..29
        uint32 future : 1; // 24
        uint32 time_coarse : 13; // 11..23
        uint32 time_fine : 11; // 0..10
#endif
      };
      uint32  u32;
    } event;
    READ_FROM_BUFFER_FULL(573,uint32 ,event,event.u32);
    CHECK_UNNAMED_BITS_ZERO(573,event.u32,0xc0000000);
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.insert_index(571,event.channel);
      __item.value = event.time_fine;
    }
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.insert_index(572,event.channel);
      __item.value = event.time_coarse;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_GSI_VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2(id)
template<typename __data_src_t>
bool VME_GSI_VFTX2::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } __custom_header;
  READ_FROM_BUFFER_FULL(551,uint32 ,custom_header,__custom_header.u32);
  MATCH_BITS_EQUAL(547,__custom_header.id,id);
  MATCH_BITS_EQUAL(550,__custom_header.unnamed_24_31,171);
  MATCH_UNNAMED_BITS_ZERO(551,__custom_header.u32,0x00fc0000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_GSI_VFTX2::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_GSI_VFTX2.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2(id)
template<typename __data_dest_t>
void PACKER_VME_GSI_VFTX2::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  // if((0 < custom_header.count))

  if ((0 < custom_header.count))
  {
    // UINT32 event_header
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
  }
  // list(1<=index<custom_header.count)

  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_GSI_VFTX2_7PS
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_GSI_VFTX2_7PS.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_7PS(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_GSI_VFTX2_7PS
class VME_GSI_VFTX2_7PS
#else//PACKER_CODE
# define DECLARED_PACKER_VME_GSI_VFTX2_7PS
class PACKER_VME_GSI_VFTX2_7PS
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA12,DATA12,32,100> time_fine;
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16,DATA16,32,100> time_coarse;
  // MEMBER(DATA16 time_trigger);
  DATA16 time_trigger;
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } custom_header;
  // if((0 < custom_header.count))

    // UINT32 event_header NOENCODE
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
  // list(1<=index<custom_header.count)

    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_GSI_VFTX2_7PS);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_GSI_VFTX2_7PS.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_7PS(id)
template<typename __data_src_t>
void VME_GSI_VFTX2_7PS::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  READ_FROM_BUFFER_FULL(588,uint32 ,custom_header,custom_header.u32);
  CHECK_BITS_EQUAL(584,custom_header.id,id);
  CHECK_BITS_EQUAL(587,custom_header.unnamed_24_31,171);
  CHECK_UNNAMED_BITS_ZERO(588,custom_header.u32,0x00fc0000);
  // if((0 < custom_header.count))

  if ((0 < custom_header.count))
  {
    // UINT32 event_header NOENCODE
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_7 : 8; // 0..7
        uint32 dummy_8_10 : 3;
        uint32 trigger_timestamp : 13; // 11..23
        uint32 dummy_24_28 : 5;
        uint32 unnamed_29_30 : 2; // 29..30
        uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_31_31 : 1; // 31
        uint32 unnamed_29_30 : 2; // 29..30
        uint32 dummy_24_28 : 5;
        uint32 trigger_timestamp : 13; // 11..23
        uint32 dummy_8_10 : 3;
        uint32 unnamed_0_7 : 8; // 0..7
#endif
      };
      uint32  u32;
    } event_header;
    READ_FROM_BUFFER_FULL(598,uint32 ,event_header,event_header.u32);
    CHECK_BITS_EQUAL(593,event_header.unnamed_0_7,170);
    CHECK_BITS_EQUAL(595,event_header.unnamed_29_30,1);
    CHECK_BITS_EQUAL(596,event_header.unnamed_31_31,1);
    CHECK_UNNAMED_BITS_ZERO(598,event_header.u32,0x1f000700);
    {
      time_trigger.value = event_header.trigger_timestamp;
    }
  }
  // list(1<=index<custom_header.count)

  for (uint32 index = 1; index < (uint32) (custom_header.count); ++index)
  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time_fine : 11; // 0..10
        uint32 time_coarse : 13; // 11..23
        uint32 future : 1; // 24
        uint32 channel : 5; // 25..29
        uint32 dummy_30_31 : 2;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 dummy_30_31 : 2;
        uint32 channel : 5; // 25..29
        uint32 future : 1; // 24
        uint32 time_coarse : 13; // 11..23
        uint32 time_fine : 11; // 0..10
#endif
      };
      uint32  u32;
    } event;
    READ_FROM_BUFFER_FULL(610,uint32 ,event,event.u32);
    CHECK_UNNAMED_BITS_ZERO(610,event.u32,0xc0000000);
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.insert_index(608,event.channel);
      __item.value = event.time_fine;
    }
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.insert_index(609,event.channel);
      __item.value = event.time_coarse;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2_7PS::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_GSI_VFTX2_7PS.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_7PS(id)
template<typename __data_src_t>
bool VME_GSI_VFTX2_7PS::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } __custom_header;
  READ_FROM_BUFFER_FULL(588,uint32 ,custom_header,__custom_header.u32);
  MATCH_BITS_EQUAL(584,__custom_header.id,id);
  MATCH_BITS_EQUAL(587,__custom_header.unnamed_24_31,171);
  MATCH_UNNAMED_BITS_ZERO(588,__custom_header.u32,0x00fc0000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_GSI_VFTX2_7PS::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_GSI_VFTX2_7PS.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_7PS(id)
template<typename __data_dest_t>
void PACKER_VME_GSI_VFTX2_7PS::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  // if((0 < custom_header.count))

  if ((0 < custom_header.count))
  {
    // UINT32 event_header NOENCODE
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
  }
  // list(1<=index<custom_header.count)

  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_29: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2_7PS::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_GSI_VFTX2_LT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_GSI_VFTX2_LT.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_LT(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_GSI_VFTX2_LT
class VME_GSI_VFTX2_LT
#else//PACKER_CODE
# define DECLARED_PACKER_VME_GSI_VFTX2_LT
class PACKER_VME_GSI_VFTX2_LT
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_fine[64] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA12,DATA12,64,100> time_fine;
  // MEMBER(DATA16 time_coarse[64] ZERO_SUPPRESS_MULTI(100));
  raw_array_multi_zero_suppress<DATA16,DATA16,64,100> time_coarse;
  // MEMBER(DATA16 time_trigger);
  DATA16 time_trigger;
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } custom_header;
  // if((0 < custom_header.count))

    // UINT32 event_header
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 unnamed_0_7 : 8; // 0..7
        uint32 dummy_8_10 : 3;
        uint32 trigger_timestamp : 13; // 11..23
        uint32 dummy_24_28 : 5;
        uint32 unnamed_29_30 : 2; // 29..30
        uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 unnamed_31_31 : 1; // 31
        uint32 unnamed_29_30 : 2; // 29..30
        uint32 dummy_24_28 : 5;
        uint32 trigger_timestamp : 13; // 11..23
        uint32 dummy_8_10 : 3;
        uint32 unnamed_0_7 : 8; // 0..7
#endif
      };
      uint32  u32;
    } event_header;
  // list(1<=index<custom_header.count)

    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_30: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_GSI_VFTX2_LT);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_GSI_VFTX2_LT.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_LT(id)
template<typename __data_src_t>
void VME_GSI_VFTX2_LT::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[64] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[64] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  READ_FROM_BUFFER_FULL(625,uint32 ,custom_header,custom_header.u32);
  CHECK_BITS_EQUAL(621,custom_header.id,id);
  CHECK_BITS_EQUAL(624,custom_header.unnamed_24_31,171);
  CHECK_UNNAMED_BITS_ZERO(625,custom_header.u32,0x00fc0000);
  // if((0 < custom_header.count))

  if ((0 < custom_header.count))
  {
    // UINT32 event_header
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
    READ_FROM_BUFFER_FULL(635,uint32 ,event_header,event_header.u32);
    CHECK_BITS_EQUAL(630,event_header.unnamed_0_7,170);
    CHECK_BITS_EQUAL(632,event_header.unnamed_29_30,1);
    CHECK_BITS_EQUAL(633,event_header.unnamed_31_31,1);
    CHECK_UNNAMED_BITS_ZERO(635,event_header.u32,0x1f000700);
    {
      time_trigger.value = event_header.trigger_timestamp;
    }
  }
  // list(1<=index<custom_header.count)

  for (uint32 index = 1; index < (uint32) (custom_header.count); ++index)
  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_30: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time_fine : 11; // 0..10
        uint32 time_coarse : 13; // 11..23
        uint32 future : 1; // 24
        uint32 channel : 6; // 25..30
        uint32 dummy_31 : 1;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 dummy_31 : 1;
        uint32 channel : 6; // 25..30
        uint32 future : 1; // 24
        uint32 time_coarse : 13; // 11..23
        uint32 time_fine : 11; // 0..10
#endif
      };
      uint32  u32;
    } event;
    READ_FROM_BUFFER_FULL(647,uint32 ,event,event.u32);
    CHECK_UNNAMED_BITS_ZERO(647,event.u32,0x80000000);
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.insert_index(645,event.channel);
      __item.value = event.time_fine;
    }
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.insert_index(646,event.channel);
      __item.value = event.time_coarse;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2_LT::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_GSI_VFTX2_LT.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_LT(id)
template<typename __data_src_t>
bool VME_GSI_VFTX2_LT::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[64] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[64] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 id : 5; // 0..4
      uint32 internal_status : 4; // 5..8
      uint32 count : 9; // 9..17
      uint32 dummy_18_23 : 6;
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 dummy_18_23 : 6;
      uint32 count : 9; // 9..17
      uint32 internal_status : 4; // 5..8
      uint32 id : 5; // 0..4
#endif
    };
    uint32  u32;
  } __custom_header;
  READ_FROM_BUFFER_FULL(625,uint32 ,custom_header,__custom_header.u32);
  MATCH_BITS_EQUAL(621,__custom_header.id,id);
  MATCH_BITS_EQUAL(624,__custom_header.unnamed_24_31,171);
  MATCH_UNNAMED_BITS_ZERO(625,__custom_header.u32,0x00fc0000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_GSI_VFTX2_LT::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_GSI_VFTX2_LT.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_LT(id)
template<typename __data_dest_t>
void PACKER_VME_GSI_VFTX2_LT::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[64] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_coarse[64] ZERO_SUPPRESS_MULTI(100));
  // MEMBER(DATA16 time_trigger);
  // UINT32 custom_header
  // {
    //  0_04: id = MATCH(id);
    //  5_08: internal_status;
    //  9_17: count;
    // 24_31: 171;
  // }
  // if((0 < custom_header.count))

  if ((0 < custom_header.count))
  {
    // UINT32 event_header
    // {
      //  0_07: 170;
      // 11_23: trigger_timestamp;
      // 29_30: 1;
      //    31: 1;
      // ENCODE(time_trigger,(value=trigger_timestamp));
    // }
  }
  // list(1<=index<custom_header.count)

  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_30: channel;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2_LT::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_GSI_VFTX2_STRAW
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_GSI_VFTX2_STRAW.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_STRAW(id)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_GSI_VFTX2_STRAW
class VME_GSI_VFTX2_STRAW
#else//PACKER_CODE
# define DECLARED_PACKER_VME_GSI_VFTX2_STRAW
class PACKER_VME_GSI_VFTX2_STRAW
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA12,DATA12,32,32> time_fine;
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(32));
  raw_array_multi_zero_suppress<DATA16,DATA16,32,32> time_coarse;
  // MEMBER(DATA16 time_trigger);
  DATA16 time_trigger;
  // UINT32 status
  // {
    //  0_03: internal;
    //  4_12: count;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 internal : 4; // 0..3
      uint32 count : 9; // 4..12
      uint32 dummy_13_31 : 19;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 dummy_13_31 : 19;
      uint32 count : 9; // 4..12
      uint32 internal : 4; // 0..3
#endif
    };
    uint32  u32;
  } status;
  // UINT32 custom_header
  // {
    //  0_15: count;
    // 16_23: id = MATCH(id);
    // 24_31: 171;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 count : 16; // 0..15
      uint32 id : 8; // 16..23
      uint32 unnamed_24_31 : 8; // 24..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_24_31 : 8; // 24..31
      uint32 id : 8; // 16..23
      uint32 count : 16; // 0..15
#endif
    };
    uint32  u32;
  } custom_header;
  // UINT32 event_header
  // {
    //  0_07: 170;
    // 11_23: trigger_timestamp;
    // 29_30: 1;
    //    31: 1;
    // ENCODE(time_trigger,(value=trigger_timestamp));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_7 : 8; // 0..7
      uint32 dummy_8_10 : 3;
      uint32 trigger_timestamp : 13; // 11..23
      uint32 dummy_24_28 : 5;
      uint32 unnamed_29_30 : 2; // 29..30
      uint32 unnamed_31_31 : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_31_31 : 1; // 31
      uint32 unnamed_29_30 : 2; // 29..30
      uint32 dummy_24_28 : 5;
      uint32 trigger_timestamp : 13; // 11..23
      uint32 dummy_8_10 : 3;
      uint32 unnamed_0_7 : 8; // 0..7
#endif
    };
    uint32  u32;
  } event_header;
  // list(0<=index<custom_header.count)

    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_30: channel;
      //    31: bluppidupp;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 id);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 id);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 id);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_GSI_VFTX2_STRAW);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_GSI_VFTX2_STRAW.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_STRAW(id)
template<typename __data_src_t>
void VME_GSI_VFTX2_STRAW::__unpack(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA16 time_trigger);
  // UINT32 status
  // {
    //  0_03: internal;
    //  4_12: count;
  // }
  READ_FROM_BUFFER_FULL(660,uint32 ,status,status.u32);
  CHECK_UNNAMED_BITS_ZERO(660,status.u32,0xffffe000);
  // UINT32 custom_header
  // {
    //  0_15: count;
    // 16_23: id = MATCH(id);
    // 24_31: 171;
  // }
  READ_FROM_BUFFER_FULL(666,uint32 ,custom_header,custom_header.u32);
  CHECK_BITS_EQUAL(664,custom_header.id,id);
  CHECK_BITS_EQUAL(665,custom_header.unnamed_24_31,171);
  // UINT32 event_header
  // {
    //  0_07: 170;
    // 11_23: trigger_timestamp;
    // 29_30: 1;
    //    31: 1;
    // ENCODE(time_trigger,(value=trigger_timestamp));
  // }
  READ_FROM_BUFFER_FULL(674,uint32 ,event_header,event_header.u32);
  CHECK_BITS_EQUAL(669,event_header.unnamed_0_7,170);
  CHECK_BITS_EQUAL(671,event_header.unnamed_29_30,1);
  CHECK_BITS_EQUAL(672,event_header.unnamed_31_31,1);
  CHECK_UNNAMED_BITS_ZERO(674,event_header.u32,0x1f000700);
  {
    time_trigger.value = event_header.trigger_timestamp;
  }
  // list(0<=index<custom_header.count)

  for (uint32 index = 0; index < (uint32) (custom_header.count); ++index)
  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_30: channel;
      //    31: bluppidupp;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
    union
    {
      struct
      {
#if __BYTE_ORDER == __LITTLE_ENDIAN
        uint32 time_fine : 11; // 0..10
        uint32 time_coarse : 13; // 11..23
        uint32 future : 1; // 24
        uint32 channel : 6; // 25..30
        uint32 bluppidupp : 1; // 31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
        uint32 bluppidupp : 1; // 31
        uint32 channel : 6; // 25..30
        uint32 future : 1; // 24
        uint32 time_coarse : 13; // 11..23
        uint32 time_fine : 11; // 0..10
#endif
      };
      uint32  u32;
    } event;
    READ_FROM_BUFFER_FULL(686,uint32 ,event,event.u32);
    {
      typedef __typeof__(*(&(time_fine))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_fine.insert_index(684,event.channel);
      __item.value = event.time_fine;
    }
    {
      typedef __typeof__(*(&(time_coarse))) __array_t;
      typedef typename __array_t::item_t __item_t;
      __item_t &__item = time_coarse.insert_index(685,event.channel);
      __item.value = event.time_coarse;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2_STRAW::__unpack,uint32 id);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_GSI_VFTX2_STRAW.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_STRAW(id)
template<typename __data_src_t>
bool VME_GSI_VFTX2_STRAW::__match(__data_src_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA16 time_trigger);
  // UINT32 status
  // {
    //  0_03: internal;
    //  4_12: count;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 internal : 4; // 0..3
      uint32 count : 9; // 4..12
      uint32 dummy_13_31 : 19;
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 dummy_13_31 : 19;
      uint32 count : 9; // 4..12
      uint32 internal : 4; // 0..3
#endif
    };
    uint32  u32;
  } __status;
  READ_FROM_BUFFER_FULL(660,uint32 ,status,__status.u32);
  MATCH_UNNAMED_BITS_ZERO(660,__status.u32,0xffffe000);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_GSI_VFTX2_STRAW::__match,uint32 id);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_GSI_VFTX2_STRAW.
 *
 * Do not edit - automatically generated.
 */

// VME_GSI_VFTX2_STRAW(id)
template<typename __data_dest_t>
void PACKER_VME_GSI_VFTX2_STRAW::__packer(__data_dest_t &__buffer,uint32 id)
{
  // MEMBER(DATA12 time_fine[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA16 time_coarse[32] ZERO_SUPPRESS_MULTI(32));
  // MEMBER(DATA16 time_trigger);
  // UINT32 status
  // {
    //  0_03: internal;
    //  4_12: count;
  // }
  // UINT32 custom_header
  // {
    //  0_15: count;
    // 16_23: id = MATCH(id);
    // 24_31: 171;
  // }
  // UINT32 event_header
  // {
    //  0_07: 170;
    // 11_23: trigger_timestamp;
    // 29_30: 1;
    //    31: 1;
    // ENCODE(time_trigger,(value=trigger_timestamp));
  // }
  // list(0<=index<custom_header.count)

  {
    // UINT32 event NOENCODE
    // {
      //  0_10: time_fine;
      // 11_23: time_coarse;
      //    24: future;
      // 25_30: channel;
      //    31: bluppidupp;
      // ENCODE(time_fine[channel],(value=time_fine));
      // ENCODE(time_coarse[channel],(value=time_coarse));
    // }
  }
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_GSI_VFTX2_STRAW::__packer,uint32 id);

/** END_PACKER ********************************************************/

//
// Generating code for: VME_MESYTEC_MADC32
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
#if !PACKER_CODE
# define DECLARED_UNPACK_VME_MESYTEC_MADC32
class VME_MESYTEC_MADC32
#else//PACKER_CODE
# define DECLARED_PACKER_VME_MESYTEC_MADC32
class PACKER_VME_MESYTEC_MADC32
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  raw_array_zero_suppress<DATA14_OVERFLOW,DATA14_OVERFLOW,32> data;
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 counter : 30; // 0..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 counter : 30; // 0..29
#endif
    };
    uint32  u32;
  } end_of_event;
  // MARK_COUNT(end);
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer,uint32 geom);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer,uint32 geom);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer,uint32 geom);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(VME_MESYTEC_MADC32);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
void VME_MESYTEC_MADC32::__unpack(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._data;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(702,uint32 ,header,header.u32);
  CHECK_BITS_EQUAL(699,header.geom,geom);
  CHECK_BITS_EQUAL(700,header.unnamed_24_29,0);
  CHECK_BITS_EQUAL(701,header.unnamed_30_31,1);
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  for ( ; ; ) {
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 value : 13; // 0..12
      uint32 dummy_13 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_15 : 1;
      uint32 channel : 5; // 16..20
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_21_29 : 9; // 21..29
      uint32 channel : 5; // 16..20
      uint32 dummy_15 : 1;
      uint32 outofrange : 1; // 14
      uint32 dummy_13 : 1;
      uint32 value : 13; // 0..12
#endif
    };
    uint32  u32;
  } ch_data;
  if (__buffer.empty()) goto data_done_0;
  PEEK_FROM_BUFFER_FULL(711,uint32 ,ch_data,ch_data.u32);
  CHECK_JUMP_BITS_EQUAL(708,ch_data.unnamed_21_29,32,data_done_0);
  CHECK_JUMP_BITS_EQUAL(709,ch_data.unnamed_30_31,0,data_done_0);
  CHECK_JUMP_UNNAMED_BITS_ZERO(711,ch_data.u32,0x0000a000,data_done_0);
  __buffer.advance(sizeof(ch_data.u32));
  {
    typedef __typeof__(*(&(data))) __array_t;
    typedef typename __array_t::item_t __item_t;
    __item_t &__item = data.insert_index(710,ch_data.channel);
    __item.value = ch_data.value;
    __item.overflow = ch_data.outofrange;
  }
  }
  data_done_0:;
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_0_31 : 32; // 0..31
#endif
    };
    uint32  u32;
  } filler;
  if (__buffer.empty()) goto data_done_1;
  PEEK_FROM_BUFFER_FULL(715,uint32 ,filler,filler.u32);
  CHECK_JUMP_BITS_EQUAL(714,filler.unnamed_0_31,0,data_done_1);
  __buffer.advance(sizeof(filler.u32));
  data_done_1:;
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  READ_FROM_BUFFER_FULL(720,uint32 ,end_of_event,end_of_event.u32);
  CHECK_BITS_EQUAL(719,end_of_event.unnamed_30_31,3);
  // MARK_COUNT(end);
  void *__mark_end = __buffer._data;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
  CHECK_WORD_COUNT(722,header.word_number,start,end,( - 4),4);
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__unpack,uint32 geom);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_src_t>
bool VME_MESYTEC_MADC32::__match(__data_src_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 word_number : 12; // 0..11
      uint32 adc_resol : 3; // 12..14
      uint32 out_form : 1; // 15
      uint32 geom : 8; // 16..23
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 unnamed_30_31 : 2; // 30..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 unnamed_30_31 : 2; // 30..31
      uint32 unnamed_24_29 : 6; // 24..29
      uint32 geom : 8; // 16..23
      uint32 out_form : 1; // 15
      uint32 adc_resol : 3; // 12..14
      uint32 word_number : 12; // 0..11
#endif
    };
    uint32  u32;
  } header;
  READ_FROM_BUFFER_FULL(702,uint32 ,header,header.u32);
  MATCH_BITS_EQUAL(699,header.geom,geom);
  MATCH_BITS_EQUAL(700,header.unnamed_24_29,0);
  MATCH_BITS_EQUAL(701,header.unnamed_30_31,1);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN_ARG(bool,VME_MESYTEC_MADC32::__match,uint32 geom);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for VME_MESYTEC_MADC32.
 *
 * Do not edit - automatically generated.
 */

// VME_MESYTEC_MADC32(geom)
template<typename __data_dest_t>
void PACKER_VME_MESYTEC_MADC32::__packer(__data_dest_t &__buffer,uint32 geom)
{
  // MEMBER(DATA14_OVERFLOW data[32] ZERO_SUPPRESS);
  // MARK_COUNT(start);
  void *__mark_start = __buffer._offset;
  // UINT32 header NOENCODE
  // {
    //  0_11: word_number;
    // 12_14: adc_resol;
    //    15: out_form;
    // 16_23: geom = MATCH(geom);
    // 24_29: 0;
    // 30_31: 1;
  // }
  // several UINT32 ch_data NOENCODE
  // {
    //  0_12: value;
    //    14: outofrange;
    // 16_20: channel;
    // 21_29: 32;
    // 30_31: 0;
    // ENCODE(data[channel],(value=value,overflow=outofrange));
  // }
  // optional UINT32 filler NOENCODE
  // {
    //  0_31: 0;
  // }
  // UINT32 end_of_event
  // {
    //  0_29: counter;
    // 30_31: 3;
  // }
  // MARK_COUNT(end);
  void *__mark_end = __buffer._offset;
  // CHECK_COUNT(header.word_number,start,end,( - 4),4)
}
FORCE_IMPL_DATA_SRC_FCN_ARG(void,VME_MESYTEC_MADC32::__packer,uint32 geom);

/** END_PACKER ********************************************************/

//
// Generating code for: WR_MULTI
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
#if !PACKER_CODE
# define DECLARED_UNPACK_WR_MULTI
class WR_MULTI
#else//PACKER_CODE
# define DECLARED_PACKER_WR_MULTI
class PACKER_WR_MULTI
#endif//PACKER_CODE

{
public:
  // MEMBER(DATA32 time_hi);
  DATA32 time_hi;
  // MEMBER(DATA32 time_lo);
  DATA32 time_lo;
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(WR_MULTI);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
void WR_MULTI::__unpack(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(733,uint32 ,hi,hi.u32);
  {
    time_hi.value = hi.time;
  }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } lo;
  READ_FROM_BUFFER_FULL(738,uint32 ,lo,lo.u32);
  {
    time_lo.value = lo.time;
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_src_t>
bool WR_MULTI::__match(__data_src_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  union
  {
    struct
    {
#if __BYTE_ORDER == __LITTLE_ENDIAN
      uint32 time : 32; // 0..31
#endif
#if __BYTE_ORDER == __BIG_ENDIAN
      uint32 time : 32; // 0..31
#endif
    };
    uint32  u32;
  } hi;
  READ_FROM_BUFFER_FULL(733,uint32 ,hi,hi.u32);
  return true;
  return false;
}
FORCE_IMPL_DATA_SRC_FCN(bool,WR_MULTI::__match);

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for WR_MULTI.
 *
 * Do not edit - automatically generated.
 */

// WR_MULTI()
template<typename __data_dest_t>
void PACKER_WR_MULTI::__packer(__data_dest_t &__buffer)
{
  // MEMBER(DATA32 time_hi);
  // MEMBER(DATA32 time_lo);
  // UINT32 hi NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_hi,(value=time));
  // }
  // UINT32 lo NOENCODE
  // {
    //  0_31: time;
    // ENCODE(time_lo,(value=time));
  // }
}
FORCE_IMPL_DATA_SRC_FCN(void,WR_MULTI::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: empty_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for empty_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(empty_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_empty_subev
class empty_subev
#else//PACKER_CODE
# define DECLARED_PACKER_empty_subev
class PACKER_empty_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(empty_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for empty_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(empty_subev)
template<typename __data_src_t>
void empty_subev::__unpack(__data_src_t &__buffer)
{
}
FORCE_IMPL_DATA_SRC_FCN(void,empty_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for empty_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(empty_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for empty_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(empty_subev)
template<typename __data_dest_t>
void PACKER_empty_subev::__packer(__data_dest_t &__buffer)
{
}
FORCE_IMPL_DATA_SRC_FCN(void,empty_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: fitest_febex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for fitest_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fitest_febex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_fitest_febex_subev
class fitest_febex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_fitest_febex_subev
class PACKER_fitest_febex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // header = FEBEX_EVENTHEADER();
  // select several

    // padding = FEBEX_PADDING();
  SINGLE(FEBEX_PADDING,padding);
  // select several

    // febex[0] = FEBEX_NOTRACE(sfp=3,card=0);
    // febex[1] = FEBEX_NOTRACE(sfp=3,card=1);
    // febex[2] = FEBEX_NOTRACE(sfp=3,card=2);
    // febex[3] = FEBEX_NOTRACE(sfp=3,card=3);
    // febex[4] = FEBEX_NOTRACE(sfp=3,card=4);
    // febex[5] = FEBEX_NOTRACE(sfp=3,card=5);
    // febex[6] = FEBEX_NOTRACE(sfp=3,card=6);
    // febex[7] = FEBEX_NOTRACE(sfp=3,card=7);
    // febextrace[0] = FEBEX_TRACE(sfp=3,card=0);
    // febextrace[1] = FEBEX_TRACE(sfp=3,card=1);
    // febextrace[2] = FEBEX_TRACE(sfp=3,card=2);
    // febextrace[3] = FEBEX_TRACE(sfp=3,card=3);
    // febextrace[4] = FEBEX_TRACE(sfp=3,card=4);
    // febextrace[5] = FEBEX_TRACE(sfp=3,card=5);
    // febextrace[6] = FEBEX_TRACE(sfp=3,card=6);
    // febextrace[7] = FEBEX_TRACE(sfp=3,card=7);
  SINGLE(FEBEX_NOTRACE,febex[8]);
  SINGLE(FEBEX_TRACE,febextrace[8]);
  SINGLE(FEBEX_EVENTHEADER,header);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(fitest_febex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for fitest_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fitest_febex_subev)
template<typename __data_src_t>
void fitest_febex_subev::__unpack(__data_src_t &__buffer)
{
  // header = FEBEX_EVENTHEADER();
  UNPACK_DECL(748,FEBEX_EVENTHEADER,header);
  // select several

    // padding = FEBEX_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_PADDING padding: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(752,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(751,spurious_match_abort_loop_1,FEBEX_PADDING);
        UNPACK_DECL(751,FEBEX_PADDING,padding);
        break;
    }
  }
  spurious_match_abort_loop_1:;
  // select several

    // febex[0] = FEBEX_NOTRACE(sfp=3,card=0);
    // febex[1] = FEBEX_NOTRACE(sfp=3,card=1);
    // febex[2] = FEBEX_NOTRACE(sfp=3,card=2);
    // febex[3] = FEBEX_NOTRACE(sfp=3,card=3);
    // febex[4] = FEBEX_NOTRACE(sfp=3,card=4);
    // febex[5] = FEBEX_NOTRACE(sfp=3,card=5);
    // febex[6] = FEBEX_NOTRACE(sfp=3,card=6);
    // febex[7] = FEBEX_NOTRACE(sfp=3,card=7);
    // febextrace[0] = FEBEX_TRACE(sfp=3,card=0);
    // febextrace[1] = FEBEX_TRACE(sfp=3,card=1);
    // febextrace[2] = FEBEX_TRACE(sfp=3,card=2);
    // febextrace[3] = FEBEX_TRACE(sfp=3,card=3);
    // febextrace[4] = FEBEX_TRACE(sfp=3,card=4);
    // febextrace[5] = FEBEX_TRACE(sfp=3,card=5);
    // febextrace[6] = FEBEX_TRACE(sfp=3,card=6);
    // febextrace[7] = FEBEX_TRACE(sfp=3,card=7);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_NOTRACE febex[0]: (s32) => (0xfffff0ff,0xff003034)
    // optimized match 2: FEBEX_NOTRACE febex[1]: (s32) => (0xfffff0ff,0xff013034)
    // optimized match 3: FEBEX_NOTRACE febex[2]: (s32) => (0xfffff0ff,0xff023034)
    // optimized match 4: FEBEX_NOTRACE febex[3]: (s32) => (0xfffff0ff,0xff033034)
    // optimized match 5: FEBEX_NOTRACE febex[4]: (s32) => (0xfffff0ff,0xff043034)
    // optimized match 6: FEBEX_NOTRACE febex[5]: (s32) => (0xfffff0ff,0xff053034)
    // optimized match 7: FEBEX_NOTRACE febex[6]: (s32) => (0xfffff0ff,0xff063034)
    // optimized match 8: FEBEX_NOTRACE febex[7]: (s32) => (0xfffff0ff,0xff073034)
    // optimized match 9: FEBEX_TRACE febextrace[0]: (s32) => (0x00fff0ff,0x00003034)
    // optimized match 10: FEBEX_TRACE febextrace[1]: (s32) => (0x00fff0ff,0x00013034)
    // optimized match 11: FEBEX_TRACE febextrace[2]: (s32) => (0x00fff0ff,0x00023034)
    // optimized match 12: FEBEX_TRACE febextrace[3]: (s32) => (0x00fff0ff,0x00033034)
    // optimized match 13: FEBEX_TRACE febextrace[4]: (s32) => (0x00fff0ff,0x00043034)
    // optimized match 14: FEBEX_TRACE febextrace[5]: (s32) => (0x00fff0ff,0x00053034)
    // optimized match 15: FEBEX_TRACE febextrace[6]: (s32) => (0x00fff0ff,0x00063034)
    // optimized match 16: FEBEX_TRACE febextrace[7]: (s32) => (0x00fff0ff,0x00073034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(771,uint32,__match_peek);
    // differ = ff070000 : 16 17 18 24 25 26 27 28 29 30 31
    // select on bit 18, partition: 1:8(d8) 0:8(d8)
    if (__match_peek & 0x00040000) {
      // select on bit 17, partition: 1:4(d4) 0:4(d4)
      if (__match_peek & 0x00020000) {
        // select on bit 16, partition: 1:2(d2) 0:2(d2)
        if (__match_peek & 0x00010000) {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(762,__match_no,8,febex[7],__match_peek,0xfffff0ff,0xff073034,FEBEX_NOTRACE,/*sfp*/3,/*card*/7);
          VERIFY_MATCH_DECL_QUICK(770,__match_no,16,febextrace[7],__match_peek,0x00fff0ff,0x00073034,FEBEX_TRACE,/*sfp*/3,/*card*/7);
        } else {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(761,__match_no,7,febex[6],__match_peek,0xfffff0ff,0xff063034,FEBEX_NOTRACE,/*sfp*/3,/*card*/6);
          VERIFY_MATCH_DECL_QUICK(769,__match_no,15,febextrace[6],__match_peek,0x00fff0ff,0x00063034,FEBEX_TRACE,/*sfp*/3,/*card*/6);
        }
      } else {
        // select on bit 16, partition: 1:2(d2) 0:2(d2)
        if (__match_peek & 0x00010000) {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(760,__match_no,6,febex[5],__match_peek,0xfffff0ff,0xff053034,FEBEX_NOTRACE,/*sfp*/3,/*card*/5);
          VERIFY_MATCH_DECL_QUICK(768,__match_no,14,febextrace[5],__match_peek,0x00fff0ff,0x00053034,FEBEX_TRACE,/*sfp*/3,/*card*/5);
        } else {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(759,__match_no,5,febex[4],__match_peek,0xfffff0ff,0xff043034,FEBEX_NOTRACE,/*sfp*/3,/*card*/4);
          VERIFY_MATCH_DECL_QUICK(767,__match_no,13,febextrace[4],__match_peek,0x00fff0ff,0x00043034,FEBEX_TRACE,/*sfp*/3,/*card*/4);
        }
      }
    } else {
      // select on bit 17, partition: 1:4(d4) 0:4(d4)
      if (__match_peek & 0x00020000) {
        // select on bit 16, partition: 1:2(d2) 0:2(d2)
        if (__match_peek & 0x00010000) {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(758,__match_no,4,febex[3],__match_peek,0xfffff0ff,0xff033034,FEBEX_NOTRACE,/*sfp*/3,/*card*/3);
          VERIFY_MATCH_DECL_QUICK(766,__match_no,12,febextrace[3],__match_peek,0x00fff0ff,0x00033034,FEBEX_TRACE,/*sfp*/3,/*card*/3);
        } else {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(757,__match_no,3,febex[2],__match_peek,0xfffff0ff,0xff023034,FEBEX_NOTRACE,/*sfp*/3,/*card*/2);
          VERIFY_MATCH_DECL_QUICK(765,__match_no,11,febextrace[2],__match_peek,0x00fff0ff,0x00023034,FEBEX_TRACE,/*sfp*/3,/*card*/2);
        }
      } else {
        // select on bit 16, partition: 1:2(d2) 0:2(d2)
        if (__match_peek & 0x00010000) {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(756,__match_no,2,febex[1],__match_peek,0xfffff0ff,0xff013034,FEBEX_NOTRACE,/*sfp*/3,/*card*/1);
          VERIFY_MATCH_DECL_QUICK(764,__match_no,10,febextrace[1],__match_peek,0x00fff0ff,0x00013034,FEBEX_TRACE,/*sfp*/3,/*card*/1);
        } else {
          // Indistinguishable: 0 1
          VERIFY_MATCH_DECL_QUICK(755,__match_no,1,febex[0],__match_peek,0xfffff0ff,0xff003034,FEBEX_NOTRACE,/*sfp*/3,/*card*/0);
          VERIFY_MATCH_DECL_QUICK(763,__match_no,9,febextrace[0],__match_peek,0x00fff0ff,0x00003034,FEBEX_TRACE,/*sfp*/3,/*card*/0);
        }
      }
    }
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(755,FEBEX_NOTRACE,febex[0],/*sfp*/3,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(756,FEBEX_NOTRACE,febex[1],/*sfp*/3,/*card*/1);
        break;
      case 3:
        UNPACK_DECL(757,FEBEX_NOTRACE,febex[2],/*sfp*/3,/*card*/2);
        break;
      case 4:
        UNPACK_DECL(758,FEBEX_NOTRACE,febex[3],/*sfp*/3,/*card*/3);
        break;
      case 5:
        UNPACK_DECL(759,FEBEX_NOTRACE,febex[4],/*sfp*/3,/*card*/4);
        break;
      case 6:
        UNPACK_DECL(760,FEBEX_NOTRACE,febex[5],/*sfp*/3,/*card*/5);
        break;
      case 7:
        UNPACK_DECL(761,FEBEX_NOTRACE,febex[6],/*sfp*/3,/*card*/6);
        break;
      case 8:
        UNPACK_DECL(762,FEBEX_NOTRACE,febex[7],/*sfp*/3,/*card*/7);
        break;
      case 9:
        UNPACK_DECL(763,FEBEX_TRACE,febextrace[0],/*sfp*/3,/*card*/0);
        break;
      case 10:
        UNPACK_DECL(764,FEBEX_TRACE,febextrace[1],/*sfp*/3,/*card*/1);
        break;
      case 11:
        UNPACK_DECL(765,FEBEX_TRACE,febextrace[2],/*sfp*/3,/*card*/2);
        break;
      case 12:
        UNPACK_DECL(766,FEBEX_TRACE,febextrace[3],/*sfp*/3,/*card*/3);
        break;
      case 13:
        UNPACK_DECL(767,FEBEX_TRACE,febextrace[4],/*sfp*/3,/*card*/4);
        break;
      case 14:
        UNPACK_DECL(768,FEBEX_TRACE,febextrace[5],/*sfp*/3,/*card*/5);
        break;
      case 15:
        UNPACK_DECL(769,FEBEX_TRACE,febextrace[6],/*sfp*/3,/*card*/6);
        break;
      case 16:
        UNPACK_DECL(770,FEBEX_TRACE,febextrace[7],/*sfp*/3,/*card*/7);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fitest_febex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for fitest_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fitest_febex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for fitest_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(fitest_febex_subev)
template<typename __data_dest_t>
void PACKER_fitest_febex_subev::__packer(__data_dest_t &__buffer)
{
  // header = FEBEX_EVENTHEADER();
  PACK_DECL(748,FEBEX_EVENTHEADER,header);
  // select several

    // padding = FEBEX_PADDING();
  {
    PACK_DECL(751,FEBEX_PADDING,padding);
  }
  // select several

    // febex[0] = FEBEX_NOTRACE(sfp=3,card=0);
    // febex[1] = FEBEX_NOTRACE(sfp=3,card=1);
    // febex[2] = FEBEX_NOTRACE(sfp=3,card=2);
    // febex[3] = FEBEX_NOTRACE(sfp=3,card=3);
    // febex[4] = FEBEX_NOTRACE(sfp=3,card=4);
    // febex[5] = FEBEX_NOTRACE(sfp=3,card=5);
    // febex[6] = FEBEX_NOTRACE(sfp=3,card=6);
    // febex[7] = FEBEX_NOTRACE(sfp=3,card=7);
    // febextrace[0] = FEBEX_TRACE(sfp=3,card=0);
    // febextrace[1] = FEBEX_TRACE(sfp=3,card=1);
    // febextrace[2] = FEBEX_TRACE(sfp=3,card=2);
    // febextrace[3] = FEBEX_TRACE(sfp=3,card=3);
    // febextrace[4] = FEBEX_TRACE(sfp=3,card=4);
    // febextrace[5] = FEBEX_TRACE(sfp=3,card=5);
    // febextrace[6] = FEBEX_TRACE(sfp=3,card=6);
    // febextrace[7] = FEBEX_TRACE(sfp=3,card=7);
  {
    PACK_DECL(755,FEBEX_NOTRACE,febex[0],/*sfp*/3,/*card*/0);
    PACK_DECL(756,FEBEX_NOTRACE,febex[1],/*sfp*/3,/*card*/1);
    PACK_DECL(757,FEBEX_NOTRACE,febex[2],/*sfp*/3,/*card*/2);
    PACK_DECL(758,FEBEX_NOTRACE,febex[3],/*sfp*/3,/*card*/3);
    PACK_DECL(759,FEBEX_NOTRACE,febex[4],/*sfp*/3,/*card*/4);
    PACK_DECL(760,FEBEX_NOTRACE,febex[5],/*sfp*/3,/*card*/5);
    PACK_DECL(761,FEBEX_NOTRACE,febex[6],/*sfp*/3,/*card*/6);
    PACK_DECL(762,FEBEX_NOTRACE,febex[7],/*sfp*/3,/*card*/7);
    PACK_DECL(763,FEBEX_TRACE,febextrace[0],/*sfp*/3,/*card*/0);
    PACK_DECL(764,FEBEX_TRACE,febextrace[1],/*sfp*/3,/*card*/1);
    PACK_DECL(765,FEBEX_TRACE,febextrace[2],/*sfp*/3,/*card*/2);
    PACK_DECL(766,FEBEX_TRACE,febextrace[3],/*sfp*/3,/*card*/3);
    PACK_DECL(767,FEBEX_TRACE,febextrace[4],/*sfp*/3,/*card*/4);
    PACK_DECL(768,FEBEX_TRACE,febextrace[5],/*sfp*/3,/*card*/5);
    PACK_DECL(769,FEBEX_TRACE,febextrace[6],/*sfp*/3,/*card*/6);
    PACK_DECL(770,FEBEX_TRACE,febextrace[7],/*sfp*/3,/*card*/7);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,fitest_febex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: lmu_scalers_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for lmu_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(lmu_scalers_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_lmu_scalers_subev
class lmu_scalers_subev
#else//PACKER_CODE
# define DECLARED_PACKER_lmu_scalers_subev
class PACKER_lmu_scalers_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // scalers = TRLOII_LMU_SCALERS(id=199);
  SINGLE(TRLOII_LMU_SCALERS,scalers);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(lmu_scalers_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for lmu_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(lmu_scalers_subev)
template<typename __data_src_t>
void lmu_scalers_subev::__unpack(__data_src_t &__buffer)
{
  // scalers = TRLOII_LMU_SCALERS(id=199);
  UNPACK_DECL(776,TRLOII_LMU_SCALERS,scalers,/*id*/199);
}
FORCE_IMPL_DATA_SRC_FCN(void,lmu_scalers_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for lmu_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(lmu_scalers_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for lmu_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(lmu_scalers_subev)
template<typename __data_dest_t>
void PACKER_lmu_scalers_subev::__packer(__data_dest_t &__buffer)
{
  // scalers = TRLOII_LMU_SCALERS(id=199);
  PACK_DECL(776,TRLOII_LMU_SCALERS,scalers,/*id*/199);
}
FORCE_IMPL_DATA_SRC_FCN(void,lmu_scalers_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: los_sampler_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for los_sampler_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_sampler_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_los_sampler_subev
class los_sampler_subev
#else//PACKER_CODE
# define DECLARED_PACKER_los_sampler_subev
class PACKER_los_sampler_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // land_vme = LAND_STD_VME();
  // select several

    // sampler = TRLOII_SAMPLER(mark=0x1050);
  SINGLE(TRLOII_SAMPLER,sampler);
  SINGLE(LAND_STD_VME,land_vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(los_sampler_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for los_sampler_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_sampler_subev)
template<typename __data_src_t>
void los_sampler_subev::__unpack(__data_src_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  UNPACK_DECL(781,LAND_STD_VME,land_vme);
  // select several

    // sampler = TRLOII_SAMPLER(mark=0x1050);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TRLOII_SAMPLER sampler: (s32) => (0xfffff800,0x10500000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(785,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(784,TRLOII_SAMPLER,sampler,/*mark*/0x1050);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,los_sampler_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for los_sampler_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_sampler_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for los_sampler_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_sampler_subev)
template<typename __data_dest_t>
void PACKER_los_sampler_subev::__packer(__data_dest_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  PACK_DECL(781,LAND_STD_VME,land_vme);
  // select several

    // sampler = TRLOII_SAMPLER(mark=0x1050);
  {
    PACK_DECL(784,TRLOII_SAMPLER,sampler,/*mark*/0x1050);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,los_sampler_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: los_scalers_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for los_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_scalers_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_los_scalers_subev
class los_scalers_subev
#else//PACKER_CODE
# define DECLARED_PACKER_los_scalers_subev
class PACKER_los_scalers_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // scaler = SCALER();
  SINGLE(SCALER,scaler);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(los_scalers_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for los_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_scalers_subev)
template<typename __data_src_t>
void los_scalers_subev::__unpack(__data_src_t &__buffer)
{
  // select several

    // scaler = SCALER();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: SCALER scaler: (s32)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(793,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(792,SCALER,scaler);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,los_scalers_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for los_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_scalers_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for los_scalers_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_scalers_subev)
template<typename __data_dest_t>
void PACKER_los_scalers_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // scaler = SCALER();
  {
    PACK_DECL(792,SCALER,scaler);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,los_scalers_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: los_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for los_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_los_subev
class los_subev
#else//PACKER_CODE
# define DECLARED_PACKER_los_subev
class PACKER_los_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // land_vme = LAND_STD_VME();
  // barrier1 = BARRIER();
  // barrier2 = BARRIER();
  // select several

    // vftx2 = VME_GSI_VFTX2_7PS(id=2);
  SINGLE(VME_GSI_VFTX2_7PS,vftx2);
  SINGLE(LAND_STD_VME,land_vme);
  SINGLE(BARRIER,barrier2);
  SINGLE(BARRIER,barrier1);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(los_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for los_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_subev)
template<typename __data_src_t>
void los_subev::__unpack(__data_src_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  UNPACK_DECL(798,LAND_STD_VME,land_vme);
  // barrier1 = BARRIER();
  UNPACK_DECL(799,BARRIER,barrier1);
  // barrier2 = BARRIER();
  UNPACK_DECL(800,BARRIER,barrier2);
  // select several

    // vftx2 = VME_GSI_VFTX2_7PS(id=2);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_GSI_VFTX2_7PS vftx2: (s32) => (0xfffc001f,0xab000002)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(804,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(803,VME_GSI_VFTX2_7PS,vftx2,/*id*/2);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,los_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for los_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for los_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(los_subev)
template<typename __data_dest_t>
void PACKER_los_subev::__packer(__data_dest_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  PACK_DECL(798,LAND_STD_VME,land_vme);
  // barrier1 = BARRIER();
  PACK_DECL(799,BARRIER,barrier1);
  // barrier2 = BARRIER();
  PACK_DECL(800,BARRIER,barrier2);
  // select several

    // vftx2 = VME_GSI_VFTX2_7PS(id=2);
  {
    PACK_DECL(803,VME_GSI_VFTX2_7PS,vftx2,/*id*/2);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,los_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: master_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for master_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(master_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_master_subev
class master_subev
#else//PACKER_CODE
# define DECLARED_PACKER_master_subev
class PACKER_master_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // land_vme = LAND_STD_VME();
  // barrier = BARRIER();
  SINGLE(BARRIER,barrier);
  SINGLE(LAND_STD_VME,land_vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(master_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for master_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(master_subev)
template<typename __data_src_t>
void master_subev::__unpack(__data_src_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  UNPACK_DECL(809,LAND_STD_VME,land_vme);
  // barrier = BARRIER();
  UNPACK_DECL(810,BARRIER,barrier);
}
FORCE_IMPL_DATA_SRC_FCN(void,master_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for master_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(master_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for master_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(master_subev)
template<typename __data_dest_t>
void PACKER_master_subev::__packer(__data_dest_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  PACK_DECL(809,LAND_STD_VME,land_vme);
  // barrier = BARRIER();
  PACK_DECL(810,BARRIER,barrier);
}
FORCE_IMPL_DATA_SRC_FCN(void,master_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: straw_vme_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for straw_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(straw_vme_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_straw_vme_subev
class straw_vme_subev
#else//PACKER_CODE
# define DECLARED_PACKER_straw_vme_subev
class PACKER_straw_vme_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // select several

    // vftx2 = VME_GSI_VFTX2_STRAW(id=0);
  SINGLE(VME_GSI_VFTX2_STRAW,vftx2);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(straw_vme_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for straw_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(straw_vme_subev)
template<typename __data_src_t>
void straw_vme_subev::__unpack(__data_src_t &__buffer)
{
  // select several

    // vftx2 = VME_GSI_VFTX2_STRAW(id=0);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_GSI_VFTX2_STRAW vftx2: (s32) => (0xffffe000,0x00000000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(818,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(817,VME_GSI_VFTX2_STRAW,vftx2,/*id*/0);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,straw_vme_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for straw_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(straw_vme_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for straw_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(straw_vme_subev)
template<typename __data_dest_t>
void PACKER_straw_vme_subev::__packer(__data_dest_t &__buffer)
{
  // select several

    // vftx2 = VME_GSI_VFTX2_STRAW(id=0);
  {
    PACK_DECL(817,VME_GSI_VFTX2_STRAW,vftx2,/*id*/0);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,straw_vme_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: tbm_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for tbm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tbm_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_tbm_subev
class tbm_subev
#else//PACKER_CODE
# define DECLARED_PACKER_tbm_subev
class PACKER_tbm_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // land_vme = LAND_STD_VME();
  SINGLE(LAND_STD_VME,land_vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(tbm_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for tbm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tbm_subev)
template<typename __data_src_t>
void tbm_subev::__unpack(__data_src_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  UNPACK_DECL(823,LAND_STD_VME,land_vme);
}
FORCE_IMPL_DATA_SRC_FCN(void,tbm_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for tbm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tbm_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for tbm_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tbm_subev)
template<typename __data_dest_t>
void PACKER_tbm_subev::__packer(__data_dest_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  PACK_DECL(823,LAND_STD_VME,land_vme);
}
FORCE_IMPL_DATA_SRC_FCN(void,tbm_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: tofd_tamex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for tofd_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_tamex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_tofd_tamex_subev
class tofd_tamex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_tofd_tamex_subev
class PACKER_tofd_tamex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // header = TAMEX3_HEADER();
  // select several

    // padding1 = TAMEX3_PADDING();
  SINGLE(TAMEX3_PADDING,padding1);
  // select several

    // tamex_1 = TAMEX3_SFP(sfp=2,card=0);
    // tamex_2 = TAMEX3_SFP(sfp=2,card=1);
  SINGLE(TAMEX3_SFP,tamex_1);
  SINGLE(TAMEX3_SFP,tamex_2);
  // select several

    // padding2 = TAMEX3_PADDING();
  SINGLE(TAMEX3_PADDING,padding2);
  // select several

    // tamex_3 = TAMEX3_SFP(sfp=3,card=0);
    // tamex_4 = TAMEX3_SFP(sfp=3,card=1);
  SINGLE(TAMEX3_SFP,tamex_3);
  SINGLE(TAMEX3_SFP,tamex_4);
  SINGLE(TAMEX3_HEADER,header);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(tofd_tamex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for tofd_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_tamex_subev)
template<typename __data_src_t>
void tofd_tamex_subev::__unpack(__data_src_t &__buffer)
{
  // header = TAMEX3_HEADER();
  UNPACK_DECL(828,TAMEX3_HEADER,header);
  // select several

    // padding1 = TAMEX3_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX3_PADDING padding1: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(832,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(831,spurious_match_abort_loop_2,TAMEX3_PADDING);
        UNPACK_DECL(831,TAMEX3_PADDING,padding1);
        break;
    }
  }
  spurious_match_abort_loop_2:;
  // select several

    // tamex_1 = TAMEX3_SFP(sfp=2,card=0);
    // tamex_2 = TAMEX3_SFP(sfp=2,card=1);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX3_SFP tamex_1: (s32) => (0xfffff0ff,0x00002034)
    // optimized match 2: TAMEX3_SFP tamex_2: (s32) => (0xfffff0ff,0x00012034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(837,uint32,__match_peek);
    // differ = 00010000 : 16
    uint32 __match_index = 0 | /* 16,16 */ ((__match_peek >> 16) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(835,spurious_match_abort_loop_3,TAMEX3_SFP,/*sfp*/2,/*card*/0);
        UNPACK_DECL(835,TAMEX3_SFP,tamex_1,/*sfp*/2,/*card*/0);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(836,spurious_match_abort_loop_3,TAMEX3_SFP,/*sfp*/2,/*card*/1);
        UNPACK_DECL(836,TAMEX3_SFP,tamex_2,/*sfp*/2,/*card*/1);
        break;
    }
  }
  spurious_match_abort_loop_3:;
  // select several

    // padding2 = TAMEX3_PADDING();
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX3_PADDING padding2: (s32) => (0xfff00000,0xadd00000)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(841,uint32,__match_peek);
    // differ = 00000000 :
    uint32 __match_index = 0;
    static const sint8 __match_index_array[1] = { 1, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(840,spurious_match_abort_loop_4,TAMEX3_PADDING);
        UNPACK_DECL(840,TAMEX3_PADDING,padding2);
        break;
    }
  }
  spurious_match_abort_loop_4:;
  // select several

    // tamex_3 = TAMEX3_SFP(sfp=3,card=0);
    // tamex_4 = TAMEX3_SFP(sfp=3,card=1);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: TAMEX3_SFP tamex_3: (s32) => (0xfffff0ff,0x00003034)
    // optimized match 2: TAMEX3_SFP tamex_4: (s32) => (0xfffff0ff,0x00013034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(846,uint32,__match_peek);
    // differ = 00010000 : 16
    uint32 __match_index = 0 | /* 16,16 */ ((__match_peek >> 16) & 0x00000001);
    static const sint8 __match_index_array[2] = { 1, 2, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(844,TAMEX3_SFP,tamex_3,/*sfp*/3,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(845,TAMEX3_SFP,tamex_4,/*sfp*/3,/*card*/1);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,tofd_tamex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for tofd_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_tamex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for tofd_tamex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_tamex_subev)
template<typename __data_dest_t>
void PACKER_tofd_tamex_subev::__packer(__data_dest_t &__buffer)
{
  // header = TAMEX3_HEADER();
  PACK_DECL(828,TAMEX3_HEADER,header);
  // select several

    // padding1 = TAMEX3_PADDING();
  {
    PACK_DECL(831,TAMEX3_PADDING,padding1);
  }
  // select several

    // tamex_1 = TAMEX3_SFP(sfp=2,card=0);
    // tamex_2 = TAMEX3_SFP(sfp=2,card=1);
  {
    PACK_DECL(835,TAMEX3_SFP,tamex_1,/*sfp*/2,/*card*/0);
    PACK_DECL(836,TAMEX3_SFP,tamex_2,/*sfp*/2,/*card*/1);
  }
  // select several

    // padding2 = TAMEX3_PADDING();
  {
    PACK_DECL(840,TAMEX3_PADDING,padding2);
  }
  // select several

    // tamex_3 = TAMEX3_SFP(sfp=3,card=0);
    // tamex_4 = TAMEX3_SFP(sfp=3,card=1);
  {
    PACK_DECL(844,TAMEX3_SFP,tamex_3,/*sfp*/3,/*card*/0);
    PACK_DECL(845,TAMEX3_SFP,tamex_4,/*sfp*/3,/*card*/1);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,tofd_tamex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: tofd_vme_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for tofd_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_vme_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_tofd_vme_subev
class tofd_vme_subev
#else//PACKER_CODE
# define DECLARED_PACKER_tofd_vme_subev
class PACKER_tofd_vme_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // land_vme = LAND_STD_VME();
  // barrier = BARRIER();
  // select several

    // vftx2_1 = VME_GSI_VFTX2_7PS(id=1);
    // vftx2_2 = VME_GSI_VFTX2_7PS(id=2);
    // vftx2_3 = VME_GSI_VFTX2_7PS(id=3);
  SINGLE(VME_GSI_VFTX2_7PS,vftx2_1);
  SINGLE(VME_GSI_VFTX2_7PS,vftx2_3);
  SINGLE(VME_GSI_VFTX2_7PS,vftx2_2);
  SINGLE(BARRIER,barrier);
  SINGLE(LAND_STD_VME,land_vme);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(tofd_vme_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for tofd_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_vme_subev)
template<typename __data_src_t>
void tofd_vme_subev::__unpack(__data_src_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  UNPACK_DECL(851,LAND_STD_VME,land_vme);
  // barrier = BARRIER();
  UNPACK_DECL(852,BARRIER,barrier);
  // select several

    // vftx2_1 = VME_GSI_VFTX2_7PS(id=1);
    // vftx2_2 = VME_GSI_VFTX2_7PS(id=2);
    // vftx2_3 = VME_GSI_VFTX2_7PS(id=3);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: VME_GSI_VFTX2_7PS vftx2_1: (s32) => (0xfffc001f,0xab000001)
    // optimized match 2: VME_GSI_VFTX2_7PS vftx2_2: (s32) => (0xfffc001f,0xab000002)
    // optimized match 3: VME_GSI_VFTX2_7PS vftx2_3: (s32) => (0xfffc001f,0xab000003)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(858,uint32,__match_peek);
    // differ = 00000003 : 0 1
    uint32 __match_index = 0 | /* 0,1 */ ((__match_peek >> 0) & 0x00000003);
    static const sint8 __match_index_array[4] = { 0, 1, 2, 3, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(855,VME_GSI_VFTX2_7PS,vftx2_1,/*id*/1);
        break;
      case 2:
        UNPACK_DECL(856,VME_GSI_VFTX2_7PS,vftx2_2,/*id*/2);
        break;
      case 3:
        UNPACK_DECL(857,VME_GSI_VFTX2_7PS,vftx2_3,/*id*/3);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,tofd_vme_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for tofd_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_vme_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for tofd_vme_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tofd_vme_subev)
template<typename __data_dest_t>
void PACKER_tofd_vme_subev::__packer(__data_dest_t &__buffer)
{
  // land_vme = LAND_STD_VME();
  PACK_DECL(851,LAND_STD_VME,land_vme);
  // barrier = BARRIER();
  PACK_DECL(852,BARRIER,barrier);
  // select several

    // vftx2_1 = VME_GSI_VFTX2_7PS(id=1);
    // vftx2_2 = VME_GSI_VFTX2_7PS(id=2);
    // vftx2_3 = VME_GSI_VFTX2_7PS(id=3);
  {
    PACK_DECL(855,VME_GSI_VFTX2_7PS,vftx2_1,/*id*/1);
    PACK_DECL(856,VME_GSI_VFTX2_7PS,vftx2_2,/*id*/2);
    PACK_DECL(857,VME_GSI_VFTX2_7PS,vftx2_3,/*id*/3);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,tofd_vme_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: tpat_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tpat_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_tpat_subev
class tpat_subev
#else//PACKER_CODE
# define DECLARED_PACKER_tpat_subev
class PACKER_tpat_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // tpat = TRLOII_TPAT(id=207);
  SINGLE(TRLOII_TPAT,tpat);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(tpat_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tpat_subev)
template<typename __data_src_t>
void tpat_subev::__unpack(__data_src_t &__buffer)
{
  // tpat = TRLOII_TPAT(id=207);
  UNPACK_DECL(863,TRLOII_TPAT,tpat,/*id*/207);
}
FORCE_IMPL_DATA_SRC_FCN(void,tpat_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tpat_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for tpat_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tpat_subev)
template<typename __data_dest_t>
void PACKER_tpat_subev::__packer(__data_dest_t &__buffer)
{
  // tpat = TRLOII_TPAT(id=207);
  PACK_DECL(863,TRLOII_TPAT,tpat,/*id*/207);
}
FORCE_IMPL_DATA_SRC_FCN(void,tpat_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: tracking_febex_subev
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for tracking_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tracking_febex_subev)
#if !PACKER_CODE
# define DECLARED_UNPACK_tracking_febex_subev
class tracking_febex_subev
#else//PACKER_CODE
# define DECLARED_PACKER_tracking_febex_subev
class PACKER_tracking_febex_subev
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // header0 = FEBEX_EVENTHEADER();
  // select several

    // febex_0[0] = FEBEX_NOTRACE(sfp=0,card=0);
    // febex_0[1] = FEBEX_NOTRACE(sfp=0,card=1);
    // febex_0[2] = FEBEX_NOTRACE(sfp=0,card=2);
    // febex_0[3] = FEBEX_NOTRACE(sfp=0,card=3);
    // febex_0[4] = FEBEX_NOTRACE(sfp=0,card=4);
    // febex_0[5] = FEBEX_NOTRACE(sfp=0,card=5);
    // febex_0[6] = FEBEX_NOTRACE(sfp=0,card=6);
    // febex_0[7] = FEBEX_NOTRACE(sfp=0,card=7);
    // febex_0[8] = FEBEX_NOTRACE(sfp=0,card=8);
    // febex_0[9] = FEBEX_NOTRACE(sfp=0,card=9);
  SINGLE(FEBEX_NOTRACE,febex_0[10]);
  // header2 = FEBEX_EVENTHEADER();
  // select several

    // febex_2[0] = FEBEX_NOTRACE(sfp=2,card=0);
    // febex_2[1] = FEBEX_NOTRACE(sfp=2,card=1);
    // febex_2[2] = FEBEX_NOTRACE(sfp=2,card=2);
    // febex_2[3] = FEBEX_NOTRACE(sfp=2,card=3);
    // febex_2[4] = FEBEX_NOTRACE(sfp=2,card=4);
    // febex_2[5] = FEBEX_NOTRACE(sfp=2,card=5);
    // febex_2[6] = FEBEX_NOTRACE(sfp=2,card=6);
    // febex_2[7] = FEBEX_NOTRACE(sfp=2,card=7);
    // febex_2[8] = FEBEX_NOTRACE(sfp=2,card=8);
    // febex_2[9] = FEBEX_NOTRACE(sfp=2,card=9);
    // febex_2[10] = FEBEX_NOTRACE(sfp=2,card=10);
    // febex_2[11] = FEBEX_NOTRACE(sfp=2,card=11);
  SINGLE(FEBEX_NOTRACE,febex_2[12]);
  SINGLE(FEBEX_EVENTHEADER,header0);
  SINGLE(FEBEX_EVENTHEADER,header2);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(tracking_febex_subev);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for tracking_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tracking_febex_subev)
template<typename __data_src_t>
void tracking_febex_subev::__unpack(__data_src_t &__buffer)
{
  // header0 = FEBEX_EVENTHEADER();
  UNPACK_DECL(868,FEBEX_EVENTHEADER,header0);
  // select several

    // febex_0[0] = FEBEX_NOTRACE(sfp=0,card=0);
    // febex_0[1] = FEBEX_NOTRACE(sfp=0,card=1);
    // febex_0[2] = FEBEX_NOTRACE(sfp=0,card=2);
    // febex_0[3] = FEBEX_NOTRACE(sfp=0,card=3);
    // febex_0[4] = FEBEX_NOTRACE(sfp=0,card=4);
    // febex_0[5] = FEBEX_NOTRACE(sfp=0,card=5);
    // febex_0[6] = FEBEX_NOTRACE(sfp=0,card=6);
    // febex_0[7] = FEBEX_NOTRACE(sfp=0,card=7);
    // febex_0[8] = FEBEX_NOTRACE(sfp=0,card=8);
    // febex_0[9] = FEBEX_NOTRACE(sfp=0,card=9);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_NOTRACE febex_0[0]: (s32) => (0xfffff0ff,0xff000034)
    // optimized match 2: FEBEX_NOTRACE febex_0[1]: (s32) => (0xfffff0ff,0xff010034)
    // optimized match 3: FEBEX_NOTRACE febex_0[2]: (s32) => (0xfffff0ff,0xff020034)
    // optimized match 4: FEBEX_NOTRACE febex_0[3]: (s32) => (0xfffff0ff,0xff030034)
    // optimized match 5: FEBEX_NOTRACE febex_0[4]: (s32) => (0xfffff0ff,0xff040034)
    // optimized match 6: FEBEX_NOTRACE febex_0[5]: (s32) => (0xfffff0ff,0xff050034)
    // optimized match 7: FEBEX_NOTRACE febex_0[6]: (s32) => (0xfffff0ff,0xff060034)
    // optimized match 8: FEBEX_NOTRACE febex_0[7]: (s32) => (0xfffff0ff,0xff070034)
    // optimized match 9: FEBEX_NOTRACE febex_0[8]: (s32) => (0xfffff0ff,0xff080034)
    // optimized match 10: FEBEX_NOTRACE febex_0[9]: (s32) => (0xfffff0ff,0xff090034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(881,uint32,__match_peek);
    // differ = 000f0000 : 16 17 18 19
    uint32 __match_index = 0 | /* 16,19 */ ((__match_peek >> 16) & 0x0000000f);
    static const sint8 __match_index_array[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 0, 0, 0, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 0
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        CHECK_SPURIOUS_MATCH_DECL(871,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/0);
        UNPACK_DECL(871,FEBEX_NOTRACE,febex_0[0],/*sfp*/0,/*card*/0);
        break;
      case 2:
        CHECK_SPURIOUS_MATCH_DECL(872,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/1);
        UNPACK_DECL(872,FEBEX_NOTRACE,febex_0[1],/*sfp*/0,/*card*/1);
        break;
      case 3:
        CHECK_SPURIOUS_MATCH_DECL(873,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/2);
        UNPACK_DECL(873,FEBEX_NOTRACE,febex_0[2],/*sfp*/0,/*card*/2);
        break;
      case 4:
        CHECK_SPURIOUS_MATCH_DECL(874,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/3);
        UNPACK_DECL(874,FEBEX_NOTRACE,febex_0[3],/*sfp*/0,/*card*/3);
        break;
      case 5:
        CHECK_SPURIOUS_MATCH_DECL(875,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/4);
        UNPACK_DECL(875,FEBEX_NOTRACE,febex_0[4],/*sfp*/0,/*card*/4);
        break;
      case 6:
        CHECK_SPURIOUS_MATCH_DECL(876,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/5);
        UNPACK_DECL(876,FEBEX_NOTRACE,febex_0[5],/*sfp*/0,/*card*/5);
        break;
      case 7:
        CHECK_SPURIOUS_MATCH_DECL(877,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/6);
        UNPACK_DECL(877,FEBEX_NOTRACE,febex_0[6],/*sfp*/0,/*card*/6);
        break;
      case 8:
        CHECK_SPURIOUS_MATCH_DECL(878,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/7);
        UNPACK_DECL(878,FEBEX_NOTRACE,febex_0[7],/*sfp*/0,/*card*/7);
        break;
      case 9:
        CHECK_SPURIOUS_MATCH_DECL(879,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/8);
        UNPACK_DECL(879,FEBEX_NOTRACE,febex_0[8],/*sfp*/0,/*card*/8);
        break;
      case 10:
        CHECK_SPURIOUS_MATCH_DECL(880,spurious_match_abort_loop_5,FEBEX_NOTRACE,/*sfp*/0,/*card*/9);
        UNPACK_DECL(880,FEBEX_NOTRACE,febex_0[9],/*sfp*/0,/*card*/9);
        break;
    }
  }
  spurious_match_abort_loop_5:;
  // header2 = FEBEX_EVENTHEADER();
  UNPACK_DECL(882,FEBEX_EVENTHEADER,header2);
  // select several

    // febex_2[0] = FEBEX_NOTRACE(sfp=2,card=0);
    // febex_2[1] = FEBEX_NOTRACE(sfp=2,card=1);
    // febex_2[2] = FEBEX_NOTRACE(sfp=2,card=2);
    // febex_2[3] = FEBEX_NOTRACE(sfp=2,card=3);
    // febex_2[4] = FEBEX_NOTRACE(sfp=2,card=4);
    // febex_2[5] = FEBEX_NOTRACE(sfp=2,card=5);
    // febex_2[6] = FEBEX_NOTRACE(sfp=2,card=6);
    // febex_2[7] = FEBEX_NOTRACE(sfp=2,card=7);
    // febex_2[8] = FEBEX_NOTRACE(sfp=2,card=8);
    // febex_2[9] = FEBEX_NOTRACE(sfp=2,card=9);
    // febex_2[10] = FEBEX_NOTRACE(sfp=2,card=10);
    // febex_2[11] = FEBEX_NOTRACE(sfp=2,card=11);
  for ( ; ; )
  {
    if (__buffer.empty()) break;
    int __match_no = 0;
    // optimized match 1: FEBEX_NOTRACE febex_2[0]: (s32) => (0xfffff0ff,0xff002034)
    // optimized match 2: FEBEX_NOTRACE febex_2[1]: (s32) => (0xfffff0ff,0xff012034)
    // optimized match 3: FEBEX_NOTRACE febex_2[2]: (s32) => (0xfffff0ff,0xff022034)
    // optimized match 4: FEBEX_NOTRACE febex_2[3]: (s32) => (0xfffff0ff,0xff032034)
    // optimized match 5: FEBEX_NOTRACE febex_2[4]: (s32) => (0xfffff0ff,0xff042034)
    // optimized match 6: FEBEX_NOTRACE febex_2[5]: (s32) => (0xfffff0ff,0xff052034)
    // optimized match 7: FEBEX_NOTRACE febex_2[6]: (s32) => (0xfffff0ff,0xff062034)
    // optimized match 8: FEBEX_NOTRACE febex_2[7]: (s32) => (0xfffff0ff,0xff072034)
    // optimized match 9: FEBEX_NOTRACE febex_2[8]: (s32) => (0xfffff0ff,0xff082034)
    // optimized match 10: FEBEX_NOTRACE febex_2[9]: (s32) => (0xfffff0ff,0xff092034)
    // optimized match 11: FEBEX_NOTRACE febex_2[10]: (s32) => (0xfffff0ff,0xff0a2034)
    // optimized match 12: FEBEX_NOTRACE febex_2[11]: (s32) => (0xfffff0ff,0xff0b2034)
    {
    uint32 __match_peek;
    PEEK_FROM_BUFFER(897,uint32,__match_peek);
    // differ = 000f0000 : 16 17 18 19
    uint32 __match_index = 0 | /* 16,19 */ ((__match_peek >> 16) & 0x0000000f);
    static const sint8 __match_index_array[16] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 0, 0, 0, 0, };
    __match_no = __match_index_array[__match_index];
    // last_subevent_item = 1
    }
    if (!__match_no) break;
    switch (__match_no)
    {
      case 1:
        UNPACK_DECL(885,FEBEX_NOTRACE,febex_2[0],/*sfp*/2,/*card*/0);
        break;
      case 2:
        UNPACK_DECL(886,FEBEX_NOTRACE,febex_2[1],/*sfp*/2,/*card*/1);
        break;
      case 3:
        UNPACK_DECL(887,FEBEX_NOTRACE,febex_2[2],/*sfp*/2,/*card*/2);
        break;
      case 4:
        UNPACK_DECL(888,FEBEX_NOTRACE,febex_2[3],/*sfp*/2,/*card*/3);
        break;
      case 5:
        UNPACK_DECL(889,FEBEX_NOTRACE,febex_2[4],/*sfp*/2,/*card*/4);
        break;
      case 6:
        UNPACK_DECL(890,FEBEX_NOTRACE,febex_2[5],/*sfp*/2,/*card*/5);
        break;
      case 7:
        UNPACK_DECL(891,FEBEX_NOTRACE,febex_2[6],/*sfp*/2,/*card*/6);
        break;
      case 8:
        UNPACK_DECL(892,FEBEX_NOTRACE,febex_2[7],/*sfp*/2,/*card*/7);
        break;
      case 9:
        UNPACK_DECL(893,FEBEX_NOTRACE,febex_2[8],/*sfp*/2,/*card*/8);
        break;
      case 10:
        UNPACK_DECL(894,FEBEX_NOTRACE,febex_2[9],/*sfp*/2,/*card*/9);
        break;
      case 11:
        UNPACK_DECL(895,FEBEX_NOTRACE,febex_2[10],/*sfp*/2,/*card*/10);
        break;
      case 12:
        UNPACK_DECL(896,FEBEX_NOTRACE,febex_2[11],/*sfp*/2,/*card*/11);
        break;
    }
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,tracking_febex_subev::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for tracking_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tracking_febex_subev)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for tracking_febex_subev.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(tracking_febex_subev)
template<typename __data_dest_t>
void PACKER_tracking_febex_subev::__packer(__data_dest_t &__buffer)
{
  // header0 = FEBEX_EVENTHEADER();
  PACK_DECL(868,FEBEX_EVENTHEADER,header0);
  // select several

    // febex_0[0] = FEBEX_NOTRACE(sfp=0,card=0);
    // febex_0[1] = FEBEX_NOTRACE(sfp=0,card=1);
    // febex_0[2] = FEBEX_NOTRACE(sfp=0,card=2);
    // febex_0[3] = FEBEX_NOTRACE(sfp=0,card=3);
    // febex_0[4] = FEBEX_NOTRACE(sfp=0,card=4);
    // febex_0[5] = FEBEX_NOTRACE(sfp=0,card=5);
    // febex_0[6] = FEBEX_NOTRACE(sfp=0,card=6);
    // febex_0[7] = FEBEX_NOTRACE(sfp=0,card=7);
    // febex_0[8] = FEBEX_NOTRACE(sfp=0,card=8);
    // febex_0[9] = FEBEX_NOTRACE(sfp=0,card=9);
  {
    PACK_DECL(871,FEBEX_NOTRACE,febex_0[0],/*sfp*/0,/*card*/0);
    PACK_DECL(872,FEBEX_NOTRACE,febex_0[1],/*sfp*/0,/*card*/1);
    PACK_DECL(873,FEBEX_NOTRACE,febex_0[2],/*sfp*/0,/*card*/2);
    PACK_DECL(874,FEBEX_NOTRACE,febex_0[3],/*sfp*/0,/*card*/3);
    PACK_DECL(875,FEBEX_NOTRACE,febex_0[4],/*sfp*/0,/*card*/4);
    PACK_DECL(876,FEBEX_NOTRACE,febex_0[5],/*sfp*/0,/*card*/5);
    PACK_DECL(877,FEBEX_NOTRACE,febex_0[6],/*sfp*/0,/*card*/6);
    PACK_DECL(878,FEBEX_NOTRACE,febex_0[7],/*sfp*/0,/*card*/7);
    PACK_DECL(879,FEBEX_NOTRACE,febex_0[8],/*sfp*/0,/*card*/8);
    PACK_DECL(880,FEBEX_NOTRACE,febex_0[9],/*sfp*/0,/*card*/9);
  }
  // header2 = FEBEX_EVENTHEADER();
  PACK_DECL(882,FEBEX_EVENTHEADER,header2);
  // select several

    // febex_2[0] = FEBEX_NOTRACE(sfp=2,card=0);
    // febex_2[1] = FEBEX_NOTRACE(sfp=2,card=1);
    // febex_2[2] = FEBEX_NOTRACE(sfp=2,card=2);
    // febex_2[3] = FEBEX_NOTRACE(sfp=2,card=3);
    // febex_2[4] = FEBEX_NOTRACE(sfp=2,card=4);
    // febex_2[5] = FEBEX_NOTRACE(sfp=2,card=5);
    // febex_2[6] = FEBEX_NOTRACE(sfp=2,card=6);
    // febex_2[7] = FEBEX_NOTRACE(sfp=2,card=7);
    // febex_2[8] = FEBEX_NOTRACE(sfp=2,card=8);
    // febex_2[9] = FEBEX_NOTRACE(sfp=2,card=9);
    // febex_2[10] = FEBEX_NOTRACE(sfp=2,card=10);
    // febex_2[11] = FEBEX_NOTRACE(sfp=2,card=11);
  {
    PACK_DECL(885,FEBEX_NOTRACE,febex_2[0],/*sfp*/2,/*card*/0);
    PACK_DECL(886,FEBEX_NOTRACE,febex_2[1],/*sfp*/2,/*card*/1);
    PACK_DECL(887,FEBEX_NOTRACE,febex_2[2],/*sfp*/2,/*card*/2);
    PACK_DECL(888,FEBEX_NOTRACE,febex_2[3],/*sfp*/2,/*card*/3);
    PACK_DECL(889,FEBEX_NOTRACE,febex_2[4],/*sfp*/2,/*card*/4);
    PACK_DECL(890,FEBEX_NOTRACE,febex_2[5],/*sfp*/2,/*card*/5);
    PACK_DECL(891,FEBEX_NOTRACE,febex_2[6],/*sfp*/2,/*card*/6);
    PACK_DECL(892,FEBEX_NOTRACE,febex_2[7],/*sfp*/2,/*card*/7);
    PACK_DECL(893,FEBEX_NOTRACE,febex_2[8],/*sfp*/2,/*card*/8);
    PACK_DECL(894,FEBEX_NOTRACE,febex_2[9],/*sfp*/2,/*card*/9);
    PACK_DECL(895,FEBEX_NOTRACE,febex_2[10],/*sfp*/2,/*card*/10);
    PACK_DECL(896,FEBEX_NOTRACE,febex_2[11],/*sfp*/2,/*card*/11);
  }
}
FORCE_IMPL_DATA_SRC_FCN(void,tracking_febex_subev::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: wr_100
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for wr_100.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_100)
#if !PACKER_CODE
# define DECLARED_UNPACK_wr_100
class wr_100
#else//PACKER_CODE
# define DECLARED_PACKER_wr_100
class PACKER_wr_100
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts100 = TIMESTAMP_WHITERABBIT(id=0x100);
  // multi_ = WR_MULTI();
  SINGLE(TIMESTAMP_WHITERABBIT,ts100);
  SINGLE(WR_MULTI,multi_);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(wr_100);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for wr_100.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_100)
template<typename __data_src_t>
void wr_100::__unpack(__data_src_t &__buffer)
{
  // ts100 = TIMESTAMP_WHITERABBIT(id=0x100);
  UNPACK_DECL(902,TIMESTAMP_WHITERABBIT,ts100,/*id*/0x100);
  // multi_ = WR_MULTI();
  UNPACK_DECL(903,WR_MULTI,multi_);
}
FORCE_IMPL_DATA_SRC_FCN(void,wr_100::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for wr_100.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_100)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for wr_100.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_100)
template<typename __data_dest_t>
void PACKER_wr_100::__packer(__data_dest_t &__buffer)
{
  // ts100 = TIMESTAMP_WHITERABBIT(id=0x100);
  PACK_DECL(902,TIMESTAMP_WHITERABBIT,ts100,/*id*/0x100);
  // multi_ = WR_MULTI();
  PACK_DECL(903,WR_MULTI,multi_);
}
FORCE_IMPL_DATA_SRC_FCN(void,wr_100::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: wr_200
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for wr_200.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_200)
#if !PACKER_CODE
# define DECLARED_UNPACK_wr_200
class wr_200
#else//PACKER_CODE
# define DECLARED_PACKER_wr_200
class PACKER_wr_200
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts200 = TIMESTAMP_WHITERABBIT(id=0x200);
  // multi_ = WR_MULTI();
  SINGLE(WR_MULTI,multi_);
  SINGLE(TIMESTAMP_WHITERABBIT,ts200);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(wr_200);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for wr_200.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_200)
template<typename __data_src_t>
void wr_200::__unpack(__data_src_t &__buffer)
{
  // ts200 = TIMESTAMP_WHITERABBIT(id=0x200);
  UNPACK_DECL(908,TIMESTAMP_WHITERABBIT,ts200,/*id*/0x200);
  // multi_ = WR_MULTI();
  UNPACK_DECL(909,WR_MULTI,multi_);
}
FORCE_IMPL_DATA_SRC_FCN(void,wr_200::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for wr_200.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_200)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for wr_200.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_200)
template<typename __data_dest_t>
void PACKER_wr_200::__packer(__data_dest_t &__buffer)
{
  // ts200 = TIMESTAMP_WHITERABBIT(id=0x200);
  PACK_DECL(908,TIMESTAMP_WHITERABBIT,ts200,/*id*/0x200);
  // multi_ = WR_MULTI();
  PACK_DECL(909,WR_MULTI,multi_);
}
FORCE_IMPL_DATA_SRC_FCN(void,wr_200::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for: wr_400
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for wr_400.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_400)
#if !PACKER_CODE
# define DECLARED_UNPACK_wr_400
class wr_400
#else//PACKER_CODE
# define DECLARED_PACKER_wr_400
class PACKER_wr_400
#endif//PACKER_CODE
 : public unpack_subevent_base
{
public:
  // ts400 = TIMESTAMP_WHITERABBIT(id=0x400);
  SINGLE(TIMESTAMP_WHITERABBIT,ts400);

public:
#ifndef __PSDC__
# if !PACKER_CODE
template<typename __data_src_t>
  void __unpack(__data_src_t &__buffer);
template<typename __data_src_t>
  static bool __match(__data_src_t &__buffer);
  // void __clean();
# else//PACKER_CODE
template<typename __data_dest_t>
  void __packer(__data_dest_t &__buffer);
# endif//PACKER_CODE

  STRUCT_FCNS_DECL(wr_400);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for wr_400.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_400)
template<typename __data_src_t>
void wr_400::__unpack(__data_src_t &__buffer)
{
  // ts400 = TIMESTAMP_WHITERABBIT(id=0x400);
  UNPACK_DECL(914,TIMESTAMP_WHITERABBIT,ts400,/*id*/0x400);
}
FORCE_IMPL_DATA_SRC_FCN(void,wr_400::__unpack);

/** END_UNPACKER ******************************************************/


/** BEGIN_MATCHER ******************************************************
 *
 * Event matcher for wr_400.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_400)
// No __match function for subevents.

/** END_MATCHER *******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for wr_400.
 *
 * Do not edit - automatically generated.
 */

// SUBEVENT(wr_400)
template<typename __data_dest_t>
void PACKER_wr_400::__packer(__data_dest_t &__buffer)
{
  // ts400 = TIMESTAMP_WHITERABBIT(id=0x400);
  PACK_DECL(914,TIMESTAMP_WHITERABBIT,ts400,/*id*/0x400);
}
FORCE_IMPL_DATA_SRC_FCN(void,wr_400::__packer);

/** END_PACKER ********************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
class unpack_event : public unpack_event_base
{
public:
  // master_ts = wr_100(type=10,subtype=1,control=0);
  // master_tpat = tpat_subev(type=36,subtype=0xe10,control=0);
  // master_lmu_scalers = lmu_scalers_subev(type=37,subtype=0xe74,control=0);
  // master_vme = master_subev(type=88,subtype=0x2260,control=0);
  // los = los_subev(type=88,subtype=0x2260,control=1);
  // los_scalers = los_scalers_subev(type=38,subtype=0xed8,control=1);
  // los_sampler = los_sampler_subev(type=39,subtype=0xf3c,control=1);
  // tofd_vme = tofd_vme_subev(type=88,subtype=0x2260,control=2);
  // tbm_ts = wr_200(type=10,subtype=1,control=3);
  // tbm_tpat = tpat_subev(type=36,subtype=0xe10,control=3);
  // tbm_vme = tbm_subev(type=88,subtype=0x2260,control=3);
  // tofd_tamex = tofd_tamex_subev(type=102,subtype=0x27d8,control=4);
  // tracking_febex = tracking_febex_subev(type=100,subtype=0x2710,control=5);
  // los_empty = empty_subev(type=10,subtype=1,control=1);
  // tofd_empty = empty_subev(type=10,subtype=1,control=2);
SINGLE(wr_100,master_ts);
SINGLE(lmu_scalers_subev,master_lmu_scalers);
SINGLE(tpat_subev,master_tpat);
SINGLE(master_subev,master_vme);
SINGLE(los_subev,los);
SINGLE(los_scalers_subev,los_scalers);
SINGLE(los_sampler_subev,los_sampler);
SINGLE(tofd_vme_subev,tofd_vme);
SINGLE(wr_200,tbm_ts);
SINGLE(tpat_subev,tbm_tpat);
SINGLE(tbm_subev,tbm_vme);
SINGLE(tofd_tamex_subev,tofd_tamex);
SINGLE(tracking_febex_subev,tracking_febex);
SINGLE(empty_subev,los_empty);
SINGLE(empty_subev,tofd_empty);
public:
#ifndef __PSDC__
  bitsone<15> __visited;
  void __clear_visited() { __visited.clear(); }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
template<typename __data_src_t>
int unpack_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
  // master_ts = wr_100(type=10,subtype=1,control=0);
  // master_tpat = tpat_subev(type=36,subtype=0xe10,control=0);
  // master_lmu_scalers = lmu_scalers_subev(type=37,subtype=0xe74,control=0);
  // master_vme = master_subev(type=88,subtype=0x2260,control=0);
  // los = los_subev(type=88,subtype=0x2260,control=1);
  // los_scalers = los_scalers_subev(type=38,subtype=0xed8,control=1);
  // los_sampler = los_sampler_subev(type=39,subtype=0xf3c,control=1);
  // tofd_vme = tofd_vme_subev(type=88,subtype=0x2260,control=2);
  // tbm_ts = wr_200(type=10,subtype=1,control=3);
  // tbm_tpat = tpat_subev(type=36,subtype=0xe10,control=3);
  // tbm_vme = tbm_subev(type=88,subtype=0x2260,control=3);
  // tofd_tamex = tofd_tamex_subev(type=102,subtype=0x27d8,control=4);
  // tracking_febex = tracking_febex_subev(type=100,subtype=0x2710,control=5);
  // los_empty = empty_subev(type=10,subtype=1,control=1);
  // tofd_empty = empty_subev(type=10,subtype=1,control=2);
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(923,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==0)),master_ts);
  MATCH_SUBEVENT_DECL(924,__match_no,2,((VES10_1_type==36)&&(VES10_1_subtype==0xe10)&&(VES10_1_control==0)),master_tpat);
  MATCH_SUBEVENT_DECL(925,__match_no,3,((VES10_1_type==37)&&(VES10_1_subtype==0xe74)&&(VES10_1_control==0)),master_lmu_scalers);
  MATCH_SUBEVENT_DECL(926,__match_no,4,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==0)),master_vme);
  MATCH_SUBEVENT_DECL(927,__match_no,5,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==1)),los);
  MATCH_SUBEVENT_DECL(928,__match_no,6,((VES10_1_type==38)&&(VES10_1_subtype==0xed8)&&(VES10_1_control==1)),los_scalers);
  MATCH_SUBEVENT_DECL(929,__match_no,7,((VES10_1_type==39)&&(VES10_1_subtype==0xf3c)&&(VES10_1_control==1)),los_sampler);
  MATCH_SUBEVENT_DECL(930,__match_no,8,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==2)),tofd_vme);
  MATCH_SUBEVENT_DECL(931,__match_no,9,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==3)),tbm_ts);
  MATCH_SUBEVENT_DECL(932,__match_no,10,((VES10_1_type==36)&&(VES10_1_subtype==0xe10)&&(VES10_1_control==3)),tbm_tpat);
  MATCH_SUBEVENT_DECL(933,__match_no,11,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==3)),tbm_vme);
  MATCH_SUBEVENT_DECL(934,__match_no,12,((VES10_1_type==102)&&(VES10_1_subtype==0x27d8)&&(VES10_1_control==4)),tofd_tamex);
  MATCH_SUBEVENT_DECL(935,__match_no,13,((VES10_1_type==100)&&(VES10_1_subtype==0x2710)&&(VES10_1_control==5)),tracking_febex);
  MATCH_SUBEVENT_DECL(936,__match_no,14,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==1)),los_empty);
  MATCH_SUBEVENT_DECL(937,__match_no,15,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==2)),tofd_empty);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(923,wr_100,master_ts,0);
      UNPACK_SUBEVENT_DECL(923,0,wr_100,master_ts);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(924,tpat_subev,master_tpat,1);
      UNPACK_SUBEVENT_DECL(924,0,tpat_subev,master_tpat);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(925,lmu_scalers_subev,master_lmu_scalers,2);
      UNPACK_SUBEVENT_DECL(925,0,lmu_scalers_subev,master_lmu_scalers);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(926,master_subev,master_vme,3);
      UNPACK_SUBEVENT_DECL(926,0,master_subev,master_vme);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(927,los_subev,los,4);
      UNPACK_SUBEVENT_DECL(927,0,los_subev,los);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(928,los_scalers_subev,los_scalers,5);
      UNPACK_SUBEVENT_DECL(928,0,los_scalers_subev,los_scalers);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(929,los_sampler_subev,los_sampler,6);
      UNPACK_SUBEVENT_DECL(929,0,los_sampler_subev,los_sampler);
      break;
    case 8:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(930,tofd_vme_subev,tofd_vme,7);
      UNPACK_SUBEVENT_DECL(930,0,tofd_vme_subev,tofd_vme);
      break;
    case 9:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(931,wr_200,tbm_ts,8);
      UNPACK_SUBEVENT_DECL(931,0,wr_200,tbm_ts);
      break;
    case 10:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(932,tpat_subev,tbm_tpat,9);
      UNPACK_SUBEVENT_DECL(932,0,tpat_subev,tbm_tpat);
      break;
    case 11:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(933,tbm_subev,tbm_vme,10);
      UNPACK_SUBEVENT_DECL(933,0,tbm_subev,tbm_vme);
      break;
    case 12:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(934,tofd_tamex_subev,tofd_tamex,11);
      UNPACK_SUBEVENT_DECL(934,0,tofd_tamex_subev,tofd_tamex);
      break;
    case 13:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(935,tracking_febex_subev,tracking_febex,12);
      UNPACK_SUBEVENT_DECL(935,0,tracking_febex_subev,tracking_febex);
      break;
    case 14:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(936,empty_subev,los_empty,13);
      UNPACK_SUBEVENT_DECL(936,0,empty_subev,los_empty);
      break;
    case 15:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(937,empty_subev,tofd_empty,14);
      UNPACK_SUBEVENT_DECL(937,0,empty_subev,tofd_empty);
      break;
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
  // master_ts = wr_100(type=10,subtype=1,control=0);
  // master_tpat = tpat_subev(type=36,subtype=0xe10,control=0);
  // master_lmu_scalers = lmu_scalers_subev(type=37,subtype=0xe74,control=0);
  // master_vme = master_subev(type=88,subtype=0x2260,control=0);
  // los = los_subev(type=88,subtype=0x2260,control=1);
  // los_scalers = los_scalers_subev(type=38,subtype=0xed8,control=1);
  // los_sampler = los_sampler_subev(type=39,subtype=0xf3c,control=1);
  // tofd_vme = tofd_vme_subev(type=88,subtype=0x2260,control=2);
  // tbm_ts = wr_200(type=10,subtype=1,control=3);
  // tbm_tpat = tpat_subev(type=36,subtype=0xe10,control=3);
  // tbm_vme = tbm_subev(type=88,subtype=0x2260,control=3);
  // tofd_tamex = tofd_tamex_subev(type=102,subtype=0x27d8,control=4);
  // tracking_febex = tracking_febex_subev(type=100,subtype=0x2710,control=5);
  // los_empty = empty_subev(type=10,subtype=1,control=1);
  // tofd_empty = empty_subev(type=10,subtype=1,control=2);
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// EVENT
int unpack_event::__revoke_subevent(subevent_header *__header)
  // master_ts = wr_100(type=10,subtype=1,control=0);
  // master_tpat = tpat_subev(type=36,subtype=0xe10,control=0);
  // master_lmu_scalers = lmu_scalers_subev(type=37,subtype=0xe74,control=0);
  // master_vme = master_subev(type=88,subtype=0x2260,control=0);
  // los = los_subev(type=88,subtype=0x2260,control=1);
  // los_scalers = los_scalers_subev(type=38,subtype=0xed8,control=1);
  // los_sampler = los_sampler_subev(type=39,subtype=0xf3c,control=1);
  // tofd_vme = tofd_vme_subev(type=88,subtype=0x2260,control=2);
  // tbm_ts = wr_200(type=10,subtype=1,control=3);
  // tbm_tpat = tpat_subev(type=36,subtype=0xe10,control=3);
  // tbm_vme = tbm_subev(type=88,subtype=0x2260,control=3);
  // tofd_tamex = tofd_tamex_subev(type=102,subtype=0x27d8,control=4);
  // tracking_febex = tracking_febex_subev(type=100,subtype=0x2710,control=5);
  // los_empty = empty_subev(type=10,subtype=1,control=1);
  // tofd_empty = empty_subev(type=10,subtype=1,control=2);
{
  int __match_no = 0;
  MATCH_SUBEVENT_DECL(923,__match_no,1,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==0)),master_ts);
  MATCH_SUBEVENT_DECL(924,__match_no,2,((VES10_1_type==36)&&(VES10_1_subtype==0xe10)&&(VES10_1_control==0)),master_tpat);
  MATCH_SUBEVENT_DECL(925,__match_no,3,((VES10_1_type==37)&&(VES10_1_subtype==0xe74)&&(VES10_1_control==0)),master_lmu_scalers);
  MATCH_SUBEVENT_DECL(926,__match_no,4,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==0)),master_vme);
  MATCH_SUBEVENT_DECL(927,__match_no,5,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==1)),los);
  MATCH_SUBEVENT_DECL(928,__match_no,6,((VES10_1_type==38)&&(VES10_1_subtype==0xed8)&&(VES10_1_control==1)),los_scalers);
  MATCH_SUBEVENT_DECL(929,__match_no,7,((VES10_1_type==39)&&(VES10_1_subtype==0xf3c)&&(VES10_1_control==1)),los_sampler);
  MATCH_SUBEVENT_DECL(930,__match_no,8,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==2)),tofd_vme);
  MATCH_SUBEVENT_DECL(931,__match_no,9,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==3)),tbm_ts);
  MATCH_SUBEVENT_DECL(932,__match_no,10,((VES10_1_type==36)&&(VES10_1_subtype==0xe10)&&(VES10_1_control==3)),tbm_tpat);
  MATCH_SUBEVENT_DECL(933,__match_no,11,((VES10_1_type==88)&&(VES10_1_subtype==0x2260)&&(VES10_1_control==3)),tbm_vme);
  MATCH_SUBEVENT_DECL(934,__match_no,12,((VES10_1_type==102)&&(VES10_1_subtype==0x27d8)&&(VES10_1_control==4)),tofd_tamex);
  MATCH_SUBEVENT_DECL(935,__match_no,13,((VES10_1_type==100)&&(VES10_1_subtype==0x2710)&&(VES10_1_control==5)),tracking_febex);
  MATCH_SUBEVENT_DECL(936,__match_no,14,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==1)),los_empty);
  MATCH_SUBEVENT_DECL(937,__match_no,15,((VES10_1_type==10)&&(VES10_1_subtype==1)&&(VES10_1_control==2)),tofd_empty);
  if (!__match_no) return 0;
  switch (__match_no)
  {
    case 1:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(923,wr_100,master_ts,0);
      REVOKE_SUBEVENT_DECL(923,0,wr_100,master_ts);
      break;
    case 2:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(924,tpat_subev,master_tpat,1);
      REVOKE_SUBEVENT_DECL(924,0,tpat_subev,master_tpat);
      break;
    case 3:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(925,lmu_scalers_subev,master_lmu_scalers,2);
      REVOKE_SUBEVENT_DECL(925,0,lmu_scalers_subev,master_lmu_scalers);
      break;
    case 4:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(926,master_subev,master_vme,3);
      REVOKE_SUBEVENT_DECL(926,0,master_subev,master_vme);
      break;
    case 5:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(927,los_subev,los,4);
      REVOKE_SUBEVENT_DECL(927,0,los_subev,los);
      break;
    case 6:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(928,los_scalers_subev,los_scalers,5);
      REVOKE_SUBEVENT_DECL(928,0,los_scalers_subev,los_scalers);
      break;
    case 7:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(929,los_sampler_subev,los_sampler,6);
      REVOKE_SUBEVENT_DECL(929,0,los_sampler_subev,los_sampler);
      break;
    case 8:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(930,tofd_vme_subev,tofd_vme,7);
      REVOKE_SUBEVENT_DECL(930,0,tofd_vme_subev,tofd_vme);
      break;
    case 9:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(931,wr_200,tbm_ts,8);
      REVOKE_SUBEVENT_DECL(931,0,wr_200,tbm_ts);
      break;
    case 10:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(932,tpat_subev,tbm_tpat,9);
      REVOKE_SUBEVENT_DECL(932,0,tpat_subev,tbm_tpat);
      break;
    case 11:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(933,tbm_subev,tbm_vme,10);
      REVOKE_SUBEVENT_DECL(933,0,tbm_subev,tbm_vme);
      break;
    case 12:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(934,tofd_tamex_subev,tofd_tamex,11);
      REVOKE_SUBEVENT_DECL(934,0,tofd_tamex_subev,tofd_tamex);
      break;
    case 13:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(935,tracking_febex_subev,tracking_febex,12);
      REVOKE_SUBEVENT_DECL(935,0,tracking_febex_subev,tracking_febex);
      break;
    case 14:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(936,empty_subev,los_empty,13);
      REVOKE_SUBEVENT_DECL(936,0,empty_subev,los_empty);
      break;
    case 15:
      UNPACK_SUBEVENT_CHECK_NO_REVISIT(937,empty_subev,tofd_empty,14);
      REVOKE_SUBEVENT_DECL(937,0,empty_subev,tofd_empty);
      break;
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */

{ "master_ts", "type=10:subtype=1:control=0" },
{ "master_tpat", "type=36:subtype=0xe10:control=0" },
{ "master_lmu_scalers", "type=37:subtype=0xe74:control=0" },
{ "master_vme", "type=88:subtype=0x2260:control=0" },
{ "los", "type=88:subtype=0x2260:control=1" },
{ "los_scalers", "type=38:subtype=0xed8:control=1" },
{ "los_sampler", "type=39:subtype=0xf3c:control=1" },
{ "tofd_vme", "type=88:subtype=0x2260:control=2" },
{ "tbm_ts", "type=10:subtype=1:control=3" },
{ "tbm_tpat", "type=36:subtype=0xe10:control=3" },
{ "tbm_vme", "type=88:subtype=0x2260:control=3" },
{ "tofd_tamex", "type=102:subtype=0x27d8:control=4" },
{ "tracking_febex", "type=100:subtype=0x2710:control=5" },
{ "los_empty", "type=10:subtype=1:control=1" },
{ "tofd_empty", "type=10:subtype=1:control=2" },

/** END_SUBEVENT_NAMES ************************************************/

//
// Generating code for EVENT
//

/** BEGIN_STRUCTURES ***************************************************
 *
 * Event unpacker associated structures for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
class unpack_sticky_event : public unpack_sticky_event_base
{
public:
public:
#ifndef __PSDC__
  void __clear_visited() { }
  bool ignore_unknown_subevent() { return false; }
#endif//!__PSDC__

public:
#ifndef __PSDC__
template<typename __data_src_t>
  int __unpack_subevent(subevent_header *__header,__data_src_t &__buffer);
  int __revoke_subevent(subevent_header *__header);
  // void __clean_event();

  STRUCT_FCNS_DECL(unpack_sticky_event);
#endif//!__PSDC__
};

/** END_STRUCTURES ****************************************************/


/** BEGIN_UNPACKER *****************************************************
 *
 * Event unpacker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
template<typename __data_src_t>
int unpack_sticky_event::__unpack_subevent(subevent_header *__header,__data_src_t &__buffer)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}
FORCE_IMPL_DATA_SRC_FCN_HDR(int,unpack_sticky_event::__unpack_subevent);

/** END_UNPACKER ******************************************************/


/** BEGIN_PACKER *******************************************************
 *
 * Event packer for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
{
}

/** END_PACKER ********************************************************/


/** BEGIN_REVOKE *******************************************************
 *
 * Event revoker for EVENT.
 *
 * Do not edit - automatically generated.
 */

// STICKY_EVENT
int unpack_sticky_event::__revoke_subevent(subevent_header *__header)
{
  int __match_no = 0;
  if (!__match_no) return 0;
  switch (__match_no)
  {
  }
  return 0;
}

/** END_REVOKE ********************************************************/


/** BEGIN_SUBEVENT_NAMES ***********************************************
 *
 * Mappings of names for [incl|excl] name lookup.
 *
 * Do not edit - automatically generated.
 */


/** END_SUBEVENT_NAMES ************************************************/


/** BEGIN_UNPACKER_DEFINES *********************************************
 *
 * Control
 *
 * Do not edit - automatically generated.
 */

#define STICKY_EVENT_IS_NONTRIVIAL  0


/** END_UNPACKER_DEFINES **********************************************/

/**********************************************************/
/**********************************************************
 * Generating event structure...
 */


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_event_TIMESTAMP_MASTER_WR
{
public:
//DUMPY: 4 0
  DATA16 T[4];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TIMESTAMP_MASTER_WR);
#endif//!__PSDC__
} ;

class raw_event_TIMESTAMP_MASTER
{
public:
  DATA32 HI;
  DATA12 ID;
  DATA32 LO;
  raw_event_TIMESTAMP_MASTER_WR
  /* {
  public:
//DUMPY: 4 0
    DATA16 T[4];
  } */ WR;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TIMESTAMP_MASTER);
#endif//!__PSDC__
} ;

class raw_event_TIMESTAMP
{
public:
  raw_event_TIMESTAMP_MASTER
  /* {
  public:
    DATA32 HI;
    DATA12 ID;
    DATA32 LO;
    raw_event_TIMESTAMP_MASTER_WR
    {
    public:
//DUMPY: 4 0
      DATA16 T[4];
    } WR;
  } */ MASTER;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TIMESTAMP);
#endif//!__PSDC__
} ;

//DUMPY: 2 0
class raw_event_TOFD_P_T
{
public:
//DUMPY: 6 4
  raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCL;
//DUMPY: 6 4
  raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCT;
//DUMPY: 6 4
  raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFL;
//DUMPY: 6 4
  raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFT;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TOFD_P_T);
#endif//!__PSDC__
} ;

//DUMPY: 6 0
class raw_event_TOFD_P
{
public:
//DUMPY: 2 0
  raw_event_TOFD_P_T
  /* {
  public:
//DUMPY: 6 4
    raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCL;
//DUMPY: 6 4
    raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCT;
//DUMPY: 6 4
    raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFL;
//DUMPY: 6 4
    raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFT;
  } */ T[2];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TOFD_P);
#endif//!__PSDC__
} ;

//DUMPY: 2 0
class raw_event_TOFD_VFTX
{
public:
//DUMPY: 3 0
  DATA16 T[3];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TOFD_VFTX);
#endif//!__PSDC__
} ;

class raw_event_TOFD
{
public:
//DUMPY: 6 0
  raw_event_TOFD_P
  /* {
  public:
//DUMPY: 2 0
    raw_event_TOFD_P_T
    {
    public:
//DUMPY: 6 4
      raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCL;
//DUMPY: 6 4
      raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCT;
//DUMPY: 6 4
      raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFL;
//DUMPY: 6 4
      raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFT;
    } T[2];
  } */ P[6];
//DUMPY: 2 0
  raw_event_TOFD_VFTX
  /* {
  public:
//DUMPY: 3 0
    DATA16 T[3];
  } */ VFTX[2];

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TOFD);
#endif//!__PSDC__
} ;

class raw_event_TRLO_SAMPLER
{
public:
//DUMPY: 512 1
  raw_array_zero_suppress<DATA32,DATA32,512> S;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TRLO_SAMPLER);
#endif//!__PSDC__
} ;

class raw_event_TRLO
{
public:
  raw_event_TRLO_SAMPLER
  /* {
  public:
//DUMPY: 512 1
    raw_array_zero_suppress<DATA32,DATA32,512> S;
  } */ SAMPLER;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event_TRLO);
#endif//!__PSDC__
} ;

class raw_event : public raw_event_base
{
public:
  raw_event_TIMESTAMP
  /* {
  public:
    raw_event_TIMESTAMP_MASTER
    {
    public:
      DATA32 HI;
      DATA12 ID;
      DATA32 LO;
      raw_event_TIMESTAMP_MASTER_WR
      {
      public:
//DUMPY: 4 0
        DATA16 T[4];
      } WR;
    } MASTER;
  } */ TIMESTAMP;
  raw_event_TOFD
  /* {
  public:
//DUMPY: 6 0
    raw_event_TOFD_P
    {
    public:
//DUMPY: 2 0
      raw_event_TOFD_P_T
      {
      public:
//DUMPY: 6 4
        raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCL;
//DUMPY: 6 4
        raw_array_multi_zero_suppress<DATA16,DATA16,6,32> TCT;
//DUMPY: 6 4
        raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFL;
//DUMPY: 6 4
        raw_array_multi_zero_suppress<DATA12,DATA12,6,32> TFT;
      } T[2];
    } P[6];
//DUMPY: 2 0
    raw_event_TOFD_VFTX
    {
    public:
//DUMPY: 3 0
      DATA16 T[3];
    } VFTX[2];
  } */ TOFD;
  raw_event_TRLO
  /* {
  public:
    raw_event_TRLO_SAMPLER
    {
    public:
//DUMPY: 512 1
      raw_array_zero_suppress<DATA32,DATA32,512> S;
    } SAMPLER;
  } */ TRLO;

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_event);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_CAL_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class cal_event : public cal_event_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(cal_event);
#endif//!__PSDC__
} ;

/** END_EVENT_CAL_STRUCTURE *******************************************/


/** BEGIN_EVENT_RAW_STRUCTURE ******************************************
 *
 * Event data structure.
 *
 * Do not edit - automatically generated.
 */

class raw_sticky : public raw_sticky_base
{
public:

public:
#ifndef __PSDC__
  STRUCT_FCNS_DECL(raw_sticky);
#endif//!__PSDC__
} ;

/** END_EVENT_RAW_STRUCTURE *******************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.

SIGNAL_MAPPING(DATA32,TIMESTAMP_MASTER_HI,master_ts.multi_.time_hi,TIMESTAMP.MASTER.HI);
SIGNAL_MAPPING(DATA12,TIMESTAMP_MASTER_ID,master_ts.ts100.subsystem_id,TIMESTAMP.MASTER.ID);
SIGNAL_MAPPING(DATA32,TIMESTAMP_MASTER_LO,master_ts.multi_.time_lo,TIMESTAMP.MASTER.LO);
SIGNAL_MAPPING(DATA16,TIMESTAMP_MASTER_WR_T1,master_ts.ts100.t1,TIMESTAMP.MASTER.WR.T[0]);
SIGNAL_MAPPING(DATA16,TIMESTAMP_MASTER_WR_T2,master_ts.ts100.t2,TIMESTAMP.MASTER.WR.T[1]);
SIGNAL_MAPPING(DATA16,TIMESTAMP_MASTER_WR_T3,master_ts.ts100.t3,TIMESTAMP.MASTER.WR.T[2]);
SIGNAL_MAPPING(DATA16,TIMESTAMP_MASTER_WR_T4,master_ts.ts100.t4,TIMESTAMP.MASTER.WR.T[3]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCL1,tofd_vme.vftx2_1.time_coarse[0],TOFD.P[0].T[0].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCL2,tofd_vme.vftx2_1.time_coarse[4],TOFD.P[0].T[0].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCL3,tofd_vme.vftx2_1.time_coarse[8],TOFD.P[0].T[0].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCL4,tofd_vme.vftx2_1.time_coarse[12],TOFD.P[0].T[0].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCL5,tofd_vme.vftx2_2.time_coarse[0],TOFD.P[0].T[0].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCL6,tofd_vme.vftx2_2.time_coarse[4],TOFD.P[0].T[0].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCT1,tofd_vme.vftx2_1.time_coarse[1],TOFD.P[0].T[0].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCT2,tofd_vme.vftx2_1.time_coarse[5],TOFD.P[0].T[0].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCT3,tofd_vme.vftx2_1.time_coarse[9],TOFD.P[0].T[0].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCT4,tofd_vme.vftx2_1.time_coarse[13],TOFD.P[0].T[0].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCT5,tofd_vme.vftx2_2.time_coarse[1],TOFD.P[0].T[0].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T1_TCT6,tofd_vme.vftx2_2.time_coarse[5],TOFD.P[0].T[0].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFL1,tofd_vme.vftx2_1.time_fine[0],TOFD.P[0].T[0].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFL2,tofd_vme.vftx2_1.time_fine[4],TOFD.P[0].T[0].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFL3,tofd_vme.vftx2_1.time_fine[8],TOFD.P[0].T[0].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFL4,tofd_vme.vftx2_1.time_fine[12],TOFD.P[0].T[0].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFL5,tofd_vme.vftx2_2.time_fine[0],TOFD.P[0].T[0].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFL6,tofd_vme.vftx2_2.time_fine[4],TOFD.P[0].T[0].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFT1,tofd_vme.vftx2_1.time_fine[1],TOFD.P[0].T[0].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFT2,tofd_vme.vftx2_1.time_fine[5],TOFD.P[0].T[0].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFT3,tofd_vme.vftx2_1.time_fine[9],TOFD.P[0].T[0].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFT4,tofd_vme.vftx2_1.time_fine[13],TOFD.P[0].T[0].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFT5,tofd_vme.vftx2_2.time_fine[1],TOFD.P[0].T[0].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T1_TFT6,tofd_vme.vftx2_2.time_fine[5],TOFD.P[0].T[0].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCL1,tofd_vme.vftx2_1.time_coarse[2],TOFD.P[0].T[1].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCL2,tofd_vme.vftx2_1.time_coarse[6],TOFD.P[0].T[1].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCL3,tofd_vme.vftx2_1.time_coarse[10],TOFD.P[0].T[1].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCL4,tofd_vme.vftx2_1.time_coarse[14],TOFD.P[0].T[1].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCL5,tofd_vme.vftx2_2.time_coarse[2],TOFD.P[0].T[1].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCL6,tofd_vme.vftx2_2.time_coarse[6],TOFD.P[0].T[1].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCT1,tofd_vme.vftx2_1.time_coarse[3],TOFD.P[0].T[1].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCT2,tofd_vme.vftx2_1.time_coarse[7],TOFD.P[0].T[1].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCT3,tofd_vme.vftx2_1.time_coarse[11],TOFD.P[0].T[1].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCT4,tofd_vme.vftx2_1.time_coarse[15],TOFD.P[0].T[1].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCT5,tofd_vme.vftx2_2.time_coarse[3],TOFD.P[0].T[1].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P1T2_TCT6,tofd_vme.vftx2_2.time_coarse[7],TOFD.P[0].T[1].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFL1,tofd_vme.vftx2_1.time_fine[2],TOFD.P[0].T[1].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFL2,tofd_vme.vftx2_1.time_fine[6],TOFD.P[0].T[1].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFL3,tofd_vme.vftx2_1.time_fine[10],TOFD.P[0].T[1].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFL4,tofd_vme.vftx2_1.time_fine[14],TOFD.P[0].T[1].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFL5,tofd_vme.vftx2_2.time_fine[2],TOFD.P[0].T[1].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFL6,tofd_vme.vftx2_2.time_fine[6],TOFD.P[0].T[1].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFT1,tofd_vme.vftx2_1.time_fine[3],TOFD.P[0].T[1].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFT2,tofd_vme.vftx2_1.time_fine[7],TOFD.P[0].T[1].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFT3,tofd_vme.vftx2_1.time_fine[11],TOFD.P[0].T[1].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFT4,tofd_vme.vftx2_1.time_fine[15],TOFD.P[0].T[1].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFT5,tofd_vme.vftx2_2.time_fine[3],TOFD.P[0].T[1].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P1T2_TFT6,tofd_vme.vftx2_2.time_fine[7],TOFD.P[0].T[1].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCL1,tofd_vme.vftx2_2.time_coarse[8],TOFD.P[1].T[0].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCL2,tofd_vme.vftx2_2.time_coarse[12],TOFD.P[1].T[0].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCL3,tofd_vme.vftx2_3.time_coarse[0],TOFD.P[1].T[0].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCL4,tofd_vme.vftx2_3.time_coarse[4],TOFD.P[1].T[0].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCL5,tofd_vme.vftx2_3.time_coarse[8],TOFD.P[1].T[0].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCL6,tofd_vme.vftx2_3.time_coarse[12],TOFD.P[1].T[0].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCT1,tofd_vme.vftx2_2.time_coarse[9],TOFD.P[1].T[0].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCT2,tofd_vme.vftx2_2.time_coarse[13],TOFD.P[1].T[0].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCT3,tofd_vme.vftx2_3.time_coarse[1],TOFD.P[1].T[0].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCT4,tofd_vme.vftx2_3.time_coarse[5],TOFD.P[1].T[0].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCT5,tofd_vme.vftx2_3.time_coarse[9],TOFD.P[1].T[0].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T1_TCT6,tofd_vme.vftx2_3.time_coarse[13],TOFD.P[1].T[0].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFL1,tofd_vme.vftx2_2.time_fine[8],TOFD.P[1].T[0].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFL2,tofd_vme.vftx2_2.time_fine[12],TOFD.P[1].T[0].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFL3,tofd_vme.vftx2_3.time_fine[0],TOFD.P[1].T[0].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFL4,tofd_vme.vftx2_3.time_fine[4],TOFD.P[1].T[0].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFL5,tofd_vme.vftx2_3.time_fine[8],TOFD.P[1].T[0].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFL6,tofd_vme.vftx2_3.time_fine[12],TOFD.P[1].T[0].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFT1,tofd_vme.vftx2_2.time_fine[9],TOFD.P[1].T[0].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFT2,tofd_vme.vftx2_2.time_fine[13],TOFD.P[1].T[0].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFT3,tofd_vme.vftx2_3.time_fine[1],TOFD.P[1].T[0].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFT4,tofd_vme.vftx2_3.time_fine[5],TOFD.P[1].T[0].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFT5,tofd_vme.vftx2_3.time_fine[9],TOFD.P[1].T[0].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T1_TFT6,tofd_vme.vftx2_3.time_fine[13],TOFD.P[1].T[0].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCL1,tofd_vme.vftx2_2.time_coarse[10],TOFD.P[1].T[1].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCL2,tofd_vme.vftx2_2.time_coarse[14],TOFD.P[1].T[1].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCL3,tofd_vme.vftx2_3.time_coarse[2],TOFD.P[1].T[1].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCL4,tofd_vme.vftx2_3.time_coarse[6],TOFD.P[1].T[1].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCL5,tofd_vme.vftx2_3.time_coarse[10],TOFD.P[1].T[1].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCL6,tofd_vme.vftx2_3.time_coarse[14],TOFD.P[1].T[1].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCT1,tofd_vme.vftx2_2.time_coarse[11],TOFD.P[1].T[1].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCT2,tofd_vme.vftx2_2.time_coarse[15],TOFD.P[1].T[1].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCT3,tofd_vme.vftx2_3.time_coarse[3],TOFD.P[1].T[1].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCT4,tofd_vme.vftx2_3.time_coarse[7],TOFD.P[1].T[1].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCT5,tofd_vme.vftx2_3.time_coarse[11],TOFD.P[1].T[1].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P2T2_TCT6,tofd_vme.vftx2_3.time_coarse[15],TOFD.P[1].T[1].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFL1,tofd_vme.vftx2_2.time_fine[10],TOFD.P[1].T[1].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFL2,tofd_vme.vftx2_2.time_fine[14],TOFD.P[1].T[1].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFL3,tofd_vme.vftx2_3.time_fine[2],TOFD.P[1].T[1].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFL4,tofd_vme.vftx2_3.time_fine[6],TOFD.P[1].T[1].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFL5,tofd_vme.vftx2_3.time_fine[10],TOFD.P[1].T[1].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFL6,tofd_vme.vftx2_3.time_fine[14],TOFD.P[1].T[1].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFT1,tofd_vme.vftx2_2.time_fine[11],TOFD.P[1].T[1].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFT2,tofd_vme.vftx2_2.time_fine[15],TOFD.P[1].T[1].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFT3,tofd_vme.vftx2_3.time_fine[3],TOFD.P[1].T[1].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFT4,tofd_vme.vftx2_3.time_fine[7],TOFD.P[1].T[1].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFT5,tofd_vme.vftx2_3.time_fine[11],TOFD.P[1].T[1].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P2T2_TFT6,tofd_vme.vftx2_3.time_fine[15],TOFD.P[1].T[1].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCL1,tofd_tamex.tamex_1.time_coarse[1],TOFD.P[2].T[0].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCL2,tofd_tamex.tamex_1.time_coarse[5],TOFD.P[2].T[0].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCL3,tofd_tamex.tamex_1.time_coarse[9],TOFD.P[2].T[0].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCL4,tofd_tamex.tamex_1.time_coarse[13],TOFD.P[2].T[0].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCL5,tofd_tamex.tamex_1.time_coarse[17],TOFD.P[2].T[0].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCL6,tofd_tamex.tamex_1.time_coarse[21],TOFD.P[2].T[0].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCT1,tofd_tamex.tamex_1.time_coarse[2],TOFD.P[2].T[0].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCT2,tofd_tamex.tamex_1.time_coarse[6],TOFD.P[2].T[0].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCT3,tofd_tamex.tamex_1.time_coarse[10],TOFD.P[2].T[0].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCT4,tofd_tamex.tamex_1.time_coarse[14],TOFD.P[2].T[0].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCT5,tofd_tamex.tamex_1.time_coarse[18],TOFD.P[2].T[0].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T1_TCT6,tofd_tamex.tamex_1.time_coarse[22],TOFD.P[2].T[0].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFL1,tofd_tamex.tamex_1.time_fine[1],TOFD.P[2].T[0].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFL2,tofd_tamex.tamex_1.time_fine[5],TOFD.P[2].T[0].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFL3,tofd_tamex.tamex_1.time_fine[9],TOFD.P[2].T[0].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFL4,tofd_tamex.tamex_1.time_fine[13],TOFD.P[2].T[0].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFL5,tofd_tamex.tamex_1.time_fine[17],TOFD.P[2].T[0].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFL6,tofd_tamex.tamex_1.time_fine[21],TOFD.P[2].T[0].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFT1,tofd_tamex.tamex_1.time_fine[2],TOFD.P[2].T[0].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFT2,tofd_tamex.tamex_1.time_fine[6],TOFD.P[2].T[0].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFT3,tofd_tamex.tamex_1.time_fine[10],TOFD.P[2].T[0].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFT4,tofd_tamex.tamex_1.time_fine[14],TOFD.P[2].T[0].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFT5,tofd_tamex.tamex_1.time_fine[18],TOFD.P[2].T[0].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T1_TFT6,tofd_tamex.tamex_1.time_fine[22],TOFD.P[2].T[0].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCL1,tofd_tamex.tamex_1.time_coarse[3],TOFD.P[2].T[1].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCL2,tofd_tamex.tamex_1.time_coarse[7],TOFD.P[2].T[1].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCL3,tofd_tamex.tamex_1.time_coarse[11],TOFD.P[2].T[1].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCL4,tofd_tamex.tamex_1.time_coarse[15],TOFD.P[2].T[1].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCL5,tofd_tamex.tamex_1.time_coarse[19],TOFD.P[2].T[1].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCL6,tofd_tamex.tamex_1.time_coarse[23],TOFD.P[2].T[1].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCT1,tofd_tamex.tamex_1.time_coarse[4],TOFD.P[2].T[1].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCT2,tofd_tamex.tamex_1.time_coarse[8],TOFD.P[2].T[1].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCT3,tofd_tamex.tamex_1.time_coarse[12],TOFD.P[2].T[1].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCT4,tofd_tamex.tamex_1.time_coarse[16],TOFD.P[2].T[1].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCT5,tofd_tamex.tamex_1.time_coarse[20],TOFD.P[2].T[1].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P3T2_TCT6,tofd_tamex.tamex_1.time_coarse[24],TOFD.P[2].T[1].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFL1,tofd_tamex.tamex_1.time_fine[3],TOFD.P[2].T[1].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFL2,tofd_tamex.tamex_1.time_fine[7],TOFD.P[2].T[1].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFL3,tofd_tamex.tamex_1.time_fine[11],TOFD.P[2].T[1].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFL4,tofd_tamex.tamex_1.time_fine[15],TOFD.P[2].T[1].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFL5,tofd_tamex.tamex_1.time_fine[19],TOFD.P[2].T[1].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFL6,tofd_tamex.tamex_1.time_fine[23],TOFD.P[2].T[1].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFT1,tofd_tamex.tamex_1.time_fine[4],TOFD.P[2].T[1].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFT2,tofd_tamex.tamex_1.time_fine[8],TOFD.P[2].T[1].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFT3,tofd_tamex.tamex_1.time_fine[12],TOFD.P[2].T[1].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFT4,tofd_tamex.tamex_1.time_fine[16],TOFD.P[2].T[1].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFT5,tofd_tamex.tamex_1.time_fine[20],TOFD.P[2].T[1].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P3T2_TFT6,tofd_tamex.tamex_1.time_fine[24],TOFD.P[2].T[1].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCL1,tofd_tamex.tamex_2.time_coarse[1],TOFD.P[3].T[0].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCL2,tofd_tamex.tamex_2.time_coarse[5],TOFD.P[3].T[0].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCL3,tofd_tamex.tamex_2.time_coarse[9],TOFD.P[3].T[0].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCL4,tofd_tamex.tamex_2.time_coarse[13],TOFD.P[3].T[0].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCL5,tofd_tamex.tamex_2.time_coarse[17],TOFD.P[3].T[0].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCL6,tofd_tamex.tamex_2.time_coarse[21],TOFD.P[3].T[0].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCT1,tofd_tamex.tamex_2.time_coarse[2],TOFD.P[3].T[0].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCT2,tofd_tamex.tamex_2.time_coarse[6],TOFD.P[3].T[0].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCT3,tofd_tamex.tamex_2.time_coarse[10],TOFD.P[3].T[0].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCT4,tofd_tamex.tamex_2.time_coarse[14],TOFD.P[3].T[0].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCT5,tofd_tamex.tamex_2.time_coarse[18],TOFD.P[3].T[0].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T1_TCT6,tofd_tamex.tamex_2.time_coarse[22],TOFD.P[3].T[0].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFL1,tofd_tamex.tamex_2.time_fine[1],TOFD.P[3].T[0].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFL2,tofd_tamex.tamex_2.time_fine[5],TOFD.P[3].T[0].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFL3,tofd_tamex.tamex_2.time_fine[9],TOFD.P[3].T[0].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFL4,tofd_tamex.tamex_2.time_fine[13],TOFD.P[3].T[0].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFL5,tofd_tamex.tamex_2.time_fine[17],TOFD.P[3].T[0].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFL6,tofd_tamex.tamex_2.time_fine[21],TOFD.P[3].T[0].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFT1,tofd_tamex.tamex_2.time_fine[2],TOFD.P[3].T[0].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFT2,tofd_tamex.tamex_2.time_fine[6],TOFD.P[3].T[0].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFT3,tofd_tamex.tamex_2.time_fine[10],TOFD.P[3].T[0].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFT4,tofd_tamex.tamex_2.time_fine[14],TOFD.P[3].T[0].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFT5,tofd_tamex.tamex_2.time_fine[18],TOFD.P[3].T[0].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T1_TFT6,tofd_tamex.tamex_2.time_fine[22],TOFD.P[3].T[0].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCL1,tofd_tamex.tamex_2.time_coarse[3],TOFD.P[3].T[1].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCL2,tofd_tamex.tamex_2.time_coarse[7],TOFD.P[3].T[1].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCL3,tofd_tamex.tamex_2.time_coarse[11],TOFD.P[3].T[1].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCL4,tofd_tamex.tamex_2.time_coarse[15],TOFD.P[3].T[1].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCL5,tofd_tamex.tamex_2.time_coarse[19],TOFD.P[3].T[1].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCL6,tofd_tamex.tamex_2.time_coarse[23],TOFD.P[3].T[1].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCT1,tofd_tamex.tamex_2.time_coarse[4],TOFD.P[3].T[1].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCT2,tofd_tamex.tamex_2.time_coarse[8],TOFD.P[3].T[1].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCT3,tofd_tamex.tamex_2.time_coarse[12],TOFD.P[3].T[1].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCT4,tofd_tamex.tamex_2.time_coarse[16],TOFD.P[3].T[1].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCT5,tofd_tamex.tamex_2.time_coarse[20],TOFD.P[3].T[1].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P4T2_TCT6,tofd_tamex.tamex_2.time_coarse[24],TOFD.P[3].T[1].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFL1,tofd_tamex.tamex_2.time_fine[3],TOFD.P[3].T[1].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFL2,tofd_tamex.tamex_2.time_fine[7],TOFD.P[3].T[1].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFL3,tofd_tamex.tamex_2.time_fine[11],TOFD.P[3].T[1].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFL4,tofd_tamex.tamex_2.time_fine[15],TOFD.P[3].T[1].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFL5,tofd_tamex.tamex_2.time_fine[19],TOFD.P[3].T[1].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFL6,tofd_tamex.tamex_2.time_fine[23],TOFD.P[3].T[1].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFT1,tofd_tamex.tamex_2.time_fine[4],TOFD.P[3].T[1].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFT2,tofd_tamex.tamex_2.time_fine[8],TOFD.P[3].T[1].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFT3,tofd_tamex.tamex_2.time_fine[12],TOFD.P[3].T[1].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFT4,tofd_tamex.tamex_2.time_fine[16],TOFD.P[3].T[1].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFT5,tofd_tamex.tamex_2.time_fine[20],TOFD.P[3].T[1].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P4T2_TFT6,tofd_tamex.tamex_2.time_fine[24],TOFD.P[3].T[1].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCL1,tofd_tamex.tamex_3.time_coarse[1],TOFD.P[4].T[0].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCL2,tofd_tamex.tamex_3.time_coarse[5],TOFD.P[4].T[0].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCL3,tofd_tamex.tamex_3.time_coarse[9],TOFD.P[4].T[0].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCL4,tofd_tamex.tamex_3.time_coarse[13],TOFD.P[4].T[0].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCL5,tofd_tamex.tamex_3.time_coarse[17],TOFD.P[4].T[0].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCL6,tofd_tamex.tamex_3.time_coarse[21],TOFD.P[4].T[0].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCT1,tofd_tamex.tamex_3.time_coarse[2],TOFD.P[4].T[0].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCT2,tofd_tamex.tamex_3.time_coarse[6],TOFD.P[4].T[0].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCT3,tofd_tamex.tamex_3.time_coarse[10],TOFD.P[4].T[0].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCT4,tofd_tamex.tamex_3.time_coarse[14],TOFD.P[4].T[0].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCT5,tofd_tamex.tamex_3.time_coarse[18],TOFD.P[4].T[0].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T1_TCT6,tofd_tamex.tamex_3.time_coarse[22],TOFD.P[4].T[0].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFL1,tofd_tamex.tamex_3.time_fine[1],TOFD.P[4].T[0].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFL2,tofd_tamex.tamex_3.time_fine[5],TOFD.P[4].T[0].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFL3,tofd_tamex.tamex_3.time_fine[9],TOFD.P[4].T[0].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFL4,tofd_tamex.tamex_3.time_fine[13],TOFD.P[4].T[0].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFL5,tofd_tamex.tamex_3.time_fine[17],TOFD.P[4].T[0].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFL6,tofd_tamex.tamex_3.time_fine[21],TOFD.P[4].T[0].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFT1,tofd_tamex.tamex_3.time_fine[2],TOFD.P[4].T[0].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFT2,tofd_tamex.tamex_3.time_fine[6],TOFD.P[4].T[0].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFT3,tofd_tamex.tamex_3.time_fine[10],TOFD.P[4].T[0].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFT4,tofd_tamex.tamex_3.time_fine[14],TOFD.P[4].T[0].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFT5,tofd_tamex.tamex_3.time_fine[18],TOFD.P[4].T[0].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T1_TFT6,tofd_tamex.tamex_3.time_fine[22],TOFD.P[4].T[0].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCL1,tofd_tamex.tamex_3.time_coarse[3],TOFD.P[4].T[1].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCL2,tofd_tamex.tamex_3.time_coarse[7],TOFD.P[4].T[1].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCL3,tofd_tamex.tamex_3.time_coarse[11],TOFD.P[4].T[1].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCL4,tofd_tamex.tamex_3.time_coarse[15],TOFD.P[4].T[1].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCL5,tofd_tamex.tamex_3.time_coarse[19],TOFD.P[4].T[1].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCL6,tofd_tamex.tamex_3.time_coarse[23],TOFD.P[4].T[1].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCT1,tofd_tamex.tamex_3.time_coarse[4],TOFD.P[4].T[1].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCT2,tofd_tamex.tamex_3.time_coarse[8],TOFD.P[4].T[1].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCT3,tofd_tamex.tamex_3.time_coarse[12],TOFD.P[4].T[1].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCT4,tofd_tamex.tamex_3.time_coarse[16],TOFD.P[4].T[1].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCT5,tofd_tamex.tamex_3.time_coarse[20],TOFD.P[4].T[1].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P5T2_TCT6,tofd_tamex.tamex_3.time_coarse[24],TOFD.P[4].T[1].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFL1,tofd_tamex.tamex_3.time_fine[3],TOFD.P[4].T[1].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFL2,tofd_tamex.tamex_3.time_fine[7],TOFD.P[4].T[1].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFL3,tofd_tamex.tamex_3.time_fine[11],TOFD.P[4].T[1].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFL4,tofd_tamex.tamex_3.time_fine[15],TOFD.P[4].T[1].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFL5,tofd_tamex.tamex_3.time_fine[19],TOFD.P[4].T[1].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFL6,tofd_tamex.tamex_3.time_fine[23],TOFD.P[4].T[1].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFT1,tofd_tamex.tamex_3.time_fine[4],TOFD.P[4].T[1].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFT2,tofd_tamex.tamex_3.time_fine[8],TOFD.P[4].T[1].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFT3,tofd_tamex.tamex_3.time_fine[12],TOFD.P[4].T[1].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFT4,tofd_tamex.tamex_3.time_fine[16],TOFD.P[4].T[1].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFT5,tofd_tamex.tamex_3.time_fine[20],TOFD.P[4].T[1].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P5T2_TFT6,tofd_tamex.tamex_3.time_fine[24],TOFD.P[4].T[1].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCL1,tofd_tamex.tamex_4.time_coarse[1],TOFD.P[5].T[0].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCL2,tofd_tamex.tamex_4.time_coarse[5],TOFD.P[5].T[0].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCL3,tofd_tamex.tamex_4.time_coarse[9],TOFD.P[5].T[0].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCL4,tofd_tamex.tamex_4.time_coarse[13],TOFD.P[5].T[0].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCL5,tofd_tamex.tamex_4.time_coarse[17],TOFD.P[5].T[0].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCL6,tofd_tamex.tamex_4.time_coarse[21],TOFD.P[5].T[0].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCT1,tofd_tamex.tamex_4.time_coarse[2],TOFD.P[5].T[0].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCT2,tofd_tamex.tamex_4.time_coarse[6],TOFD.P[5].T[0].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCT3,tofd_tamex.tamex_4.time_coarse[10],TOFD.P[5].T[0].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCT4,tofd_tamex.tamex_4.time_coarse[14],TOFD.P[5].T[0].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCT5,tofd_tamex.tamex_4.time_coarse[18],TOFD.P[5].T[0].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T1_TCT6,tofd_tamex.tamex_4.time_coarse[22],TOFD.P[5].T[0].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFL1,tofd_tamex.tamex_4.time_fine[1],TOFD.P[5].T[0].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFL2,tofd_tamex.tamex_4.time_fine[5],TOFD.P[5].T[0].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFL3,tofd_tamex.tamex_4.time_fine[9],TOFD.P[5].T[0].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFL4,tofd_tamex.tamex_4.time_fine[13],TOFD.P[5].T[0].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFL5,tofd_tamex.tamex_4.time_fine[17],TOFD.P[5].T[0].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFL6,tofd_tamex.tamex_4.time_fine[21],TOFD.P[5].T[0].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFT1,tofd_tamex.tamex_4.time_fine[2],TOFD.P[5].T[0].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFT2,tofd_tamex.tamex_4.time_fine[6],TOFD.P[5].T[0].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFT3,tofd_tamex.tamex_4.time_fine[10],TOFD.P[5].T[0].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFT4,tofd_tamex.tamex_4.time_fine[14],TOFD.P[5].T[0].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFT5,tofd_tamex.tamex_4.time_fine[18],TOFD.P[5].T[0].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T1_TFT6,tofd_tamex.tamex_4.time_fine[22],TOFD.P[5].T[0].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCL1,tofd_tamex.tamex_4.time_coarse[3],TOFD.P[5].T[1].TCL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCL2,tofd_tamex.tamex_4.time_coarse[7],TOFD.P[5].T[1].TCL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCL3,tofd_tamex.tamex_4.time_coarse[11],TOFD.P[5].T[1].TCL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCL4,tofd_tamex.tamex_4.time_coarse[15],TOFD.P[5].T[1].TCL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCL5,tofd_tamex.tamex_4.time_coarse[19],TOFD.P[5].T[1].TCL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCL6,tofd_tamex.tamex_4.time_coarse[23],TOFD.P[5].T[1].TCL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCT1,tofd_tamex.tamex_4.time_coarse[4],TOFD.P[5].T[1].TCT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCT2,tofd_tamex.tamex_4.time_coarse[8],TOFD.P[5].T[1].TCT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCT3,tofd_tamex.tamex_4.time_coarse[12],TOFD.P[5].T[1].TCT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCT4,tofd_tamex.tamex_4.time_coarse[16],TOFD.P[5].T[1].TCT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCT5,tofd_tamex.tamex_4.time_coarse[20],TOFD.P[5].T[1].TCT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_P6T2_TCT6,tofd_tamex.tamex_4.time_coarse[24],TOFD.P[5].T[1].TCT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFL1,tofd_tamex.tamex_4.time_fine[3],TOFD.P[5].T[1].TFL[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFL2,tofd_tamex.tamex_4.time_fine[7],TOFD.P[5].T[1].TFL[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFL3,tofd_tamex.tamex_4.time_fine[11],TOFD.P[5].T[1].TFL[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFL4,tofd_tamex.tamex_4.time_fine[15],TOFD.P[5].T[1].TFL[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFL5,tofd_tamex.tamex_4.time_fine[19],TOFD.P[5].T[1].TFL[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFL6,tofd_tamex.tamex_4.time_fine[23],TOFD.P[5].T[1].TFL[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFT1,tofd_tamex.tamex_4.time_fine[4],TOFD.P[5].T[1].TFT[0]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFT2,tofd_tamex.tamex_4.time_fine[8],TOFD.P[5].T[1].TFT[1]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFT3,tofd_tamex.tamex_4.time_fine[12],TOFD.P[5].T[1].TFT[2]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFT4,tofd_tamex.tamex_4.time_fine[16],TOFD.P[5].T[1].TFT[3]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFT5,tofd_tamex.tamex_4.time_fine[20],TOFD.P[5].T[1].TFT[4]/*multi:*/[0]);
SIGNAL_MAPPING(DATA12,TOFD_P6T2_TFT6,tofd_tamex.tamex_4.time_fine[24],TOFD.P[5].T[1].TFT[5]/*multi:*/[0]);
SIGNAL_MAPPING(DATA16,TOFD_VFTX2_T1,tofd_vme.vftx2_1.time_trigger,TOFD.VFTX[1].T[0]);
SIGNAL_MAPPING(DATA16,TOFD_VFTX2_T2,tofd_vme.vftx2_2.time_trigger,TOFD.VFTX[1].T[1]);
SIGNAL_MAPPING(DATA16,TOFD_VFTX2_T3,tofd_vme.vftx2_3.time_trigger,TOFD.VFTX[1].T[2]);
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S1,los_sampler.sampler.sampler[0],TRLO.SAMPLER.S[0]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,0)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S10,los_sampler.sampler.sampler[9],TRLO.SAMPLER.S[9]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,9)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S100,los_sampler.sampler.sampler[99],TRLO.SAMPLER.S[99]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,99)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S101,los_sampler.sampler.sampler[100],TRLO.SAMPLER.S[100]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,100)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S102,los_sampler.sampler.sampler[101],TRLO.SAMPLER.S[101]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,101)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S103,los_sampler.sampler.sampler[102],TRLO.SAMPLER.S[102]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,102)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S104,los_sampler.sampler.sampler[103],TRLO.SAMPLER.S[103]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,103)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S105,los_sampler.sampler.sampler[104],TRLO.SAMPLER.S[104]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,104)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S106,los_sampler.sampler.sampler[105],TRLO.SAMPLER.S[105]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,105)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S107,los_sampler.sampler.sampler[106],TRLO.SAMPLER.S[106]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,106)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S108,los_sampler.sampler.sampler[107],TRLO.SAMPLER.S[107]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,107)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S109,los_sampler.sampler.sampler[108],TRLO.SAMPLER.S[108]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,108)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S11,los_sampler.sampler.sampler[10],TRLO.SAMPLER.S[10]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,10)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S110,los_sampler.sampler.sampler[109],TRLO.SAMPLER.S[109]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,109)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S111,los_sampler.sampler.sampler[110],TRLO.SAMPLER.S[110]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,110)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S112,los_sampler.sampler.sampler[111],TRLO.SAMPLER.S[111]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,111)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S113,los_sampler.sampler.sampler[112],TRLO.SAMPLER.S[112]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,112)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S114,los_sampler.sampler.sampler[113],TRLO.SAMPLER.S[113]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,113)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S115,los_sampler.sampler.sampler[114],TRLO.SAMPLER.S[114]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,114)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S116,los_sampler.sampler.sampler[115],TRLO.SAMPLER.S[115]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,115)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S117,los_sampler.sampler.sampler[116],TRLO.SAMPLER.S[116]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,116)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S118,los_sampler.sampler.sampler[117],TRLO.SAMPLER.S[117]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,117)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S119,los_sampler.sampler.sampler[118],TRLO.SAMPLER.S[118]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,118)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S12,los_sampler.sampler.sampler[11],TRLO.SAMPLER.S[11]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,11)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S120,los_sampler.sampler.sampler[119],TRLO.SAMPLER.S[119]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,119)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S121,los_sampler.sampler.sampler[120],TRLO.SAMPLER.S[120]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,120)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S122,los_sampler.sampler.sampler[121],TRLO.SAMPLER.S[121]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,121)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S123,los_sampler.sampler.sampler[122],TRLO.SAMPLER.S[122]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,122)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S124,los_sampler.sampler.sampler[123],TRLO.SAMPLER.S[123]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,123)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S125,los_sampler.sampler.sampler[124],TRLO.SAMPLER.S[124]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,124)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S126,los_sampler.sampler.sampler[125],TRLO.SAMPLER.S[125]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,125)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S127,los_sampler.sampler.sampler[126],TRLO.SAMPLER.S[126]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,126)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S128,los_sampler.sampler.sampler[127],TRLO.SAMPLER.S[127]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,127)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S129,los_sampler.sampler.sampler[128],TRLO.SAMPLER.S[128]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,128)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S13,los_sampler.sampler.sampler[12],TRLO.SAMPLER.S[12]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,12)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S130,los_sampler.sampler.sampler[129],TRLO.SAMPLER.S[129]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,129)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S131,los_sampler.sampler.sampler[130],TRLO.SAMPLER.S[130]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,130)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S132,los_sampler.sampler.sampler[131],TRLO.SAMPLER.S[131]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,131)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S133,los_sampler.sampler.sampler[132],TRLO.SAMPLER.S[132]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,132)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S134,los_sampler.sampler.sampler[133],TRLO.SAMPLER.S[133]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,133)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S135,los_sampler.sampler.sampler[134],TRLO.SAMPLER.S[134]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,134)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S136,los_sampler.sampler.sampler[135],TRLO.SAMPLER.S[135]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,135)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S137,los_sampler.sampler.sampler[136],TRLO.SAMPLER.S[136]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,136)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S138,los_sampler.sampler.sampler[137],TRLO.SAMPLER.S[137]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,137)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S139,los_sampler.sampler.sampler[138],TRLO.SAMPLER.S[138]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,138)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S14,los_sampler.sampler.sampler[13],TRLO.SAMPLER.S[13]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,13)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S140,los_sampler.sampler.sampler[139],TRLO.SAMPLER.S[139]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,139)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S141,los_sampler.sampler.sampler[140],TRLO.SAMPLER.S[140]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,140)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S142,los_sampler.sampler.sampler[141],TRLO.SAMPLER.S[141]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,141)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S143,los_sampler.sampler.sampler[142],TRLO.SAMPLER.S[142]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,142)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S144,los_sampler.sampler.sampler[143],TRLO.SAMPLER.S[143]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,143)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S145,los_sampler.sampler.sampler[144],TRLO.SAMPLER.S[144]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,144)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S146,los_sampler.sampler.sampler[145],TRLO.SAMPLER.S[145]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,145)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S147,los_sampler.sampler.sampler[146],TRLO.SAMPLER.S[146]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,146)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S148,los_sampler.sampler.sampler[147],TRLO.SAMPLER.S[147]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,147)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S149,los_sampler.sampler.sampler[148],TRLO.SAMPLER.S[148]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,148)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S15,los_sampler.sampler.sampler[14],TRLO.SAMPLER.S[14]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,14)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S150,los_sampler.sampler.sampler[149],TRLO.SAMPLER.S[149]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,149)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S151,los_sampler.sampler.sampler[150],TRLO.SAMPLER.S[150]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,150)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S152,los_sampler.sampler.sampler[151],TRLO.SAMPLER.S[151]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,151)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S153,los_sampler.sampler.sampler[152],TRLO.SAMPLER.S[152]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,152)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S154,los_sampler.sampler.sampler[153],TRLO.SAMPLER.S[153]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,153)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S155,los_sampler.sampler.sampler[154],TRLO.SAMPLER.S[154]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,154)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S156,los_sampler.sampler.sampler[155],TRLO.SAMPLER.S[155]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,155)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S157,los_sampler.sampler.sampler[156],TRLO.SAMPLER.S[156]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,156)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S158,los_sampler.sampler.sampler[157],TRLO.SAMPLER.S[157]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,157)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S159,los_sampler.sampler.sampler[158],TRLO.SAMPLER.S[158]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,158)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S16,los_sampler.sampler.sampler[15],TRLO.SAMPLER.S[15]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,15)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S160,los_sampler.sampler.sampler[159],TRLO.SAMPLER.S[159]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,159)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S161,los_sampler.sampler.sampler[160],TRLO.SAMPLER.S[160]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,160)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S162,los_sampler.sampler.sampler[161],TRLO.SAMPLER.S[161]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,161)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S163,los_sampler.sampler.sampler[162],TRLO.SAMPLER.S[162]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,162)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S164,los_sampler.sampler.sampler[163],TRLO.SAMPLER.S[163]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,163)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S165,los_sampler.sampler.sampler[164],TRLO.SAMPLER.S[164]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,164)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S166,los_sampler.sampler.sampler[165],TRLO.SAMPLER.S[165]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,165)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S167,los_sampler.sampler.sampler[166],TRLO.SAMPLER.S[166]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,166)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S168,los_sampler.sampler.sampler[167],TRLO.SAMPLER.S[167]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,167)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S169,los_sampler.sampler.sampler[168],TRLO.SAMPLER.S[168]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,168)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S17,los_sampler.sampler.sampler[16],TRLO.SAMPLER.S[16]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,16)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S170,los_sampler.sampler.sampler[169],TRLO.SAMPLER.S[169]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,169)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S171,los_sampler.sampler.sampler[170],TRLO.SAMPLER.S[170]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,170)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S172,los_sampler.sampler.sampler[171],TRLO.SAMPLER.S[171]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,171)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S173,los_sampler.sampler.sampler[172],TRLO.SAMPLER.S[172]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,172)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S174,los_sampler.sampler.sampler[173],TRLO.SAMPLER.S[173]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,173)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S175,los_sampler.sampler.sampler[174],TRLO.SAMPLER.S[174]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,174)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S176,los_sampler.sampler.sampler[175],TRLO.SAMPLER.S[175]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,175)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S177,los_sampler.sampler.sampler[176],TRLO.SAMPLER.S[176]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,176)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S178,los_sampler.sampler.sampler[177],TRLO.SAMPLER.S[177]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,177)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S179,los_sampler.sampler.sampler[178],TRLO.SAMPLER.S[178]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,178)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S18,los_sampler.sampler.sampler[17],TRLO.SAMPLER.S[17]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,17)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S180,los_sampler.sampler.sampler[179],TRLO.SAMPLER.S[179]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,179)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S181,los_sampler.sampler.sampler[180],TRLO.SAMPLER.S[180]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,180)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S182,los_sampler.sampler.sampler[181],TRLO.SAMPLER.S[181]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,181)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S183,los_sampler.sampler.sampler[182],TRLO.SAMPLER.S[182]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,182)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S184,los_sampler.sampler.sampler[183],TRLO.SAMPLER.S[183]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,183)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S185,los_sampler.sampler.sampler[184],TRLO.SAMPLER.S[184]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,184)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S186,los_sampler.sampler.sampler[185],TRLO.SAMPLER.S[185]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,185)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S187,los_sampler.sampler.sampler[186],TRLO.SAMPLER.S[186]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,186)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S188,los_sampler.sampler.sampler[187],TRLO.SAMPLER.S[187]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,187)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S189,los_sampler.sampler.sampler[188],TRLO.SAMPLER.S[188]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,188)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S19,los_sampler.sampler.sampler[18],TRLO.SAMPLER.S[18]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,18)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S190,los_sampler.sampler.sampler[189],TRLO.SAMPLER.S[189]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,189)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S191,los_sampler.sampler.sampler[190],TRLO.SAMPLER.S[190]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,190)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S192,los_sampler.sampler.sampler[191],TRLO.SAMPLER.S[191]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,191)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S193,los_sampler.sampler.sampler[192],TRLO.SAMPLER.S[192]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,192)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S194,los_sampler.sampler.sampler[193],TRLO.SAMPLER.S[193]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,193)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S195,los_sampler.sampler.sampler[194],TRLO.SAMPLER.S[194]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,194)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S196,los_sampler.sampler.sampler[195],TRLO.SAMPLER.S[195]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,195)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S197,los_sampler.sampler.sampler[196],TRLO.SAMPLER.S[196]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,196)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S198,los_sampler.sampler.sampler[197],TRLO.SAMPLER.S[197]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,197)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S199,los_sampler.sampler.sampler[198],TRLO.SAMPLER.S[198]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,198)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S2,los_sampler.sampler.sampler[1],TRLO.SAMPLER.S[1]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,1)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S20,los_sampler.sampler.sampler[19],TRLO.SAMPLER.S[19]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,19)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S200,los_sampler.sampler.sampler[199],TRLO.SAMPLER.S[199]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,199)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S201,los_sampler.sampler.sampler[200],TRLO.SAMPLER.S[200]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,200)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S202,los_sampler.sampler.sampler[201],TRLO.SAMPLER.S[201]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,201)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S203,los_sampler.sampler.sampler[202],TRLO.SAMPLER.S[202]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,202)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S204,los_sampler.sampler.sampler[203],TRLO.SAMPLER.S[203]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,203)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S205,los_sampler.sampler.sampler[204],TRLO.SAMPLER.S[204]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,204)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S206,los_sampler.sampler.sampler[205],TRLO.SAMPLER.S[205]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,205)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S207,los_sampler.sampler.sampler[206],TRLO.SAMPLER.S[206]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,206)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S208,los_sampler.sampler.sampler[207],TRLO.SAMPLER.S[207]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,207)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S209,los_sampler.sampler.sampler[208],TRLO.SAMPLER.S[208]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,208)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S21,los_sampler.sampler.sampler[20],TRLO.SAMPLER.S[20]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,20)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S210,los_sampler.sampler.sampler[209],TRLO.SAMPLER.S[209]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,209)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S211,los_sampler.sampler.sampler[210],TRLO.SAMPLER.S[210]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,210)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S212,los_sampler.sampler.sampler[211],TRLO.SAMPLER.S[211]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,211)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S213,los_sampler.sampler.sampler[212],TRLO.SAMPLER.S[212]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,212)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S214,los_sampler.sampler.sampler[213],TRLO.SAMPLER.S[213]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,213)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S215,los_sampler.sampler.sampler[214],TRLO.SAMPLER.S[214]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,214)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S216,los_sampler.sampler.sampler[215],TRLO.SAMPLER.S[215]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,215)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S217,los_sampler.sampler.sampler[216],TRLO.SAMPLER.S[216]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,216)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S218,los_sampler.sampler.sampler[217],TRLO.SAMPLER.S[217]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,217)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S219,los_sampler.sampler.sampler[218],TRLO.SAMPLER.S[218]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,218)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S22,los_sampler.sampler.sampler[21],TRLO.SAMPLER.S[21]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,21)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S220,los_sampler.sampler.sampler[219],TRLO.SAMPLER.S[219]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,219)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S221,los_sampler.sampler.sampler[220],TRLO.SAMPLER.S[220]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,220)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S222,los_sampler.sampler.sampler[221],TRLO.SAMPLER.S[221]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,221)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S223,los_sampler.sampler.sampler[222],TRLO.SAMPLER.S[222]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,222)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S224,los_sampler.sampler.sampler[223],TRLO.SAMPLER.S[223]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,223)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S225,los_sampler.sampler.sampler[224],TRLO.SAMPLER.S[224]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,224)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S226,los_sampler.sampler.sampler[225],TRLO.SAMPLER.S[225]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,225)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S227,los_sampler.sampler.sampler[226],TRLO.SAMPLER.S[226]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,226)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S228,los_sampler.sampler.sampler[227],TRLO.SAMPLER.S[227]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,227)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S229,los_sampler.sampler.sampler[228],TRLO.SAMPLER.S[228]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,228)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S23,los_sampler.sampler.sampler[22],TRLO.SAMPLER.S[22]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,22)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S230,los_sampler.sampler.sampler[229],TRLO.SAMPLER.S[229]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,229)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S231,los_sampler.sampler.sampler[230],TRLO.SAMPLER.S[230]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,230)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S232,los_sampler.sampler.sampler[231],TRLO.SAMPLER.S[231]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,231)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S233,los_sampler.sampler.sampler[232],TRLO.SAMPLER.S[232]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,232)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S234,los_sampler.sampler.sampler[233],TRLO.SAMPLER.S[233]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,233)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S235,los_sampler.sampler.sampler[234],TRLO.SAMPLER.S[234]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,234)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S236,los_sampler.sampler.sampler[235],TRLO.SAMPLER.S[235]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,235)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S237,los_sampler.sampler.sampler[236],TRLO.SAMPLER.S[236]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,236)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S238,los_sampler.sampler.sampler[237],TRLO.SAMPLER.S[237]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,237)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S239,los_sampler.sampler.sampler[238],TRLO.SAMPLER.S[238]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,238)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S24,los_sampler.sampler.sampler[23],TRLO.SAMPLER.S[23]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,23)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S240,los_sampler.sampler.sampler[239],TRLO.SAMPLER.S[239]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,239)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S241,los_sampler.sampler.sampler[240],TRLO.SAMPLER.S[240]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,240)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S242,los_sampler.sampler.sampler[241],TRLO.SAMPLER.S[241]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,241)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S243,los_sampler.sampler.sampler[242],TRLO.SAMPLER.S[242]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,242)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S244,los_sampler.sampler.sampler[243],TRLO.SAMPLER.S[243]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,243)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S245,los_sampler.sampler.sampler[244],TRLO.SAMPLER.S[244]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,244)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S246,los_sampler.sampler.sampler[245],TRLO.SAMPLER.S[245]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,245)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S247,los_sampler.sampler.sampler[246],TRLO.SAMPLER.S[246]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,246)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S248,los_sampler.sampler.sampler[247],TRLO.SAMPLER.S[247]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,247)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S249,los_sampler.sampler.sampler[248],TRLO.SAMPLER.S[248]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,248)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S25,los_sampler.sampler.sampler[24],TRLO.SAMPLER.S[24]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,24)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S250,los_sampler.sampler.sampler[249],TRLO.SAMPLER.S[249]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,249)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S251,los_sampler.sampler.sampler[250],TRLO.SAMPLER.S[250]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,250)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S252,los_sampler.sampler.sampler[251],TRLO.SAMPLER.S[251]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,251)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S253,los_sampler.sampler.sampler[252],TRLO.SAMPLER.S[252]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,252)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S254,los_sampler.sampler.sampler[253],TRLO.SAMPLER.S[253]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,253)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S255,los_sampler.sampler.sampler[254],TRLO.SAMPLER.S[254]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,254)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S256,los_sampler.sampler.sampler[255],TRLO.SAMPLER.S[255]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,255)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S257,los_sampler.sampler.sampler[256],TRLO.SAMPLER.S[256]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,256)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S258,los_sampler.sampler.sampler[257],TRLO.SAMPLER.S[257]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,257)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S259,los_sampler.sampler.sampler[258],TRLO.SAMPLER.S[258]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,258)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S26,los_sampler.sampler.sampler[25],TRLO.SAMPLER.S[25]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,25)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S260,los_sampler.sampler.sampler[259],TRLO.SAMPLER.S[259]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,259)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S261,los_sampler.sampler.sampler[260],TRLO.SAMPLER.S[260]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,260)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S262,los_sampler.sampler.sampler[261],TRLO.SAMPLER.S[261]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,261)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S263,los_sampler.sampler.sampler[262],TRLO.SAMPLER.S[262]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,262)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S264,los_sampler.sampler.sampler[263],TRLO.SAMPLER.S[263]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,263)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S265,los_sampler.sampler.sampler[264],TRLO.SAMPLER.S[264]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,264)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S266,los_sampler.sampler.sampler[265],TRLO.SAMPLER.S[265]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,265)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S267,los_sampler.sampler.sampler[266],TRLO.SAMPLER.S[266]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,266)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S268,los_sampler.sampler.sampler[267],TRLO.SAMPLER.S[267]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,267)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S269,los_sampler.sampler.sampler[268],TRLO.SAMPLER.S[268]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,268)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S27,los_sampler.sampler.sampler[26],TRLO.SAMPLER.S[26]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,26)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S270,los_sampler.sampler.sampler[269],TRLO.SAMPLER.S[269]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,269)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S271,los_sampler.sampler.sampler[270],TRLO.SAMPLER.S[270]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,270)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S272,los_sampler.sampler.sampler[271],TRLO.SAMPLER.S[271]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,271)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S273,los_sampler.sampler.sampler[272],TRLO.SAMPLER.S[272]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,272)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S274,los_sampler.sampler.sampler[273],TRLO.SAMPLER.S[273]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,273)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S275,los_sampler.sampler.sampler[274],TRLO.SAMPLER.S[274]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,274)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S276,los_sampler.sampler.sampler[275],TRLO.SAMPLER.S[275]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,275)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S277,los_sampler.sampler.sampler[276],TRLO.SAMPLER.S[276]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,276)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S278,los_sampler.sampler.sampler[277],TRLO.SAMPLER.S[277]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,277)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S279,los_sampler.sampler.sampler[278],TRLO.SAMPLER.S[278]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,278)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S28,los_sampler.sampler.sampler[27],TRLO.SAMPLER.S[27]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,27)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S280,los_sampler.sampler.sampler[279],TRLO.SAMPLER.S[279]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,279)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S281,los_sampler.sampler.sampler[280],TRLO.SAMPLER.S[280]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,280)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S282,los_sampler.sampler.sampler[281],TRLO.SAMPLER.S[281]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,281)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S283,los_sampler.sampler.sampler[282],TRLO.SAMPLER.S[282]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,282)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S284,los_sampler.sampler.sampler[283],TRLO.SAMPLER.S[283]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,283)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S285,los_sampler.sampler.sampler[284],TRLO.SAMPLER.S[284]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,284)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S286,los_sampler.sampler.sampler[285],TRLO.SAMPLER.S[285]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,285)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S287,los_sampler.sampler.sampler[286],TRLO.SAMPLER.S[286]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,286)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S288,los_sampler.sampler.sampler[287],TRLO.SAMPLER.S[287]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,287)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S289,los_sampler.sampler.sampler[288],TRLO.SAMPLER.S[288]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,288)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S29,los_sampler.sampler.sampler[28],TRLO.SAMPLER.S[28]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,28)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S290,los_sampler.sampler.sampler[289],TRLO.SAMPLER.S[289]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,289)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S291,los_sampler.sampler.sampler[290],TRLO.SAMPLER.S[290]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,290)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S292,los_sampler.sampler.sampler[291],TRLO.SAMPLER.S[291]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,291)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S293,los_sampler.sampler.sampler[292],TRLO.SAMPLER.S[292]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,292)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S294,los_sampler.sampler.sampler[293],TRLO.SAMPLER.S[293]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,293)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S295,los_sampler.sampler.sampler[294],TRLO.SAMPLER.S[294]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,294)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S296,los_sampler.sampler.sampler[295],TRLO.SAMPLER.S[295]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,295)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S297,los_sampler.sampler.sampler[296],TRLO.SAMPLER.S[296]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,296)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S298,los_sampler.sampler.sampler[297],TRLO.SAMPLER.S[297]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,297)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S299,los_sampler.sampler.sampler[298],TRLO.SAMPLER.S[298]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,298)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S3,los_sampler.sampler.sampler[2],TRLO.SAMPLER.S[2]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,2)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S30,los_sampler.sampler.sampler[29],TRLO.SAMPLER.S[29]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,29)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S300,los_sampler.sampler.sampler[299],TRLO.SAMPLER.S[299]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,299)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S301,los_sampler.sampler.sampler[300],TRLO.SAMPLER.S[300]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,300)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S302,los_sampler.sampler.sampler[301],TRLO.SAMPLER.S[301]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,301)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S303,los_sampler.sampler.sampler[302],TRLO.SAMPLER.S[302]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,302)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S304,los_sampler.sampler.sampler[303],TRLO.SAMPLER.S[303]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,303)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S305,los_sampler.sampler.sampler[304],TRLO.SAMPLER.S[304]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,304)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S306,los_sampler.sampler.sampler[305],TRLO.SAMPLER.S[305]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,305)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S307,los_sampler.sampler.sampler[306],TRLO.SAMPLER.S[306]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,306)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S308,los_sampler.sampler.sampler[307],TRLO.SAMPLER.S[307]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,307)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S309,los_sampler.sampler.sampler[308],TRLO.SAMPLER.S[308]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,308)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S31,los_sampler.sampler.sampler[30],TRLO.SAMPLER.S[30]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,30)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S310,los_sampler.sampler.sampler[309],TRLO.SAMPLER.S[309]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,309)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S311,los_sampler.sampler.sampler[310],TRLO.SAMPLER.S[310]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,310)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S312,los_sampler.sampler.sampler[311],TRLO.SAMPLER.S[311]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,311)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S313,los_sampler.sampler.sampler[312],TRLO.SAMPLER.S[312]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,312)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S314,los_sampler.sampler.sampler[313],TRLO.SAMPLER.S[313]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,313)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S315,los_sampler.sampler.sampler[314],TRLO.SAMPLER.S[314]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,314)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S316,los_sampler.sampler.sampler[315],TRLO.SAMPLER.S[315]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,315)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S317,los_sampler.sampler.sampler[316],TRLO.SAMPLER.S[316]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,316)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S318,los_sampler.sampler.sampler[317],TRLO.SAMPLER.S[317]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,317)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S319,los_sampler.sampler.sampler[318],TRLO.SAMPLER.S[318]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,318)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S32,los_sampler.sampler.sampler[31],TRLO.SAMPLER.S[31]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,31)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S320,los_sampler.sampler.sampler[319],TRLO.SAMPLER.S[319]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,319)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S321,los_sampler.sampler.sampler[320],TRLO.SAMPLER.S[320]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,320)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S322,los_sampler.sampler.sampler[321],TRLO.SAMPLER.S[321]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,321)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S323,los_sampler.sampler.sampler[322],TRLO.SAMPLER.S[322]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,322)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S324,los_sampler.sampler.sampler[323],TRLO.SAMPLER.S[323]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,323)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S325,los_sampler.sampler.sampler[324],TRLO.SAMPLER.S[324]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,324)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S326,los_sampler.sampler.sampler[325],TRLO.SAMPLER.S[325]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,325)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S327,los_sampler.sampler.sampler[326],TRLO.SAMPLER.S[326]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,326)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S328,los_sampler.sampler.sampler[327],TRLO.SAMPLER.S[327]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,327)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S329,los_sampler.sampler.sampler[328],TRLO.SAMPLER.S[328]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,328)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S33,los_sampler.sampler.sampler[32],TRLO.SAMPLER.S[32]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,32)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S330,los_sampler.sampler.sampler[329],TRLO.SAMPLER.S[329]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,329)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S331,los_sampler.sampler.sampler[330],TRLO.SAMPLER.S[330]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,330)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S332,los_sampler.sampler.sampler[331],TRLO.SAMPLER.S[331]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,331)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S333,los_sampler.sampler.sampler[332],TRLO.SAMPLER.S[332]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,332)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S334,los_sampler.sampler.sampler[333],TRLO.SAMPLER.S[333]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,333)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S335,los_sampler.sampler.sampler[334],TRLO.SAMPLER.S[334]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,334)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S336,los_sampler.sampler.sampler[335],TRLO.SAMPLER.S[335]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,335)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S337,los_sampler.sampler.sampler[336],TRLO.SAMPLER.S[336]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,336)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S338,los_sampler.sampler.sampler[337],TRLO.SAMPLER.S[337]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,337)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S339,los_sampler.sampler.sampler[338],TRLO.SAMPLER.S[338]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,338)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S34,los_sampler.sampler.sampler[33],TRLO.SAMPLER.S[33]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,33)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S340,los_sampler.sampler.sampler[339],TRLO.SAMPLER.S[339]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,339)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S341,los_sampler.sampler.sampler[340],TRLO.SAMPLER.S[340]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,340)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S342,los_sampler.sampler.sampler[341],TRLO.SAMPLER.S[341]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,341)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S343,los_sampler.sampler.sampler[342],TRLO.SAMPLER.S[342]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,342)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S344,los_sampler.sampler.sampler[343],TRLO.SAMPLER.S[343]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,343)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S345,los_sampler.sampler.sampler[344],TRLO.SAMPLER.S[344]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,344)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S346,los_sampler.sampler.sampler[345],TRLO.SAMPLER.S[345]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,345)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S347,los_sampler.sampler.sampler[346],TRLO.SAMPLER.S[346]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,346)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S348,los_sampler.sampler.sampler[347],TRLO.SAMPLER.S[347]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,347)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S349,los_sampler.sampler.sampler[348],TRLO.SAMPLER.S[348]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,348)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S35,los_sampler.sampler.sampler[34],TRLO.SAMPLER.S[34]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,34)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S350,los_sampler.sampler.sampler[349],TRLO.SAMPLER.S[349]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,349)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S351,los_sampler.sampler.sampler[350],TRLO.SAMPLER.S[350]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,350)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S352,los_sampler.sampler.sampler[351],TRLO.SAMPLER.S[351]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,351)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S353,los_sampler.sampler.sampler[352],TRLO.SAMPLER.S[352]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,352)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S354,los_sampler.sampler.sampler[353],TRLO.SAMPLER.S[353]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,353)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S355,los_sampler.sampler.sampler[354],TRLO.SAMPLER.S[354]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,354)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S356,los_sampler.sampler.sampler[355],TRLO.SAMPLER.S[355]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,355)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S357,los_sampler.sampler.sampler[356],TRLO.SAMPLER.S[356]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,356)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S358,los_sampler.sampler.sampler[357],TRLO.SAMPLER.S[357]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,357)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S359,los_sampler.sampler.sampler[358],TRLO.SAMPLER.S[358]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,358)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S36,los_sampler.sampler.sampler[35],TRLO.SAMPLER.S[35]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,35)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S360,los_sampler.sampler.sampler[359],TRLO.SAMPLER.S[359]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,359)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S361,los_sampler.sampler.sampler[360],TRLO.SAMPLER.S[360]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,360)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S362,los_sampler.sampler.sampler[361],TRLO.SAMPLER.S[361]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,361)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S363,los_sampler.sampler.sampler[362],TRLO.SAMPLER.S[362]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,362)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S364,los_sampler.sampler.sampler[363],TRLO.SAMPLER.S[363]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,363)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S365,los_sampler.sampler.sampler[364],TRLO.SAMPLER.S[364]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,364)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S366,los_sampler.sampler.sampler[365],TRLO.SAMPLER.S[365]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,365)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S367,los_sampler.sampler.sampler[366],TRLO.SAMPLER.S[366]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,366)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S368,los_sampler.sampler.sampler[367],TRLO.SAMPLER.S[367]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,367)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S369,los_sampler.sampler.sampler[368],TRLO.SAMPLER.S[368]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,368)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S37,los_sampler.sampler.sampler[36],TRLO.SAMPLER.S[36]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,36)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S370,los_sampler.sampler.sampler[369],TRLO.SAMPLER.S[369]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,369)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S371,los_sampler.sampler.sampler[370],TRLO.SAMPLER.S[370]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,370)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S372,los_sampler.sampler.sampler[371],TRLO.SAMPLER.S[371]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,371)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S373,los_sampler.sampler.sampler[372],TRLO.SAMPLER.S[372]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,372)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S374,los_sampler.sampler.sampler[373],TRLO.SAMPLER.S[373]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,373)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S375,los_sampler.sampler.sampler[374],TRLO.SAMPLER.S[374]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,374)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S376,los_sampler.sampler.sampler[375],TRLO.SAMPLER.S[375]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,375)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S377,los_sampler.sampler.sampler[376],TRLO.SAMPLER.S[376]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,376)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S378,los_sampler.sampler.sampler[377],TRLO.SAMPLER.S[377]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,377)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S379,los_sampler.sampler.sampler[378],TRLO.SAMPLER.S[378]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,378)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S38,los_sampler.sampler.sampler[37],TRLO.SAMPLER.S[37]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,37)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S380,los_sampler.sampler.sampler[379],TRLO.SAMPLER.S[379]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,379)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S381,los_sampler.sampler.sampler[380],TRLO.SAMPLER.S[380]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,380)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S382,los_sampler.sampler.sampler[381],TRLO.SAMPLER.S[381]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,381)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S383,los_sampler.sampler.sampler[382],TRLO.SAMPLER.S[382]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,382)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S384,los_sampler.sampler.sampler[383],TRLO.SAMPLER.S[383]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,383)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S385,los_sampler.sampler.sampler[384],TRLO.SAMPLER.S[384]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,384)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S386,los_sampler.sampler.sampler[385],TRLO.SAMPLER.S[385]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,385)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S387,los_sampler.sampler.sampler[386],TRLO.SAMPLER.S[386]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,386)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S388,los_sampler.sampler.sampler[387],TRLO.SAMPLER.S[387]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,387)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S389,los_sampler.sampler.sampler[388],TRLO.SAMPLER.S[388]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,388)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S39,los_sampler.sampler.sampler[38],TRLO.SAMPLER.S[38]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,38)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S390,los_sampler.sampler.sampler[389],TRLO.SAMPLER.S[389]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,389)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S391,los_sampler.sampler.sampler[390],TRLO.SAMPLER.S[390]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,390)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S392,los_sampler.sampler.sampler[391],TRLO.SAMPLER.S[391]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,391)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S393,los_sampler.sampler.sampler[392],TRLO.SAMPLER.S[392]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,392)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S394,los_sampler.sampler.sampler[393],TRLO.SAMPLER.S[393]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,393)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S395,los_sampler.sampler.sampler[394],TRLO.SAMPLER.S[394]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,394)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S396,los_sampler.sampler.sampler[395],TRLO.SAMPLER.S[395]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,395)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S397,los_sampler.sampler.sampler[396],TRLO.SAMPLER.S[396]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,396)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S398,los_sampler.sampler.sampler[397],TRLO.SAMPLER.S[397]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,397)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S399,los_sampler.sampler.sampler[398],TRLO.SAMPLER.S[398]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,398)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S4,los_sampler.sampler.sampler[3],TRLO.SAMPLER.S[3]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,3)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S40,los_sampler.sampler.sampler[39],TRLO.SAMPLER.S[39]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,39)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S400,los_sampler.sampler.sampler[399],TRLO.SAMPLER.S[399]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,399)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S401,los_sampler.sampler.sampler[400],TRLO.SAMPLER.S[400]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,400)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S402,los_sampler.sampler.sampler[401],TRLO.SAMPLER.S[401]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,401)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S403,los_sampler.sampler.sampler[402],TRLO.SAMPLER.S[402]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,402)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S404,los_sampler.sampler.sampler[403],TRLO.SAMPLER.S[403]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,403)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S405,los_sampler.sampler.sampler[404],TRLO.SAMPLER.S[404]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,404)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S406,los_sampler.sampler.sampler[405],TRLO.SAMPLER.S[405]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,405)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S407,los_sampler.sampler.sampler[406],TRLO.SAMPLER.S[406]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,406)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S408,los_sampler.sampler.sampler[407],TRLO.SAMPLER.S[407]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,407)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S409,los_sampler.sampler.sampler[408],TRLO.SAMPLER.S[408]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,408)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S41,los_sampler.sampler.sampler[40],TRLO.SAMPLER.S[40]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,40)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S410,los_sampler.sampler.sampler[409],TRLO.SAMPLER.S[409]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,409)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S411,los_sampler.sampler.sampler[410],TRLO.SAMPLER.S[410]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,410)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S412,los_sampler.sampler.sampler[411],TRLO.SAMPLER.S[411]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,411)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S413,los_sampler.sampler.sampler[412],TRLO.SAMPLER.S[412]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,412)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S414,los_sampler.sampler.sampler[413],TRLO.SAMPLER.S[413]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,413)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S415,los_sampler.sampler.sampler[414],TRLO.SAMPLER.S[414]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,414)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S416,los_sampler.sampler.sampler[415],TRLO.SAMPLER.S[415]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,415)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S417,los_sampler.sampler.sampler[416],TRLO.SAMPLER.S[416]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,416)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S418,los_sampler.sampler.sampler[417],TRLO.SAMPLER.S[417]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,417)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S419,los_sampler.sampler.sampler[418],TRLO.SAMPLER.S[418]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,418)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S42,los_sampler.sampler.sampler[41],TRLO.SAMPLER.S[41]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,41)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S420,los_sampler.sampler.sampler[419],TRLO.SAMPLER.S[419]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,419)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S421,los_sampler.sampler.sampler[420],TRLO.SAMPLER.S[420]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,420)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S422,los_sampler.sampler.sampler[421],TRLO.SAMPLER.S[421]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,421)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S423,los_sampler.sampler.sampler[422],TRLO.SAMPLER.S[422]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,422)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S424,los_sampler.sampler.sampler[423],TRLO.SAMPLER.S[423]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,423)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S425,los_sampler.sampler.sampler[424],TRLO.SAMPLER.S[424]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,424)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S426,los_sampler.sampler.sampler[425],TRLO.SAMPLER.S[425]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,425)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S427,los_sampler.sampler.sampler[426],TRLO.SAMPLER.S[426]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,426)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S428,los_sampler.sampler.sampler[427],TRLO.SAMPLER.S[427]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,427)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S429,los_sampler.sampler.sampler[428],TRLO.SAMPLER.S[428]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,428)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S43,los_sampler.sampler.sampler[42],TRLO.SAMPLER.S[42]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,42)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S430,los_sampler.sampler.sampler[429],TRLO.SAMPLER.S[429]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,429)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S431,los_sampler.sampler.sampler[430],TRLO.SAMPLER.S[430]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,430)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S432,los_sampler.sampler.sampler[431],TRLO.SAMPLER.S[431]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,431)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S433,los_sampler.sampler.sampler[432],TRLO.SAMPLER.S[432]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,432)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S434,los_sampler.sampler.sampler[433],TRLO.SAMPLER.S[433]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,433)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S435,los_sampler.sampler.sampler[434],TRLO.SAMPLER.S[434]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,434)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S436,los_sampler.sampler.sampler[435],TRLO.SAMPLER.S[435]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,435)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S437,los_sampler.sampler.sampler[436],TRLO.SAMPLER.S[436]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,436)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S438,los_sampler.sampler.sampler[437],TRLO.SAMPLER.S[437]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,437)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S439,los_sampler.sampler.sampler[438],TRLO.SAMPLER.S[438]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,438)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S44,los_sampler.sampler.sampler[43],TRLO.SAMPLER.S[43]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,43)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S440,los_sampler.sampler.sampler[439],TRLO.SAMPLER.S[439]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,439)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S441,los_sampler.sampler.sampler[440],TRLO.SAMPLER.S[440]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,440)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S442,los_sampler.sampler.sampler[441],TRLO.SAMPLER.S[441]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,441)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S443,los_sampler.sampler.sampler[442],TRLO.SAMPLER.S[442]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,442)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S444,los_sampler.sampler.sampler[443],TRLO.SAMPLER.S[443]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,443)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S445,los_sampler.sampler.sampler[444],TRLO.SAMPLER.S[444]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,444)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S446,los_sampler.sampler.sampler[445],TRLO.SAMPLER.S[445]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,445)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S447,los_sampler.sampler.sampler[446],TRLO.SAMPLER.S[446]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,446)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S448,los_sampler.sampler.sampler[447],TRLO.SAMPLER.S[447]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,447)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S449,los_sampler.sampler.sampler[448],TRLO.SAMPLER.S[448]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,448)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S45,los_sampler.sampler.sampler[44],TRLO.SAMPLER.S[44]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,44)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S450,los_sampler.sampler.sampler[449],TRLO.SAMPLER.S[449]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,449)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S451,los_sampler.sampler.sampler[450],TRLO.SAMPLER.S[450]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,450)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S452,los_sampler.sampler.sampler[451],TRLO.SAMPLER.S[451]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,451)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S453,los_sampler.sampler.sampler[452],TRLO.SAMPLER.S[452]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,452)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S454,los_sampler.sampler.sampler[453],TRLO.SAMPLER.S[453]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,453)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S455,los_sampler.sampler.sampler[454],TRLO.SAMPLER.S[454]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,454)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S456,los_sampler.sampler.sampler[455],TRLO.SAMPLER.S[455]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,455)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S457,los_sampler.sampler.sampler[456],TRLO.SAMPLER.S[456]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,456)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S458,los_sampler.sampler.sampler[457],TRLO.SAMPLER.S[457]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,457)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S459,los_sampler.sampler.sampler[458],TRLO.SAMPLER.S[458]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,458)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S46,los_sampler.sampler.sampler[45],TRLO.SAMPLER.S[45]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,45)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S460,los_sampler.sampler.sampler[459],TRLO.SAMPLER.S[459]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,459)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S461,los_sampler.sampler.sampler[460],TRLO.SAMPLER.S[460]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,460)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S462,los_sampler.sampler.sampler[461],TRLO.SAMPLER.S[461]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,461)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S463,los_sampler.sampler.sampler[462],TRLO.SAMPLER.S[462]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,462)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S464,los_sampler.sampler.sampler[463],TRLO.SAMPLER.S[463]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,463)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S465,los_sampler.sampler.sampler[464],TRLO.SAMPLER.S[464]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,464)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S466,los_sampler.sampler.sampler[465],TRLO.SAMPLER.S[465]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,465)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S467,los_sampler.sampler.sampler[466],TRLO.SAMPLER.S[466]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,466)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S468,los_sampler.sampler.sampler[467],TRLO.SAMPLER.S[467]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,467)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S469,los_sampler.sampler.sampler[468],TRLO.SAMPLER.S[468]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,468)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S47,los_sampler.sampler.sampler[46],TRLO.SAMPLER.S[46]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,46)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S470,los_sampler.sampler.sampler[469],TRLO.SAMPLER.S[469]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,469)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S471,los_sampler.sampler.sampler[470],TRLO.SAMPLER.S[470]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,470)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S472,los_sampler.sampler.sampler[471],TRLO.SAMPLER.S[471]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,471)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S473,los_sampler.sampler.sampler[472],TRLO.SAMPLER.S[472]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,472)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S474,los_sampler.sampler.sampler[473],TRLO.SAMPLER.S[473]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,473)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S475,los_sampler.sampler.sampler[474],TRLO.SAMPLER.S[474]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,474)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S476,los_sampler.sampler.sampler[475],TRLO.SAMPLER.S[475]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,475)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S477,los_sampler.sampler.sampler[476],TRLO.SAMPLER.S[476]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,476)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S478,los_sampler.sampler.sampler[477],TRLO.SAMPLER.S[477]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,477)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S479,los_sampler.sampler.sampler[478],TRLO.SAMPLER.S[478]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,478)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S48,los_sampler.sampler.sampler[47],TRLO.SAMPLER.S[47]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,47)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S480,los_sampler.sampler.sampler[479],TRLO.SAMPLER.S[479]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,479)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S481,los_sampler.sampler.sampler[480],TRLO.SAMPLER.S[480]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,480)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S482,los_sampler.sampler.sampler[481],TRLO.SAMPLER.S[481]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,481)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S483,los_sampler.sampler.sampler[482],TRLO.SAMPLER.S[482]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,482)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S484,los_sampler.sampler.sampler[483],TRLO.SAMPLER.S[483]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,483)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S485,los_sampler.sampler.sampler[484],TRLO.SAMPLER.S[484]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,484)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S486,los_sampler.sampler.sampler[485],TRLO.SAMPLER.S[485]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,485)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S487,los_sampler.sampler.sampler[486],TRLO.SAMPLER.S[486]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,486)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S488,los_sampler.sampler.sampler[487],TRLO.SAMPLER.S[487]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,487)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S489,los_sampler.sampler.sampler[488],TRLO.SAMPLER.S[488]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,488)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S49,los_sampler.sampler.sampler[48],TRLO.SAMPLER.S[48]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,48)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S490,los_sampler.sampler.sampler[489],TRLO.SAMPLER.S[489]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,489)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S491,los_sampler.sampler.sampler[490],TRLO.SAMPLER.S[490]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,490)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S492,los_sampler.sampler.sampler[491],TRLO.SAMPLER.S[491]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,491)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S493,los_sampler.sampler.sampler[492],TRLO.SAMPLER.S[492]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,492)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S494,los_sampler.sampler.sampler[493],TRLO.SAMPLER.S[493]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,493)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S495,los_sampler.sampler.sampler[494],TRLO.SAMPLER.S[494]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,494)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S496,los_sampler.sampler.sampler[495],TRLO.SAMPLER.S[495]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,495)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S497,los_sampler.sampler.sampler[496],TRLO.SAMPLER.S[496]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,496)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S498,los_sampler.sampler.sampler[497],TRLO.SAMPLER.S[497]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,497)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S499,los_sampler.sampler.sampler[498],TRLO.SAMPLER.S[498]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,498)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S5,los_sampler.sampler.sampler[4],TRLO.SAMPLER.S[4]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,4)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S50,los_sampler.sampler.sampler[49],TRLO.SAMPLER.S[49]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,49)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S500,los_sampler.sampler.sampler[499],TRLO.SAMPLER.S[499]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,499)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S501,los_sampler.sampler.sampler[500],TRLO.SAMPLER.S[500]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,500)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S502,los_sampler.sampler.sampler[501],TRLO.SAMPLER.S[501]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,501)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S503,los_sampler.sampler.sampler[502],TRLO.SAMPLER.S[502]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,502)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S504,los_sampler.sampler.sampler[503],TRLO.SAMPLER.S[503]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,503)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S505,los_sampler.sampler.sampler[504],TRLO.SAMPLER.S[504]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,504)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S506,los_sampler.sampler.sampler[505],TRLO.SAMPLER.S[505]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,505)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S507,los_sampler.sampler.sampler[506],TRLO.SAMPLER.S[506]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,506)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S508,los_sampler.sampler.sampler[507],TRLO.SAMPLER.S[507]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,507)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S509,los_sampler.sampler.sampler[508],TRLO.SAMPLER.S[508]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,508)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S51,los_sampler.sampler.sampler[50],TRLO.SAMPLER.S[50]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,50)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S510,los_sampler.sampler.sampler[509],TRLO.SAMPLER.S[509]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,509)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S511,los_sampler.sampler.sampler[510],TRLO.SAMPLER.S[510]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,510)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S512,los_sampler.sampler.sampler[511],TRLO.SAMPLER.S[511]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,511)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S52,los_sampler.sampler.sampler[51],TRLO.SAMPLER.S[51]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,51)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S53,los_sampler.sampler.sampler[52],TRLO.SAMPLER.S[52]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,52)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S54,los_sampler.sampler.sampler[53],TRLO.SAMPLER.S[53]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,53)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S55,los_sampler.sampler.sampler[54],TRLO.SAMPLER.S[54]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,54)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S56,los_sampler.sampler.sampler[55],TRLO.SAMPLER.S[55]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,55)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S57,los_sampler.sampler.sampler[56],TRLO.SAMPLER.S[56]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,56)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S58,los_sampler.sampler.sampler[57],TRLO.SAMPLER.S[57]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,57)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S59,los_sampler.sampler.sampler[58],TRLO.SAMPLER.S[58]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,58)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S6,los_sampler.sampler.sampler[5],TRLO.SAMPLER.S[5]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,5)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S60,los_sampler.sampler.sampler[59],TRLO.SAMPLER.S[59]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,59)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S61,los_sampler.sampler.sampler[60],TRLO.SAMPLER.S[60]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,60)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S62,los_sampler.sampler.sampler[61],TRLO.SAMPLER.S[61]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,61)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S63,los_sampler.sampler.sampler[62],TRLO.SAMPLER.S[62]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,62)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S64,los_sampler.sampler.sampler[63],TRLO.SAMPLER.S[63]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,63)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S65,los_sampler.sampler.sampler[64],TRLO.SAMPLER.S[64]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,64)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S66,los_sampler.sampler.sampler[65],TRLO.SAMPLER.S[65]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,65)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S67,los_sampler.sampler.sampler[66],TRLO.SAMPLER.S[66]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,66)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S68,los_sampler.sampler.sampler[67],TRLO.SAMPLER.S[67]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,67)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S69,los_sampler.sampler.sampler[68],TRLO.SAMPLER.S[68]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,68)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S7,los_sampler.sampler.sampler[6],TRLO.SAMPLER.S[6]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,6)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S70,los_sampler.sampler.sampler[69],TRLO.SAMPLER.S[69]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,69)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S71,los_sampler.sampler.sampler[70],TRLO.SAMPLER.S[70]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,70)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S72,los_sampler.sampler.sampler[71],TRLO.SAMPLER.S[71]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,71)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S73,los_sampler.sampler.sampler[72],TRLO.SAMPLER.S[72]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,72)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S74,los_sampler.sampler.sampler[73],TRLO.SAMPLER.S[73]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,73)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S75,los_sampler.sampler.sampler[74],TRLO.SAMPLER.S[74]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,74)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S76,los_sampler.sampler.sampler[75],TRLO.SAMPLER.S[75]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,75)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S77,los_sampler.sampler.sampler[76],TRLO.SAMPLER.S[76]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,76)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S78,los_sampler.sampler.sampler[77],TRLO.SAMPLER.S[77]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,77)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S79,los_sampler.sampler.sampler[78],TRLO.SAMPLER.S[78]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,78)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S8,los_sampler.sampler.sampler[7],TRLO.SAMPLER.S[7]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,7)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S80,los_sampler.sampler.sampler[79],TRLO.SAMPLER.S[79]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,79)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S81,los_sampler.sampler.sampler[80],TRLO.SAMPLER.S[80]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,80)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S82,los_sampler.sampler.sampler[81],TRLO.SAMPLER.S[81]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,81)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S83,los_sampler.sampler.sampler[82],TRLO.SAMPLER.S[82]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,82)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S84,los_sampler.sampler.sampler[83],TRLO.SAMPLER.S[83]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,83)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S85,los_sampler.sampler.sampler[84],TRLO.SAMPLER.S[84]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,84)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S86,los_sampler.sampler.sampler[85],TRLO.SAMPLER.S[85]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,85)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S87,los_sampler.sampler.sampler[86],TRLO.SAMPLER.S[86]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,86)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S88,los_sampler.sampler.sampler[87],TRLO.SAMPLER.S[87]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,87)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S89,los_sampler.sampler.sampler[88],TRLO.SAMPLER.S[88]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,88)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S9,los_sampler.sampler.sampler[8],TRLO.SAMPLER.S[8]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,8)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S90,los_sampler.sampler.sampler[89],TRLO.SAMPLER.S[89]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,89)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S91,los_sampler.sampler.sampler[90],TRLO.SAMPLER.S[90]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,90)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S92,los_sampler.sampler.sampler[91],TRLO.SAMPLER.S[91]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,91)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S93,los_sampler.sampler.sampler[92],TRLO.SAMPLER.S[92]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,92)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S94,los_sampler.sampler.sampler[93],TRLO.SAMPLER.S[93]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,93)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S95,los_sampler.sampler.sampler[94],TRLO.SAMPLER.S[94]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,94)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S96,los_sampler.sampler.sampler[95],TRLO.SAMPLER.S[95]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,95)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S97,los_sampler.sampler.sampler[96],TRLO.SAMPLER.S[96]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,96)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S98,los_sampler.sampler.sampler[97],TRLO.SAMPLER.S[97]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,97)*/
SIGNAL_MAPPING(DATA32,TRLO_SAMPLER_S99,los_sampler.sampler.sampler[98],TRLO.SAMPLER.S[98]);/*,ZERO_SUPPRESS_ITEM(TRLO.SAMPLER.S,98)*/

/** END_EVENT_DATA_MAPPING ********************************************/


/** BEGIN_EVENT_DATA_MAPPING *******************************************
 *
 * Event data mapping.
 *
 * Do not edit - automatically generated.
 */

// The order in this file does not matter.
// This information parsed once and not treated eventwise,
// it is used to initialize a structure.


/** END_EVENT_DATA_MAPPING ********************************************/

/**********************************************************/

/** BEGIN_LOCATIONS ****************************************************
 *
 * File and line locations from the parsed specification files.
 *
 * Do not edit - automatically generated.
 */

// It's left to the compiler to only store one copy of each
// unique string.

location spec_locations[] =
{ 
  { 2, 1, "gen_jun16_U/reparse.uce" },
  { 3, 1, "<built-in>" },
  { 4, 1, "<command-line>" },
  { 5, 1, "/usr/include/stdc-predef.h" },
  { 6, 1, "<command-line>" },
  { 7, 1, "gen_jun16_U/reparse.uce" },
  { 8, 12, "gen_jun16_U/reparse.uce" },
  { 940, 952, "gen_jun16_U/reparse.uce" },
};

/** END_LOCATIONS *****************************************************/

